# setting LC_ALL to "C"
# --> Including file '/publicfs/cms/user/wanghan/CEPCSW/Detector/DetCRD/scripts/bashes/Standalone-Sim-RotCrystal_0014.py'
/cvmfs/sft.cern.ch/lcg/releases/DD4hep/01.25.01-5059b/x86_64-centos7-gcc11-opt/lib:/cvmfs/sft.cern.ch/lcg/releases/XercesC/3.2.3-714f6/x86_64-centos7-gcc11-opt/lib:/cvmfs/sft.cern.ch/lcg/releases/ROOT/6.28.00-a8528/x86_64-centos7-gcc11-opt/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/podio/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/Gaudi/lib:/cvmfs/sft.cern.ch/lcg/releases/MCGenerators/thepeg/2.2.3-22dc4/x86_64-centos7-gcc11-opt/lib/ThePEG:/cvmfs/sft.cern.ch/lcg/releases/MCGenerators/herwig++/7.2.3-c9708/x86_64-centos7-gcc11-opt/lib/Herwig:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/jaxlib/mlir/_mlir_libs:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/torch/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/onnxruntime/capi/:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow/contrib/tensor_forest:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow/python/framework:/cvmfs/sft.cern.ch/lcg/releases/java/8u362-88cd4/x86_64-centos7-gcc11-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib:/cvmfs/sft.cern.ch/lcg/releases/gcc/11.3.0-ad0f5/x86_64-centos7/lib:/cvmfs/sft.cern.ch/lcg/releases/gcc/11.3.0-ad0f5/x86_64-centos7/lib64:/cvmfs/sft.cern.ch/lcg/releases/binutils/2.37-355ed/x86_64-centos7/lib:/cvmfs/sft.cern.ch/lcg/contrib/git/lib64:/publicfs/cms/user/wanghan/CEPCSW/InstallArea/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/k4EDM4hep2LcioConv/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/Garfield++/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/k4LCIOReader/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/GenFit/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/Pandora/LCContent/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/Pandora/PandoraSDK/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/GEAR/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/k4FWCore/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/EDM4hep/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/LCIO/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/LCIO/lib:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/podio/lib64:/cvmfs/cepcsw.ihep.ac.cn/prototype/releases/externals/103.0.2/Gaudi/lib:/cvmfs/sft.cern.ch/lcg/releases/MCGenerators/thepeg/2.2.3-22dc4/x86_64-centos7-gcc11-opt/lib/ThePEG:/cvmfs/sft.cern.ch/lcg/releases/MCGenerators/herwig++/7.2.3-c9708/x86_64-centos7-gcc11-opt/lib/Herwig:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/jaxlib/mlir/_mlir_libs:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/torch/lib:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/onnxruntime/capi/:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow/contrib/tensor_forest:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib/python3.9/site-packages/tensorflow/python/framework:/cvmfs/sft.cern.ch/lcg/releases/java/8u362-88cd4/x86_64-centos7-gcc11-opt/jre/lib/amd64:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib64:/cvmfs/sft.cern.ch/lcg/views/LCG_103/x86_64-centos7-gcc11-opt/lib:/cvmfs/sft.cern.ch/lcg/releases/gcc/11.3.0-ad0f5/x86_64-centos7/lib:/cvmfs/sft.cern.ch/lcg/releases/gcc/11.3.0-ad0f5/x86_64-centos7/lib64:/cvmfs/sft.cern.ch/lcg/releases/binutils/2.37-355ed/x86_64-centos7/lib:/cvmfs/sft.cern.ch/lcg/contrib/git/lib64:/afs/ihep.ac.cn/soft/CMS/root/5.34.36/root/lib:/afs/ihep.ac.cn/soft/CMS/gcc/4.9.1/x86_64-slc6-gcc48-opt/lib64:/afs/ihep.ac.cn/soft/CMS/gcc/4.9.1/x86_64-slc6-gcc48-opt/lib64:/afs/ihep.ac.cn/soft/CMS/gcc/4.9.1/x86_64-slc6-gcc48-opt/lib64:/afs/ihep.ac.cn/soft/CMS/gcc/4.9.1/x86_64-slc6-gcc48-opt/lib64:/cvmfs/sft.cern.ch/lcg/releases/R/4.1.2-dbb9a/x86_64-centos7-gcc11-opt/lib64/R/library/readr/rcon:/cvmfs/sft.cern.ch/lcg/releases/R/4.1.2-dbb9a/x86_64-centos7-gcc11-opt/lib64/R/library/readr/rcon
# <-- End of file '/publicfs/cms/user/wanghan/CEPCSW/Detector/DetCRD/scripts/bashes/Standalone-Sim-RotCrystal_0014.py'
ApplicationMgr    SUCCESS 
====================================================================================================================================
                                                   Welcome to ApplicationMgr (GaudiCoreSvc v36r16)
                                          running on cws043.ihep.ac.cn on Tue Mar  5 17:11:43 2024
====================================================================================================================================
ApplicationMgr       INFO Application Manager Configured successfully
RndmGenSvc.Engine    INFO Generator engine type:CLHEP::HepJamesRandom
RndmGenSvc.Engine    INFO Current Seed:257 Luxury:3
RndmGenSvc.Engine    INFO This is the GEANT4 engine!
RndmGenSvc           INFO Using Random engine:RndmGenSvc.Engine
PersistencyIO    INFO  +++ Set Streamer to dd4hep::OpaqueDataBlock
TGeoManager::TG...   INFO Geometry default, Detector Geometry created
TGeoNavigator::...   INFO --- Maximum geometry depth set to 100
DD4hep           WARN  ++ STD conditions NOT defined by client. NTP defaults taken.
TGeoMixture::Co...WARNING Mixture G4_Au: sum of weights is: 0
TGeoMixture::Co...WARNING Mixture RPCGAS2: sum of weights is: 0.99249
TGeoMixture::Co...WARNING Mixture PEEK-GF30: sum of weights is: 1.03333
TGeoMixture::Co...WARNING Mixture g10-RPC: sum of weights is: 1.10025
Detector         INFO  *********** Created World volume with size:  600  600  600
TGeoManager::Se...   INFO Top volume is world_volume. Master volume is world_volume
This is the double RotatedCrystalCalorimeter:
rmin    = 1900
rmax    = 2200
zhalf   = 3350
alpha   = 20
nphi    = 1276
nz      = 670
Utilities        INFO  +++ setDetectorTypeFlags for detector: EcalBarrel not set.
Single crystal's open angle = 0.282132
AE = 316.419, /_AOE = 2.81961
OA = 1900, /_AEO = 17.1804
OE = 2200, /_EAO = 160
x1 = 8.79948 x2 = 10.3418 y = 10 l = 313.218
module_odd: crystal_id = 1, phiCenter = -1.37181, phi0Center = -1.37181, phiCenter = -1.37181
module_odd: crystal_id = 2, phiCenter = -1.08968, phi0Center = -1.37181, phiCenter = -1.08968
module_odd: crystal_id = 3, phiCenter = -0.80755, phi0Center = -1.37181, phiCenter = -0.80755
module_odd: crystal_id = 4, phiCenter = -0.525418, phi0Center = -1.37181, phiCenter = -0.525418
module_odd: crystal_id = 5, phiCenter = -0.243287, phi0Center = -1.37181, phiCenter = -0.243287
module_odd: crystal_id = 6, phiCenter = 0.0388449, phi0Center = -1.37181, phiCenter = 0.0388449
module_odd: crystal_id = 7, phiCenter = 0.320977, phi0Center = -1.37181, phiCenter = 0.320977
module_odd: crystal_id = 8, phiCenter = 0.603108, phi0Center = -1.37181, phiCenter = 0.603108
module_odd: crystal_id = 9, phiCenter = 0.88524, phi0Center = -1.37181, phiCenter = 0.88524
module_odd: crystal_id = 10, phiCenter = 1.16737, phi0Center = -1.37181, phiCenter = 1.16737
module_odd: crystal_id = 11, phiCenter = 1.4495, phi0Center = -1.37181, phiCenter = 1.4495
module_odd: crystal_id = 12, phiCenter = 1.73163, phi0Center = -1.37181, phiCenter = 1.73163
module_odd: crystal_id = 13, phiCenter = 2.01377, phi0Center = -1.37181, phiCenter = 2.01377
module_odd: crystal_id = 14, phiCenter = 2.2959, phi0Center = -1.37181, phiCenter = 2.2959
module_odd: crystal_id = 15, phiCenter = 2.57803, phi0Center = -1.37181, phiCenter = 2.57803
module_odd: crystal_id = 16, phiCenter = 2.86016, phi0Center = -1.37181, phiCenter = 2.86016
module_odd: crystal_id = 17, phiCenter = 3.14229, phi0Center = -1.37181, phiCenter = 3.14229
module_odd: crystal_id = 18, phiCenter = 3.42442, phi0Center = -1.37181, phiCenter = 3.42442
module_odd: crystal_id = 19, phiCenter = 3.70656, phi0Center = -1.37181, phiCenter = 3.70656
module_odd: crystal_id = 20, phiCenter = 3.98869, phi0Center = -1.37181, phiCenter = 3.98869
module_odd: crystal_id = 21, phiCenter = 4.27082, phi0Center = -1.37181, phiCenter = 4.27082
module_odd: crystal_id = 22, phiCenter = 4.55295, phi0Center = -1.37181, phiCenter = 4.55295
module_odd: crystal_id = 23, phiCenter = 4.83508, phi0Center = -1.37181, phiCenter = 4.83508
module_odd: crystal_id = 24, phiCenter = 5.11721, phi0Center = -1.37181, phiCenter = 5.11721
module_odd: crystal_id = 25, phiCenter = 5.39935, phi0Center = -1.37181, phiCenter = 5.39935
module_odd: crystal_id = 26, phiCenter = 5.68148, phi0Center = -1.37181, phiCenter = 5.68148
module_odd: crystal_id = 27, phiCenter = 5.96361, phi0Center = -1.37181, phiCenter = 5.96361
module_odd: crystal_id = 28, phiCenter = 6.24574, phi0Center = -1.37181, phiCenter = 6.24574
module_odd: crystal_id = 29, phiCenter = 6.52787, phi0Center = -1.37181, phiCenter = 6.52787
module_odd: crystal_id = 30, phiCenter = 6.81, phi0Center = -1.37181, phiCenter = 6.81
module_odd: crystal_id = 31, phiCenter = 7.09214, phi0Center = -1.37181, phiCenter = 7.09214
module_odd: crystal_id = 32, phiCenter = 7.37427, phi0Center = -1.37181, phiCenter = 7.37427
module_odd: crystal_id = 33, phiCenter = 7.6564, phi0Center = -1.37181, phiCenter = 7.6564
module_odd: crystal_id = 34, phiCenter = 7.93853, phi0Center = -1.37181, phiCenter = 7.93853
module_odd: crystal_id = 35, phiCenter = 8.22066, phi0Center = -1.37181, phiCenter = 8.22066
module_odd: crystal_id = 36, phiCenter = 8.50279, phi0Center = -1.37181, phiCenter = 8.50279
module_odd: crystal_id = 37, phiCenter = 8.78493, phi0Center = -1.37181, phiCenter = 8.78493
module_odd: crystal_id = 38, phiCenter = 9.06706, phi0Center = -1.37181, phiCenter = 9.06706
module_odd: crystal_id = 39, phiCenter = 9.34919, phi0Center = -1.37181, phiCenter = 9.34919
module_odd: crystal_id = 40, phiCenter = 9.63132, phi0Center = -1.37181, phiCenter = 9.63132
module_odd: crystal_id = 41, phiCenter = 9.91345, phi0Center = -1.37181, phiCenter = 9.91345
module_odd: crystal_id = 42, phiCenter = 10.1956, phi0Center = -1.37181, phiCenter = 10.1956
module_odd: crystal_id = 43, phiCenter = 10.4777, phi0Center = -1.37181, phiCenter = 10.4777
module_odd: crystal_id = 44, phiCenter = 10.7598, phi0Center = -1.37181, phiCenter = 10.7598
module_odd: crystal_id = 45, phiCenter = 11.042, phi0Center = -1.37181, phiCenter = 11.042
module_odd: crystal_id = 46, phiCenter = 11.3241, phi0Center = -1.37181, phiCenter = 11.3241
module_odd: crystal_id = 47, phiCenter = 11.6062, phi0Center = -1.37181, phiCenter = 11.6062
module_odd: crystal_id = 48, phiCenter = 11.8884, phi0Center = -1.37181, phiCenter = 11.8884
module_odd: crystal_id = 49, phiCenter = 12.1705, phi0Center = -1.37181, phiCenter = 12.1705
module_odd: crystal_id = 50, phiCenter = 12.4526, phi0Center = -1.37181, phiCenter = 12.4526
module_odd: crystal_id = 51, phiCenter = 12.7348, phi0Center = -1.37181, phiCenter = 12.7348
module_odd: crystal_id = 52, phiCenter = 13.0169, phi0Center = -1.37181, phiCenter = 13.0169
module_odd: crystal_id = 53, phiCenter = 13.299, phi0Center = -1.37181, phiCenter = 13.299
module_odd: crystal_id = 54, phiCenter = 13.5812, phi0Center = -1.37181, phiCenter = 13.5812
module_odd: crystal_id = 55, phiCenter = 13.8633, phi0Center = -1.37181, phiCenter = 13.8633
module_odd: crystal_id = 56, phiCenter = 14.1454, phi0Center = -1.37181, phiCenter = 14.1454
module_odd: crystal_id = 57, phiCenter = 14.4276, phi0Center = -1.37181, phiCenter = 14.4276
module_odd: crystal_id = 58, phiCenter = 14.7097, phi0Center = -1.37181, phiCenter = 14.7097
module_odd: crystal_id = 59, phiCenter = 14.9918, phi0Center = -1.37181, phiCenter = 14.9918
module_odd: crystal_id = 60, phiCenter = 15.274, phi0Center = -1.37181, phiCenter = 15.274
module_odd: crystal_id = 61, phiCenter = 15.5561, phi0Center = -1.37181, phiCenter = 15.5561
module_odd: crystal_id = 62, phiCenter = 15.8382, phi0Center = -1.37181, phiCenter = 15.8382
module_odd: crystal_id = 63, phiCenter = 16.1203, phi0Center = -1.37181, phiCenter = 16.1203
module_odd: crystal_id = 64, phiCenter = 16.4025, phi0Center = -1.37181, phiCenter = 16.4025
module_odd: crystal_id = 65, phiCenter = 16.6846, phi0Center = -1.37181, phiCenter = 16.6846
module_odd: crystal_id = 66, phiCenter = 16.9667, phi0Center = -1.37181, phiCenter = 16.9667
module_odd: crystal_id = 67, phiCenter = 17.2489, phi0Center = -1.37181, phiCenter = 17.2489
module_odd: crystal_id = 68, phiCenter = 17.531, phi0Center = -1.37181, phiCenter = 17.531
module_odd: crystal_id = 69, phiCenter = 17.8131, phi0Center = -1.37181, phiCenter = 17.8131
module_odd: crystal_id = 70, phiCenter = 18.0953, phi0Center = -1.37181, phiCenter = 18.0953
module_odd: crystal_id = 71, phiCenter = 18.3774, phi0Center = -1.37181, phiCenter = 18.3774
module_odd: crystal_id = 72, phiCenter = 18.6595, phi0Center = -1.37181, phiCenter = 18.6595
module_odd: crystal_id = 73, phiCenter = 18.9417, phi0Center = -1.37181, phiCenter = 18.9417
module_odd: crystal_id = 74, phiCenter = 19.2238, phi0Center = -1.37181, phiCenter = 19.2238
module_odd: crystal_id = 75, phiCenter = 19.5059, phi0Center = -1.37181, phiCenter = 19.5059
module_odd: crystal_id = 76, phiCenter = 19.7881, phi0Center = -1.37181, phiCenter = 19.7881
module_odd: crystal_id = 77, phiCenter = 20.0702, phi0Center = -1.37181, phiCenter = 20.0702
module_odd: crystal_id = 78, phiCenter = 20.3523, phi0Center = -1.37181, phiCenter = 20.3523
module_odd: crystal_id = 79, phiCenter = 20.6345, phi0Center = -1.37181, phiCenter = 20.6345
module_odd: crystal_id = 80, phiCenter = 20.9166, phi0Center = -1.37181, phiCenter = 20.9166
module_odd: crystal_id = 81, phiCenter = 21.1987, phi0Center = -1.37181, phiCenter = 21.1987
module_odd: crystal_id = 82, phiCenter = 21.4809, phi0Center = -1.37181, phiCenter = 21.4809
module_odd: crystal_id = 83, phiCenter = 21.763, phi0Center = -1.37181, phiCenter = 21.763
module_odd: crystal_id = 84, phiCenter = 22.0451, phi0Center = -1.37181, phiCenter = 22.0451
module_odd: crystal_id = 85, phiCenter = 22.3272, phi0Center = -1.37181, phiCenter = 22.3272
module_odd: crystal_id = 86, phiCenter = 22.6094, phi0Center = -1.37181, phiCenter = 22.6094
module_odd: crystal_id = 87, phiCenter = 22.8915, phi0Center = -1.37181, phiCenter = 22.8915
module_odd: crystal_id = 88, phiCenter = 23.1736, phi0Center = -1.37181, phiCenter = 23.1736
module_odd: crystal_id = 89, phiCenter = 23.4558, phi0Center = -1.37181, phiCenter = 23.4558
module_odd: crystal_id = 90, phiCenter = 23.7379, phi0Center = -1.37181, phiCenter = 23.7379
module_odd: crystal_id = 91, phiCenter = 24.02, phi0Center = -1.37181, phiCenter = 24.02
module_odd: crystal_id = 92, phiCenter = 24.3022, phi0Center = -1.37181, phiCenter = 24.3022
module_odd: crystal_id = 93, phiCenter = 24.5843, phi0Center = -1.37181, phiCenter = 24.5843
module_odd: crystal_id = 94, phiCenter = 24.8664, phi0Center = -1.37181, phiCenter = 24.8664
module_odd: crystal_id = 95, phiCenter = 25.1486, phi0Center = -1.37181, phiCenter = 25.1486
module_odd: crystal_id = 96, phiCenter = 25.4307, phi0Center = -1.37181, phiCenter = 25.4307
module_odd: crystal_id = 97, phiCenter = 25.7128, phi0Center = -1.37181, phiCenter = 25.7128
module_odd: crystal_id = 98, phiCenter = 25.995, phi0Center = -1.37181, phiCenter = 25.995
module_odd: crystal_id = 99, phiCenter = 26.2771, phi0Center = -1.37181, phiCenter = 26.2771
module_odd: crystal_id = 100, phiCenter = 26.5592, phi0Center = -1.37181, phiCenter = 26.5592
module_odd: crystal_id = 101, phiCenter = 26.8414, phi0Center = -1.37181, phiCenter = 26.8414
module_odd: crystal_id = 102, phiCenter = 27.1235, phi0Center = -1.37181, phiCenter = 27.1235
module_odd: crystal_id = 103, phiCenter = 27.4056, phi0Center = -1.37181, phiCenter = 27.4056
module_odd: crystal_id = 104, phiCenter = 27.6877, phi0Center = -1.37181, phiCenter = 27.6877
module_odd: crystal_id = 105, phiCenter = 27.9699, phi0Center = -1.37181, phiCenter = 27.9699
module_odd: crystal_id = 106, phiCenter = 28.252, phi0Center = -1.37181, phiCenter = 28.252
module_odd: crystal_id = 107, phiCenter = 28.5341, phi0Center = -1.37181, phiCenter = 28.5341
module_odd: crystal_id = 108, phiCenter = 28.8163, phi0Center = -1.37181, phiCenter = 28.8163
module_odd: crystal_id = 109, phiCenter = 29.0984, phi0Center = -1.37181, phiCenter = 29.0984
module_odd: crystal_id = 110, phiCenter = 29.3805, phi0Center = -1.37181, phiCenter = 29.3805
module_odd: crystal_id = 111, phiCenter = 29.6627, phi0Center = -1.37181, phiCenter = 29.6627
module_odd: crystal_id = 112, phiCenter = 29.9448, phi0Center = -1.37181, phiCenter = 29.9448
module_odd: crystal_id = 113, phiCenter = 30.2269, phi0Center = -1.37181, phiCenter = 30.2269
module_odd: crystal_id = 114, phiCenter = 30.5091, phi0Center = -1.37181, phiCenter = 30.5091
module_odd: crystal_id = 115, phiCenter = 30.7912, phi0Center = -1.37181, phiCenter = 30.7912
module_odd: crystal_id = 116, phiCenter = 31.0733, phi0Center = -1.37181, phiCenter = 31.0733
module_odd: crystal_id = 117, phiCenter = 31.3555, phi0Center = -1.37181, phiCenter = 31.3555
module_odd: crystal_id = 118, phiCenter = 31.6376, phi0Center = -1.37181, phiCenter = 31.6376
module_odd: crystal_id = 119, phiCenter = 31.9197, phi0Center = -1.37181, phiCenter = 31.9197
module_odd: crystal_id = 120, phiCenter = 32.2019, phi0Center = -1.37181, phiCenter = 32.2019
module_odd: crystal_id = 121, phiCenter = 32.484, phi0Center = -1.37181, phiCenter = 32.484
module_odd: crystal_id = 122, phiCenter = 32.7661, phi0Center = -1.37181, phiCenter = 32.7661
module_odd: crystal_id = 123, phiCenter = 33.0482, phi0Center = -1.37181, phiCenter = 33.0482
module_odd: crystal_id = 124, phiCenter = 33.3304, phi0Center = -1.37181, phiCenter = 33.3304
module_odd: crystal_id = 125, phiCenter = 33.6125, phi0Center = -1.37181, phiCenter = 33.6125
module_odd: crystal_id = 126, phiCenter = 33.8946, phi0Center = -1.37181, phiCenter = 33.8946
module_odd: crystal_id = 127, phiCenter = 34.1768, phi0Center = -1.37181, phiCenter = 34.1768
module_odd: crystal_id = 128, phiCenter = 34.4589, phi0Center = -1.37181, phiCenter = 34.4589
module_odd: crystal_id = 129, phiCenter = 34.741, phi0Center = -1.37181, phiCenter = 34.741
module_odd: crystal_id = 130, phiCenter = 35.0232, phi0Center = -1.37181, phiCenter = 35.0232
module_odd: crystal_id = 131, phiCenter = 35.3053, phi0Center = -1.37181, phiCenter = 35.3053
module_odd: crystal_id = 132, phiCenter = 35.5874, phi0Center = -1.37181, phiCenter = 35.5874
module_odd: crystal_id = 133, phiCenter = 35.8696, phi0Center = -1.37181, phiCenter = 35.8696
module_odd: crystal_id = 134, phiCenter = 36.1517, phi0Center = -1.37181, phiCenter = 36.1517
module_odd: crystal_id = 135, phiCenter = 36.4338, phi0Center = -1.37181, phiCenter = 36.4338
module_odd: crystal_id = 136, phiCenter = 36.716, phi0Center = -1.37181, phiCenter = 36.716
module_odd: crystal_id = 137, phiCenter = 36.9981, phi0Center = -1.37181, phiCenter = 36.9981
module_odd: crystal_id = 138, phiCenter = 37.2802, phi0Center = -1.37181, phiCenter = 37.2802
module_odd: crystal_id = 139, phiCenter = 37.5624, phi0Center = -1.37181, phiCenter = 37.5624
module_odd: crystal_id = 140, phiCenter = 37.8445, phi0Center = -1.37181, phiCenter = 37.8445
module_odd: crystal_id = 141, phiCenter = 38.1266, phi0Center = -1.37181, phiCenter = 38.1266
module_odd: crystal_id = 142, phiCenter = 38.4088, phi0Center = -1.37181, phiCenter = 38.4088
module_odd: crystal_id = 143, phiCenter = 38.6909, phi0Center = -1.37181, phiCenter = 38.6909
module_odd: crystal_id = 144, phiCenter = 38.973, phi0Center = -1.37181, phiCenter = 38.973
module_odd: crystal_id = 145, phiCenter = 39.2551, phi0Center = -1.37181, phiCenter = 39.2551
module_odd: crystal_id = 146, phiCenter = 39.5373, phi0Center = -1.37181, phiCenter = 39.5373
module_odd: crystal_id = 147, phiCenter = 39.8194, phi0Center = -1.37181, phiCenter = 39.8194
module_odd: crystal_id = 148, phiCenter = 40.1015, phi0Center = -1.37181, phiCenter = 40.1015
module_odd: crystal_id = 149, phiCenter = 40.3837, phi0Center = -1.37181, phiCenter = 40.3837
module_odd: crystal_id = 150, phiCenter = 40.6658, phi0Center = -1.37181, phiCenter = 40.6658
module_odd: crystal_id = 151, phiCenter = 40.9479, phi0Center = -1.37181, phiCenter = 40.9479
module_odd: crystal_id = 152, phiCenter = 41.2301, phi0Center = -1.37181, phiCenter = 41.2301
module_odd: crystal_id = 153, phiCenter = 41.5122, phi0Center = -1.37181, phiCenter = 41.5122
module_odd: crystal_id = 154, phiCenter = 41.7943, phi0Center = -1.37181, phiCenter = 41.7943
module_odd: crystal_id = 155, phiCenter = 42.0765, phi0Center = -1.37181, phiCenter = 42.0765
module_odd: crystal_id = 156, phiCenter = 42.3586, phi0Center = -1.37181, phiCenter = 42.3586
module_odd: crystal_id = 157, phiCenter = 42.6407, phi0Center = -1.37181, phiCenter = 42.6407
module_odd: crystal_id = 158, phiCenter = 42.9229, phi0Center = -1.37181, phiCenter = 42.9229
module_odd: crystal_id = 159, phiCenter = 43.205, phi0Center = -1.37181, phiCenter = 43.205
module_odd: crystal_id = 160, phiCenter = 43.4871, phi0Center = -1.37181, phiCenter = 43.4871
module_odd: crystal_id = 161, phiCenter = 43.7693, phi0Center = -1.37181, phiCenter = 43.7693
module_odd: crystal_id = 162, phiCenter = 44.0514, phi0Center = -1.37181, phiCenter = 44.0514
module_odd: crystal_id = 163, phiCenter = 44.3335, phi0Center = -1.37181, phiCenter = 44.3335
module_odd: crystal_id = 164, phiCenter = 44.6156, phi0Center = -1.37181, phiCenter = 44.6156
module_odd: crystal_id = 165, phiCenter = 44.8978, phi0Center = -1.37181, phiCenter = 44.8978
module_odd: crystal_id = 166, phiCenter = 45.1799, phi0Center = -1.37181, phiCenter = 45.1799
module_odd: crystal_id = 167, phiCenter = 45.462, phi0Center = -1.37181, phiCenter = 45.462
module_odd: crystal_id = 168, phiCenter = 45.7442, phi0Center = -1.37181, phiCenter = 45.7442
module_odd: crystal_id = 169, phiCenter = 46.0263, phi0Center = -1.37181, phiCenter = 46.0263
module_odd: crystal_id = 170, phiCenter = 46.3084, phi0Center = -1.37181, phiCenter = 46.3084
module_odd: crystal_id = 171, phiCenter = 46.5906, phi0Center = -1.37181, phiCenter = 46.5906
module_odd: crystal_id = 172, phiCenter = 46.8727, phi0Center = -1.37181, phiCenter = 46.8727
module_odd: crystal_id = 173, phiCenter = 47.1548, phi0Center = -1.37181, phiCenter = 47.1548
module_odd: crystal_id = 174, phiCenter = 47.437, phi0Center = -1.37181, phiCenter = 47.437
module_odd: crystal_id = 175, phiCenter = 47.7191, phi0Center = -1.37181, phiCenter = 47.7191
module_odd: crystal_id = 176, phiCenter = 48.0012, phi0Center = -1.37181, phiCenter = 48.0012
module_odd: crystal_id = 177, phiCenter = 48.2834, phi0Center = -1.37181, phiCenter = 48.2834
module_odd: crystal_id = 178, phiCenter = 48.5655, phi0Center = -1.37181, phiCenter = 48.5655
module_odd: crystal_id = 179, phiCenter = 48.8476, phi0Center = -1.37181, phiCenter = 48.8476
module_odd: crystal_id = 180, phiCenter = 49.1298, phi0Center = -1.37181, phiCenter = 49.1298
module_odd: crystal_id = 181, phiCenter = 49.4119, phi0Center = -1.37181, phiCenter = 49.4119
module_odd: crystal_id = 182, phiCenter = 49.694, phi0Center = -1.37181, phiCenter = 49.694
module_odd: crystal_id = 183, phiCenter = 49.9761, phi0Center = -1.37181, phiCenter = 49.9761
module_odd: crystal_id = 184, phiCenter = 50.2583, phi0Center = -1.37181, phiCenter = 50.2583
module_odd: crystal_id = 185, phiCenter = 50.5404, phi0Center = -1.37181, phiCenter = 50.5404
module_odd: crystal_id = 186, phiCenter = 50.8225, phi0Center = -1.37181, phiCenter = 50.8225
module_odd: crystal_id = 187, phiCenter = 51.1047, phi0Center = -1.37181, phiCenter = 51.1047
module_odd: crystal_id = 188, phiCenter = 51.3868, phi0Center = -1.37181, phiCenter = 51.3868
module_odd: crystal_id = 189, phiCenter = 51.6689, phi0Center = -1.37181, phiCenter = 51.6689
module_odd: crystal_id = 190, phiCenter = 51.9511, phi0Center = -1.37181, phiCenter = 51.9511
module_odd: crystal_id = 191, phiCenter = 52.2332, phi0Center = -1.37181, phiCenter = 52.2332
module_odd: crystal_id = 192, phiCenter = 52.5153, phi0Center = -1.37181, phiCenter = 52.5153
module_odd: crystal_id = 193, phiCenter = 52.7975, phi0Center = -1.37181, phiCenter = 52.7975
module_odd: crystal_id = 194, phiCenter = 53.0796, phi0Center = -1.37181, phiCenter = 53.0796
module_odd: crystal_id = 195, phiCenter = 53.3617, phi0Center = -1.37181, phiCenter = 53.3617
module_odd: crystal_id = 196, phiCenter = 53.6439, phi0Center = -1.37181, phiCenter = 53.6439
module_odd: crystal_id = 197, phiCenter = 53.926, phi0Center = -1.37181, phiCenter = 53.926
module_odd: crystal_id = 198, phiCenter = 54.2081, phi0Center = -1.37181, phiCenter = 54.2081
module_odd: crystal_id = 199, phiCenter = 54.4903, phi0Center = -1.37181, phiCenter = 54.4903
module_odd: crystal_id = 200, phiCenter = 54.7724, phi0Center = -1.37181, phiCenter = 54.7724
module_odd: crystal_id = 201, phiCenter = 55.0545, phi0Center = -1.37181, phiCenter = 55.0545
module_odd: crystal_id = 202, phiCenter = 55.3367, phi0Center = -1.37181, phiCenter = 55.3367
module_odd: crystal_id = 203, phiCenter = 55.6188, phi0Center = -1.37181, phiCenter = 55.6188
module_odd: crystal_id = 204, phiCenter = 55.9009, phi0Center = -1.37181, phiCenter = 55.9009
module_odd: crystal_id = 205, phiCenter = 56.183, phi0Center = -1.37181, phiCenter = 56.183
module_odd: crystal_id = 206, phiCenter = 56.4652, phi0Center = -1.37181, phiCenter = 56.4652
module_odd: crystal_id = 207, phiCenter = 56.7473, phi0Center = -1.37181, phiCenter = 56.7473
module_odd: crystal_id = 208, phiCenter = 57.0294, phi0Center = -1.37181, phiCenter = 57.0294
module_odd: crystal_id = 209, phiCenter = 57.3116, phi0Center = -1.37181, phiCenter = 57.3116
module_odd: crystal_id = 210, phiCenter = 57.5937, phi0Center = -1.37181, phiCenter = 57.5937
module_odd: crystal_id = 211, phiCenter = 57.8758, phi0Center = -1.37181, phiCenter = 57.8758
module_odd: crystal_id = 212, phiCenter = 58.158, phi0Center = -1.37181, phiCenter = 58.158
module_odd: crystal_id = 213, phiCenter = 58.4401, phi0Center = -1.37181, phiCenter = 58.4401
module_odd: crystal_id = 214, phiCenter = 58.7222, phi0Center = -1.37181, phiCenter = 58.7222
module_odd: crystal_id = 215, phiCenter = 59.0044, phi0Center = -1.37181, phiCenter = 59.0044
module_odd: crystal_id = 216, phiCenter = 59.2865, phi0Center = -1.37181, phiCenter = 59.2865
module_odd: crystal_id = 217, phiCenter = 59.5686, phi0Center = -1.37181, phiCenter = 59.5686
module_odd: crystal_id = 218, phiCenter = 59.8508, phi0Center = -1.37181, phiCenter = 59.8508
module_odd: crystal_id = 219, phiCenter = 60.1329, phi0Center = -1.37181, phiCenter = 60.1329
module_odd: crystal_id = 220, phiCenter = 60.415, phi0Center = -1.37181, phiCenter = 60.415
module_odd: crystal_id = 221, phiCenter = 60.6972, phi0Center = -1.37181, phiCenter = 60.6972
module_odd: crystal_id = 222, phiCenter = 60.9793, phi0Center = -1.37181, phiCenter = 60.9793
module_odd: crystal_id = 223, phiCenter = 61.2614, phi0Center = -1.37181, phiCenter = 61.2614
module_odd: crystal_id = 224, phiCenter = 61.5435, phi0Center = -1.37181, phiCenter = 61.5435
module_odd: crystal_id = 225, phiCenter = 61.8257, phi0Center = -1.37181, phiCenter = 61.8257
module_odd: crystal_id = 226, phiCenter = 62.1078, phi0Center = -1.37181, phiCenter = 62.1078
module_odd: crystal_id = 227, phiCenter = 62.3899, phi0Center = -1.37181, phiCenter = 62.3899
module_odd: crystal_id = 228, phiCenter = 62.6721, phi0Center = -1.37181, phiCenter = 62.6721
module_odd: crystal_id = 229, phiCenter = 62.9542, phi0Center = -1.37181, phiCenter = 62.9542
module_odd: crystal_id = 230, phiCenter = 63.2363, phi0Center = -1.37181, phiCenter = 63.2363
module_odd: crystal_id = 231, phiCenter = 63.5185, phi0Center = -1.37181, phiCenter = 63.5185
module_odd: crystal_id = 232, phiCenter = 63.8006, phi0Center = -1.37181, phiCenter = 63.8006
module_odd: crystal_id = 233, phiCenter = 64.0827, phi0Center = -1.37181, phiCenter = 64.0827
module_odd: crystal_id = 234, phiCenter = 64.3649, phi0Center = -1.37181, phiCenter = 64.3649
module_odd: crystal_id = 235, phiCenter = 64.647, phi0Center = -1.37181, phiCenter = 64.647
module_odd: crystal_id = 236, phiCenter = 64.9291, phi0Center = -1.37181, phiCenter = 64.9291
module_odd: crystal_id = 237, phiCenter = 65.2113, phi0Center = -1.37181, phiCenter = 65.2113
module_odd: crystal_id = 238, phiCenter = 65.4934, phi0Center = -1.37181, phiCenter = 65.4934
module_odd: crystal_id = 239, phiCenter = 65.7755, phi0Center = -1.37181, phiCenter = 65.7755
module_odd: crystal_id = 240, phiCenter = 66.0577, phi0Center = -1.37181, phiCenter = 66.0577
module_odd: crystal_id = 241, phiCenter = 66.3398, phi0Center = -1.37181, phiCenter = 66.3398
module_odd: crystal_id = 242, phiCenter = 66.6219, phi0Center = -1.37181, phiCenter = 66.6219
module_odd: crystal_id = 243, phiCenter = 66.904, phi0Center = -1.37181, phiCenter = 66.904
module_odd: crystal_id = 244, phiCenter = 67.1862, phi0Center = -1.37181, phiCenter = 67.1862
module_odd: crystal_id = 245, phiCenter = 67.4683, phi0Center = -1.37181, phiCenter = 67.4683
module_odd: crystal_id = 246, phiCenter = 67.7504, phi0Center = -1.37181, phiCenter = 67.7504
module_odd: crystal_id = 247, phiCenter = 68.0326, phi0Center = -1.37181, phiCenter = 68.0326
module_odd: crystal_id = 248, phiCenter = 68.3147, phi0Center = -1.37181, phiCenter = 68.3147
module_odd: crystal_id = 249, phiCenter = 68.5968, phi0Center = -1.37181, phiCenter = 68.5968
module_odd: crystal_id = 250, phiCenter = 68.879, phi0Center = -1.37181, phiCenter = 68.879
module_odd: crystal_id = 251, phiCenter = 69.1611, phi0Center = -1.37181, phiCenter = 69.1611
module_odd: crystal_id = 252, phiCenter = 69.4432, phi0Center = -1.37181, phiCenter = 69.4432
module_odd: crystal_id = 253, phiCenter = 69.7254, phi0Center = -1.37181, phiCenter = 69.7254
module_odd: crystal_id = 254, phiCenter = 70.0075, phi0Center = -1.37181, phiCenter = 70.0075
module_odd: crystal_id = 255, phiCenter = 70.2896, phi0Center = -1.37181, phiCenter = 70.2896
module_odd: crystal_id = 256, phiCenter = 70.5718, phi0Center = -1.37181, phiCenter = 70.5718
module_odd: crystal_id = 257, phiCenter = 70.8539, phi0Center = -1.37181, phiCenter = 70.8539
module_odd: crystal_id = 258, phiCenter = 71.136, phi0Center = -1.37181, phiCenter = 71.136
module_odd: crystal_id = 259, phiCenter = 71.4182, phi0Center = -1.37181, phiCenter = 71.4182
module_odd: crystal_id = 260, phiCenter = 71.7003, phi0Center = -1.37181, phiCenter = 71.7003
module_odd: crystal_id = 261, phiCenter = 71.9824, phi0Center = -1.37181, phiCenter = 71.9824
module_odd: crystal_id = 262, phiCenter = 72.2646, phi0Center = -1.37181, phiCenter = 72.2646
module_odd: crystal_id = 263, phiCenter = 72.5467, phi0Center = -1.37181, phiCenter = 72.5467
module_odd: crystal_id = 264, phiCenter = 72.8288, phi0Center = -1.37181, phiCenter = 72.8288
module_odd: crystal_id = 265, phiCenter = 73.1109, phi0Center = -1.37181, phiCenter = 73.1109
module_odd: crystal_id = 266, phiCenter = 73.3931, phi0Center = -1.37181, phiCenter = 73.3931
module_odd: crystal_id = 267, phiCenter = 73.6752, phi0Center = -1.37181, phiCenter = 73.6752
module_odd: crystal_id = 268, phiCenter = 73.9573, phi0Center = -1.37181, phiCenter = 73.9573
module_odd: crystal_id = 269, phiCenter = 74.2395, phi0Center = -1.37181, phiCenter = 74.2395
module_odd: crystal_id = 270, phiCenter = 74.5216, phi0Center = -1.37181, phiCenter = 74.5216
module_odd: crystal_id = 271, phiCenter = 74.8037, phi0Center = -1.37181, phiCenter = 74.8037
module_odd: crystal_id = 272, phiCenter = 75.0859, phi0Center = -1.37181, phiCenter = 75.0859
module_odd: crystal_id = 273, phiCenter = 75.368, phi0Center = -1.37181, phiCenter = 75.368
module_odd: crystal_id = 274, phiCenter = 75.6501, phi0Center = -1.37181, phiCenter = 75.6501
module_odd: crystal_id = 275, phiCenter = 75.9323, phi0Center = -1.37181, phiCenter = 75.9323
module_odd: crystal_id = 276, phiCenter = 76.2144, phi0Center = -1.37181, phiCenter = 76.2144
module_odd: crystal_id = 277, phiCenter = 76.4965, phi0Center = -1.37181, phiCenter = 76.4965
module_odd: crystal_id = 278, phiCenter = 76.7787, phi0Center = -1.37181, phiCenter = 76.7787
module_odd: crystal_id = 279, phiCenter = 77.0608, phi0Center = -1.37181, phiCenter = 77.0608
module_odd: crystal_id = 280, phiCenter = 77.3429, phi0Center = -1.37181, phiCenter = 77.3429
module_odd: crystal_id = 281, phiCenter = 77.6251, phi0Center = -1.37181, phiCenter = 77.6251
module_odd: crystal_id = 282, phiCenter = 77.9072, phi0Center = -1.37181, phiCenter = 77.9072
module_odd: crystal_id = 283, phiCenter = 78.1893, phi0Center = -1.37181, phiCenter = 78.1893
module_odd: crystal_id = 284, phiCenter = 78.4714, phi0Center = -1.37181, phiCenter = 78.4714
module_odd: crystal_id = 285, phiCenter = 78.7536, phi0Center = -1.37181, phiCenter = 78.7536
module_odd: crystal_id = 286, phiCenter = 79.0357, phi0Center = -1.37181, phiCenter = 79.0357
module_odd: crystal_id = 287, phiCenter = 79.3178, phi0Center = -1.37181, phiCenter = 79.3178
module_odd: crystal_id = 288, phiCenter = 79.6, phi0Center = -1.37181, phiCenter = 79.6
module_odd: crystal_id = 289, phiCenter = 79.8821, phi0Center = -1.37181, phiCenter = 79.8821
module_odd: crystal_id = 290, phiCenter = 80.1642, phi0Center = -1.37181, phiCenter = 80.1642
module_odd: crystal_id = 291, phiCenter = 80.4464, phi0Center = -1.37181, phiCenter = 80.4464
module_odd: crystal_id = 292, phiCenter = 80.7285, phi0Center = -1.37181, phiCenter = 80.7285
module_odd: crystal_id = 293, phiCenter = 81.0106, phi0Center = -1.37181, phiCenter = 81.0106
module_odd: crystal_id = 294, phiCenter = 81.2928, phi0Center = -1.37181, phiCenter = 81.2928
module_odd: crystal_id = 295, phiCenter = 81.5749, phi0Center = -1.37181, phiCenter = 81.5749
module_odd: crystal_id = 296, phiCenter = 81.857, phi0Center = -1.37181, phiCenter = 81.857
module_odd: crystal_id = 297, phiCenter = 82.1392, phi0Center = -1.37181, phiCenter = 82.1392
module_odd: crystal_id = 298, phiCenter = 82.4213, phi0Center = -1.37181, phiCenter = 82.4213
module_odd: crystal_id = 299, phiCenter = 82.7034, phi0Center = -1.37181, phiCenter = 82.7034
module_odd: crystal_id = 300, phiCenter = 82.9856, phi0Center = -1.37181, phiCenter = 82.9856
module_odd: crystal_id = 301, phiCenter = 83.2677, phi0Center = -1.37181, phiCenter = 83.2677
module_odd: crystal_id = 302, phiCenter = 83.5498, phi0Center = -1.37181, phiCenter = 83.5498
module_odd: crystal_id = 303, phiCenter = 83.8319, phi0Center = -1.37181, phiCenter = 83.8319
module_odd: crystal_id = 304, phiCenter = 84.1141, phi0Center = -1.37181, phiCenter = 84.1141
module_odd: crystal_id = 305, phiCenter = 84.3962, phi0Center = -1.37181, phiCenter = 84.3962
module_odd: crystal_id = 306, phiCenter = 84.6783, phi0Center = -1.37181, phiCenter = 84.6783
module_odd: crystal_id = 307, phiCenter = 84.9605, phi0Center = -1.37181, phiCenter = 84.9605
module_odd: crystal_id = 308, phiCenter = 85.2426, phi0Center = -1.37181, phiCenter = 85.2426
module_odd: crystal_id = 309, phiCenter = 85.5247, phi0Center = -1.37181, phiCenter = 85.5247
module_odd: crystal_id = 310, phiCenter = 85.8069, phi0Center = -1.37181, phiCenter = 85.8069
module_odd: crystal_id = 311, phiCenter = 86.089, phi0Center = -1.37181, phiCenter = 86.089
module_odd: crystal_id = 312, phiCenter = 86.3711, phi0Center = -1.37181, phiCenter = 86.3711
module_odd: crystal_id = 313, phiCenter = 86.6533, phi0Center = -1.37181, phiCenter = 86.6533
module_odd: crystal_id = 314, phiCenter = 86.9354, phi0Center = -1.37181, phiCenter = 86.9354
module_odd: crystal_id = 315, phiCenter = 87.2175, phi0Center = -1.37181, phiCenter = 87.2175
module_odd: crystal_id = 316, phiCenter = 87.4997, phi0Center = -1.37181, phiCenter = 87.4997
module_odd: crystal_id = 317, phiCenter = 87.7818, phi0Center = -1.37181, phiCenter = 87.7818
module_odd: crystal_id = 318, phiCenter = 88.0639, phi0Center = -1.37181, phiCenter = 88.0639
module_odd: crystal_id = 319, phiCenter = 88.3461, phi0Center = -1.37181, phiCenter = 88.3461
module_odd: crystal_id = 320, phiCenter = 88.6282, phi0Center = -1.37181, phiCenter = 88.6282
module_odd: crystal_id = 321, phiCenter = 88.9103, phi0Center = -1.37181, phiCenter = 88.9103
module_odd: crystal_id = 322, phiCenter = 89.1924, phi0Center = -1.37181, phiCenter = 89.1924
module_odd: crystal_id = 323, phiCenter = 89.4746, phi0Center = -1.37181, phiCenter = 89.4746
module_odd: crystal_id = 324, phiCenter = 89.7567, phi0Center = -1.37181, phiCenter = 89.7567
module_odd: crystal_id = 325, phiCenter = 90.0388, phi0Center = -1.37181, phiCenter = 90.0388
module_odd: crystal_id = 326, phiCenter = 90.321, phi0Center = -1.37181, phiCenter = 90.321
module_odd: crystal_id = 327, phiCenter = 90.6031, phi0Center = -1.37181, phiCenter = 90.6031
module_odd: crystal_id = 328, phiCenter = 90.8852, phi0Center = -1.37181, phiCenter = 90.8852
module_odd: crystal_id = 329, phiCenter = 91.1674, phi0Center = -1.37181, phiCenter = 91.1674
module_odd: crystal_id = 330, phiCenter = 91.4495, phi0Center = -1.37181, phiCenter = 91.4495
module_odd: crystal_id = 331, phiCenter = 91.7316, phi0Center = -1.37181, phiCenter = 91.7316
module_odd: crystal_id = 332, phiCenter = 92.0138, phi0Center = -1.37181, phiCenter = 92.0138
module_odd: crystal_id = 333, phiCenter = 92.2959, phi0Center = -1.37181, phiCenter = 92.2959
module_odd: crystal_id = 334, phiCenter = 92.578, phi0Center = -1.37181, phiCenter = 92.578
module_odd: crystal_id = 335, phiCenter = 92.8602, phi0Center = -1.37181, phiCenter = 92.8602
module_odd: crystal_id = 336, phiCenter = 93.1423, phi0Center = -1.37181, phiCenter = 93.1423
module_odd: crystal_id = 337, phiCenter = 93.4244, phi0Center = -1.37181, phiCenter = 93.4244
module_odd: crystal_id = 338, phiCenter = 93.7066, phi0Center = -1.37181, phiCenter = 93.7066
module_odd: crystal_id = 339, phiCenter = 93.9887, phi0Center = -1.37181, phiCenter = 93.9887
module_odd: crystal_id = 340, phiCenter = 94.2708, phi0Center = -1.37181, phiCenter = 94.2708
module_odd: crystal_id = 341, phiCenter = 94.553, phi0Center = -1.37181, phiCenter = 94.553
module_odd: crystal_id = 342, phiCenter = 94.8351, phi0Center = -1.37181, phiCenter = 94.8351
module_odd: crystal_id = 343, phiCenter = 95.1172, phi0Center = -1.37181, phiCenter = 95.1172
module_odd: crystal_id = 344, phiCenter = 95.3993, phi0Center = -1.37181, phiCenter = 95.3993
module_odd: crystal_id = 345, phiCenter = 95.6815, phi0Center = -1.37181, phiCenter = 95.6815
module_odd: crystal_id = 346, phiCenter = 95.9636, phi0Center = -1.37181, phiCenter = 95.9636
module_odd: crystal_id = 347, phiCenter = 96.2457, phi0Center = -1.37181, phiCenter = 96.2457
module_odd: crystal_id = 348, phiCenter = 96.5279, phi0Center = -1.37181, phiCenter = 96.5279
module_odd: crystal_id = 349, phiCenter = 96.81, phi0Center = -1.37181, phiCenter = 96.81
module_odd: crystal_id = 350, phiCenter = 97.0921, phi0Center = -1.37181, phiCenter = 97.0921
module_odd: crystal_id = 351, phiCenter = 97.3743, phi0Center = -1.37181, phiCenter = 97.3743
module_odd: crystal_id = 352, phiCenter = 97.6564, phi0Center = -1.37181, phiCenter = 97.6564
module_odd: crystal_id = 353, phiCenter = 97.9385, phi0Center = -1.37181, phiCenter = 97.9385
module_odd: crystal_id = 354, phiCenter = 98.2207, phi0Center = -1.37181, phiCenter = 98.2207
module_odd: crystal_id = 355, phiCenter = 98.5028, phi0Center = -1.37181, phiCenter = 98.5028
module_odd: crystal_id = 356, phiCenter = 98.7849, phi0Center = -1.37181, phiCenter = 98.7849
module_odd: crystal_id = 357, phiCenter = 99.0671, phi0Center = -1.37181, phiCenter = 99.0671
module_odd: crystal_id = 358, phiCenter = 99.3492, phi0Center = -1.37181, phiCenter = 99.3492
module_odd: crystal_id = 359, phiCenter = 99.6313, phi0Center = -1.37181, phiCenter = 99.6313
module_odd: crystal_id = 360, phiCenter = 99.9135, phi0Center = -1.37181, phiCenter = 99.9135
module_odd: crystal_id = 361, phiCenter = 100.196, phi0Center = -1.37181, phiCenter = 100.196
module_odd: crystal_id = 362, phiCenter = 100.478, phi0Center = -1.37181, phiCenter = 100.478
module_odd: crystal_id = 363, phiCenter = 100.76, phi0Center = -1.37181, phiCenter = 100.76
module_odd: crystal_id = 364, phiCenter = 101.042, phi0Center = -1.37181, phiCenter = 101.042
module_odd: crystal_id = 365, phiCenter = 101.324, phi0Center = -1.37181, phiCenter = 101.324
module_odd: crystal_id = 366, phiCenter = 101.606, phi0Center = -1.37181, phiCenter = 101.606
module_odd: crystal_id = 367, phiCenter = 101.888, phi0Center = -1.37181, phiCenter = 101.888
module_odd: crystal_id = 368, phiCenter = 102.171, phi0Center = -1.37181, phiCenter = 102.171
module_odd: crystal_id = 369, phiCenter = 102.453, phi0Center = -1.37181, phiCenter = 102.453
module_odd: crystal_id = 370, phiCenter = 102.735, phi0Center = -1.37181, phiCenter = 102.735
module_odd: crystal_id = 371, phiCenter = 103.017, phi0Center = -1.37181, phiCenter = 103.017
module_odd: crystal_id = 372, phiCenter = 103.299, phi0Center = -1.37181, phiCenter = 103.299
module_odd: crystal_id = 373, phiCenter = 103.581, phi0Center = -1.37181, phiCenter = 103.581
module_odd: crystal_id = 374, phiCenter = 103.863, phi0Center = -1.37181, phiCenter = 103.863
module_odd: crystal_id = 375, phiCenter = 104.145, phi0Center = -1.37181, phiCenter = 104.145
module_odd: crystal_id = 376, phiCenter = 104.428, phi0Center = -1.37181, phiCenter = 104.428
module_odd: crystal_id = 377, phiCenter = 104.71, phi0Center = -1.37181, phiCenter = 104.71
module_odd: crystal_id = 378, phiCenter = 104.992, phi0Center = -1.37181, phiCenter = 104.992
module_odd: crystal_id = 379, phiCenter = 105.274, phi0Center = -1.37181, phiCenter = 105.274
module_odd: crystal_id = 380, phiCenter = 105.556, phi0Center = -1.37181, phiCenter = 105.556
module_odd: crystal_id = 381, phiCenter = 105.838, phi0Center = -1.37181, phiCenter = 105.838
module_odd: crystal_id = 382, phiCenter = 106.12, phi0Center = -1.37181, phiCenter = 106.12
module_odd: crystal_id = 383, phiCenter = 106.402, phi0Center = -1.37181, phiCenter = 106.402
module_odd: crystal_id = 384, phiCenter = 106.685, phi0Center = -1.37181, phiCenter = 106.685
module_odd: crystal_id = 385, phiCenter = 106.967, phi0Center = -1.37181, phiCenter = 106.967
module_odd: crystal_id = 386, phiCenter = 107.249, phi0Center = -1.37181, phiCenter = 107.249
module_odd: crystal_id = 387, phiCenter = 107.531, phi0Center = -1.37181, phiCenter = 107.531
module_odd: crystal_id = 388, phiCenter = 107.813, phi0Center = -1.37181, phiCenter = 107.813
module_odd: crystal_id = 389, phiCenter = 108.095, phi0Center = -1.37181, phiCenter = 108.095
module_odd: crystal_id = 390, phiCenter = 108.377, phi0Center = -1.37181, phiCenter = 108.377
module_odd: crystal_id = 391, phiCenter = 108.66, phi0Center = -1.37181, phiCenter = 108.66
module_odd: crystal_id = 392, phiCenter = 108.942, phi0Center = -1.37181, phiCenter = 108.942
module_odd: crystal_id = 393, phiCenter = 109.224, phi0Center = -1.37181, phiCenter = 109.224
module_odd: crystal_id = 394, phiCenter = 109.506, phi0Center = -1.37181, phiCenter = 109.506
module_odd: crystal_id = 395, phiCenter = 109.788, phi0Center = -1.37181, phiCenter = 109.788
module_odd: crystal_id = 396, phiCenter = 110.07, phi0Center = -1.37181, phiCenter = 110.07
module_odd: crystal_id = 397, phiCenter = 110.352, phi0Center = -1.37181, phiCenter = 110.352
module_odd: crystal_id = 398, phiCenter = 110.634, phi0Center = -1.37181, phiCenter = 110.634
module_odd: crystal_id = 399, phiCenter = 110.917, phi0Center = -1.37181, phiCenter = 110.917
module_odd: crystal_id = 400, phiCenter = 111.199, phi0Center = -1.37181, phiCenter = 111.199
module_odd: crystal_id = 401, phiCenter = 111.481, phi0Center = -1.37181, phiCenter = 111.481
module_odd: crystal_id = 402, phiCenter = 111.763, phi0Center = -1.37181, phiCenter = 111.763
module_odd: crystal_id = 403, phiCenter = 112.045, phi0Center = -1.37181, phiCenter = 112.045
module_odd: crystal_id = 404, phiCenter = 112.327, phi0Center = -1.37181, phiCenter = 112.327
module_odd: crystal_id = 405, phiCenter = 112.609, phi0Center = -1.37181, phiCenter = 112.609
module_odd: crystal_id = 406, phiCenter = 112.892, phi0Center = -1.37181, phiCenter = 112.892
module_odd: crystal_id = 407, phiCenter = 113.174, phi0Center = -1.37181, phiCenter = 113.174
module_odd: crystal_id = 408, phiCenter = 113.456, phi0Center = -1.37181, phiCenter = 113.456
module_odd: crystal_id = 409, phiCenter = 113.738, phi0Center = -1.37181, phiCenter = 113.738
module_odd: crystal_id = 410, phiCenter = 114.02, phi0Center = -1.37181, phiCenter = 114.02
module_odd: crystal_id = 411, phiCenter = 114.302, phi0Center = -1.37181, phiCenter = 114.302
module_odd: crystal_id = 412, phiCenter = 114.584, phi0Center = -1.37181, phiCenter = 114.584
module_odd: crystal_id = 413, phiCenter = 114.866, phi0Center = -1.37181, phiCenter = 114.866
module_odd: crystal_id = 414, phiCenter = 115.149, phi0Center = -1.37181, phiCenter = 115.149
module_odd: crystal_id = 415, phiCenter = 115.431, phi0Center = -1.37181, phiCenter = 115.431
module_odd: crystal_id = 416, phiCenter = 115.713, phi0Center = -1.37181, phiCenter = 115.713
module_odd: crystal_id = 417, phiCenter = 115.995, phi0Center = -1.37181, phiCenter = 115.995
module_odd: crystal_id = 418, phiCenter = 116.277, phi0Center = -1.37181, phiCenter = 116.277
module_odd: crystal_id = 419, phiCenter = 116.559, phi0Center = -1.37181, phiCenter = 116.559
module_odd: crystal_id = 420, phiCenter = 116.841, phi0Center = -1.37181, phiCenter = 116.841
module_odd: crystal_id = 421, phiCenter = 117.123, phi0Center = -1.37181, phiCenter = 117.123
module_odd: crystal_id = 422, phiCenter = 117.406, phi0Center = -1.37181, phiCenter = 117.406
module_odd: crystal_id = 423, phiCenter = 117.688, phi0Center = -1.37181, phiCenter = 117.688
module_odd: crystal_id = 424, phiCenter = 117.97, phi0Center = -1.37181, phiCenter = 117.97
module_odd: crystal_id = 425, phiCenter = 118.252, phi0Center = -1.37181, phiCenter = 118.252
module_odd: crystal_id = 426, phiCenter = 118.534, phi0Center = -1.37181, phiCenter = 118.534
module_odd: crystal_id = 427, phiCenter = 118.816, phi0Center = -1.37181, phiCenter = 118.816
module_odd: crystal_id = 428, phiCenter = 119.098, phi0Center = -1.37181, phiCenter = 119.098
module_odd: crystal_id = 429, phiCenter = 119.381, phi0Center = -1.37181, phiCenter = 119.381
module_odd: crystal_id = 430, phiCenter = 119.663, phi0Center = -1.37181, phiCenter = 119.663
module_odd: crystal_id = 431, phiCenter = 119.945, phi0Center = -1.37181, phiCenter = 119.945
module_odd: crystal_id = 432, phiCenter = 120.227, phi0Center = -1.37181, phiCenter = 120.227
module_odd: crystal_id = 433, phiCenter = 120.509, phi0Center = -1.37181, phiCenter = 120.509
module_odd: crystal_id = 434, phiCenter = 120.791, phi0Center = -1.37181, phiCenter = 120.791
module_odd: crystal_id = 435, phiCenter = 121.073, phi0Center = -1.37181, phiCenter = 121.073
module_odd: crystal_id = 436, phiCenter = 121.355, phi0Center = -1.37181, phiCenter = 121.355
module_odd: crystal_id = 437, phiCenter = 121.638, phi0Center = -1.37181, phiCenter = 121.638
module_odd: crystal_id = 438, phiCenter = 121.92, phi0Center = -1.37181, phiCenter = 121.92
module_odd: crystal_id = 439, phiCenter = 122.202, phi0Center = -1.37181, phiCenter = 122.202
module_odd: crystal_id = 440, phiCenter = 122.484, phi0Center = -1.37181, phiCenter = 122.484
module_odd: crystal_id = 441, phiCenter = 122.766, phi0Center = -1.37181, phiCenter = 122.766
module_odd: crystal_id = 442, phiCenter = 123.048, phi0Center = -1.37181, phiCenter = 123.048
module_odd: crystal_id = 443, phiCenter = 123.33, phi0Center = -1.37181, phiCenter = 123.33
module_odd: crystal_id = 444, phiCenter = 123.613, phi0Center = -1.37181, phiCenter = 123.613
module_odd: crystal_id = 445, phiCenter = 123.895, phi0Center = -1.37181, phiCenter = 123.895
module_odd: crystal_id = 446, phiCenter = 124.177, phi0Center = -1.37181, phiCenter = 124.177
module_odd: crystal_id = 447, phiCenter = 124.459, phi0Center = -1.37181, phiCenter = 124.459
module_odd: crystal_id = 448, phiCenter = 124.741, phi0Center = -1.37181, phiCenter = 124.741
module_odd: crystal_id = 449, phiCenter = 125.023, phi0Center = -1.37181, phiCenter = 125.023
module_odd: crystal_id = 450, phiCenter = 125.305, phi0Center = -1.37181, phiCenter = 125.305
module_odd: crystal_id = 451, phiCenter = 125.587, phi0Center = -1.37181, phiCenter = 125.587
module_odd: crystal_id = 452, phiCenter = 125.87, phi0Center = -1.37181, phiCenter = 125.87
module_odd: crystal_id = 453, phiCenter = 126.152, phi0Center = -1.37181, phiCenter = 126.152
module_odd: crystal_id = 454, phiCenter = 126.434, phi0Center = -1.37181, phiCenter = 126.434
module_odd: crystal_id = 455, phiCenter = 126.716, phi0Center = -1.37181, phiCenter = 126.716
module_odd: crystal_id = 456, phiCenter = 126.998, phi0Center = -1.37181, phiCenter = 126.998
module_odd: crystal_id = 457, phiCenter = 127.28, phi0Center = -1.37181, phiCenter = 127.28
module_odd: crystal_id = 458, phiCenter = 127.562, phi0Center = -1.37181, phiCenter = 127.562
module_odd: crystal_id = 459, phiCenter = 127.844, phi0Center = -1.37181, phiCenter = 127.844
module_odd: crystal_id = 460, phiCenter = 128.127, phi0Center = -1.37181, phiCenter = 128.127
module_odd: crystal_id = 461, phiCenter = 128.409, phi0Center = -1.37181, phiCenter = 128.409
module_odd: crystal_id = 462, phiCenter = 128.691, phi0Center = -1.37181, phiCenter = 128.691
module_odd: crystal_id = 463, phiCenter = 128.973, phi0Center = -1.37181, phiCenter = 128.973
module_odd: crystal_id = 464, phiCenter = 129.255, phi0Center = -1.37181, phiCenter = 129.255
module_odd: crystal_id = 465, phiCenter = 129.537, phi0Center = -1.37181, phiCenter = 129.537
module_odd: crystal_id = 466, phiCenter = 129.819, phi0Center = -1.37181, phiCenter = 129.819
module_odd: crystal_id = 467, phiCenter = 130.102, phi0Center = -1.37181, phiCenter = 130.102
module_odd: crystal_id = 468, phiCenter = 130.384, phi0Center = -1.37181, phiCenter = 130.384
module_odd: crystal_id = 469, phiCenter = 130.666, phi0Center = -1.37181, phiCenter = 130.666
module_odd: crystal_id = 470, phiCenter = 130.948, phi0Center = -1.37181, phiCenter = 130.948
module_odd: crystal_id = 471, phiCenter = 131.23, phi0Center = -1.37181, phiCenter = 131.23
module_odd: crystal_id = 472, phiCenter = 131.512, phi0Center = -1.37181, phiCenter = 131.512
module_odd: crystal_id = 473, phiCenter = 131.794, phi0Center = -1.37181, phiCenter = 131.794
module_odd: crystal_id = 474, phiCenter = 132.076, phi0Center = -1.37181, phiCenter = 132.076
module_odd: crystal_id = 475, phiCenter = 132.359, phi0Center = -1.37181, phiCenter = 132.359
module_odd: crystal_id = 476, phiCenter = 132.641, phi0Center = -1.37181, phiCenter = 132.641
module_odd: crystal_id = 477, phiCenter = 132.923, phi0Center = -1.37181, phiCenter = 132.923
module_odd: crystal_id = 478, phiCenter = 133.205, phi0Center = -1.37181, phiCenter = 133.205
module_odd: crystal_id = 479, phiCenter = 133.487, phi0Center = -1.37181, phiCenter = 133.487
module_odd: crystal_id = 480, phiCenter = 133.769, phi0Center = -1.37181, phiCenter = 133.769
module_odd: crystal_id = 481, phiCenter = 134.051, phi0Center = -1.37181, phiCenter = 134.051
module_odd: crystal_id = 482, phiCenter = 134.334, phi0Center = -1.37181, phiCenter = 134.334
module_odd: crystal_id = 483, phiCenter = 134.616, phi0Center = -1.37181, phiCenter = 134.616
module_odd: crystal_id = 484, phiCenter = 134.898, phi0Center = -1.37181, phiCenter = 134.898
module_odd: crystal_id = 485, phiCenter = 135.18, phi0Center = -1.37181, phiCenter = 135.18
module_odd: crystal_id = 486, phiCenter = 135.462, phi0Center = -1.37181, phiCenter = 135.462
module_odd: crystal_id = 487, phiCenter = 135.744, phi0Center = -1.37181, phiCenter = 135.744
module_odd: crystal_id = 488, phiCenter = 136.026, phi0Center = -1.37181, phiCenter = 136.026
module_odd: crystal_id = 489, phiCenter = 136.308, phi0Center = -1.37181, phiCenter = 136.308
module_odd: crystal_id = 490, phiCenter = 136.591, phi0Center = -1.37181, phiCenter = 136.591
module_odd: crystal_id = 491, phiCenter = 136.873, phi0Center = -1.37181, phiCenter = 136.873
module_odd: crystal_id = 492, phiCenter = 137.155, phi0Center = -1.37181, phiCenter = 137.155
module_odd: crystal_id = 493, phiCenter = 137.437, phi0Center = -1.37181, phiCenter = 137.437
module_odd: crystal_id = 494, phiCenter = 137.719, phi0Center = -1.37181, phiCenter = 137.719
module_odd: crystal_id = 495, phiCenter = 138.001, phi0Center = -1.37181, phiCenter = 138.001
module_odd: crystal_id = 496, phiCenter = 138.283, phi0Center = -1.37181, phiCenter = 138.283
module_odd: crystal_id = 497, phiCenter = 138.565, phi0Center = -1.37181, phiCenter = 138.565
module_odd: crystal_id = 498, phiCenter = 138.848, phi0Center = -1.37181, phiCenter = 138.848
module_odd: crystal_id = 499, phiCenter = 139.13, phi0Center = -1.37181, phiCenter = 139.13
module_odd: crystal_id = 500, phiCenter = 139.412, phi0Center = -1.37181, phiCenter = 139.412
module_odd: crystal_id = 501, phiCenter = 139.694, phi0Center = -1.37181, phiCenter = 139.694
module_odd: crystal_id = 502, phiCenter = 139.976, phi0Center = -1.37181, phiCenter = 139.976
module_odd: crystal_id = 503, phiCenter = 140.258, phi0Center = -1.37181, phiCenter = 140.258
module_odd: crystal_id = 504, phiCenter = 140.54, phi0Center = -1.37181, phiCenter = 140.54
module_odd: crystal_id = 505, phiCenter = 140.823, phi0Center = -1.37181, phiCenter = 140.823
module_odd: crystal_id = 506, phiCenter = 141.105, phi0Center = -1.37181, phiCenter = 141.105
module_odd: crystal_id = 507, phiCenter = 141.387, phi0Center = -1.37181, phiCenter = 141.387
module_odd: crystal_id = 508, phiCenter = 141.669, phi0Center = -1.37181, phiCenter = 141.669
module_odd: crystal_id = 509, phiCenter = 141.951, phi0Center = -1.37181, phiCenter = 141.951
module_odd: crystal_id = 510, phiCenter = 142.233, phi0Center = -1.37181, phiCenter = 142.233
module_odd: crystal_id = 511, phiCenter = 142.515, phi0Center = -1.37181, phiCenter = 142.515
module_odd: crystal_id = 512, phiCenter = 142.797, phi0Center = -1.37181, phiCenter = 142.797
module_odd: crystal_id = 513, phiCenter = 143.08, phi0Center = -1.37181, phiCenter = 143.08
module_odd: crystal_id = 514, phiCenter = 143.362, phi0Center = -1.37181, phiCenter = 143.362
module_odd: crystal_id = 515, phiCenter = 143.644, phi0Center = -1.37181, phiCenter = 143.644
module_odd: crystal_id = 516, phiCenter = 143.926, phi0Center = -1.37181, phiCenter = 143.926
module_odd: crystal_id = 517, phiCenter = 144.208, phi0Center = -1.37181, phiCenter = 144.208
module_odd: crystal_id = 518, phiCenter = 144.49, phi0Center = -1.37181, phiCenter = 144.49
module_odd: crystal_id = 519, phiCenter = 144.772, phi0Center = -1.37181, phiCenter = 144.772
module_odd: crystal_id = 520, phiCenter = 145.055, phi0Center = -1.37181, phiCenter = 145.055
module_odd: crystal_id = 521, phiCenter = 145.337, phi0Center = -1.37181, phiCenter = 145.337
module_odd: crystal_id = 522, phiCenter = 145.619, phi0Center = -1.37181, phiCenter = 145.619
module_odd: crystal_id = 523, phiCenter = 145.901, phi0Center = -1.37181, phiCenter = 145.901
module_odd: crystal_id = 524, phiCenter = 146.183, phi0Center = -1.37181, phiCenter = 146.183
module_odd: crystal_id = 525, phiCenter = 146.465, phi0Center = -1.37181, phiCenter = 146.465
module_odd: crystal_id = 526, phiCenter = 146.747, phi0Center = -1.37181, phiCenter = 146.747
module_odd: crystal_id = 527, phiCenter = 147.029, phi0Center = -1.37181, phiCenter = 147.029
module_odd: crystal_id = 528, phiCenter = 147.312, phi0Center = -1.37181, phiCenter = 147.312
module_odd: crystal_id = 529, phiCenter = 147.594, phi0Center = -1.37181, phiCenter = 147.594
module_odd: crystal_id = 530, phiCenter = 147.876, phi0Center = -1.37181, phiCenter = 147.876
module_odd: crystal_id = 531, phiCenter = 148.158, phi0Center = -1.37181, phiCenter = 148.158
module_odd: crystal_id = 532, phiCenter = 148.44, phi0Center = -1.37181, phiCenter = 148.44
module_odd: crystal_id = 533, phiCenter = 148.722, phi0Center = -1.37181, phiCenter = 148.722
module_odd: crystal_id = 534, phiCenter = 149.004, phi0Center = -1.37181, phiCenter = 149.004
module_odd: crystal_id = 535, phiCenter = 149.286, phi0Center = -1.37181, phiCenter = 149.286
module_odd: crystal_id = 536, phiCenter = 149.569, phi0Center = -1.37181, phiCenter = 149.569
module_odd: crystal_id = 537, phiCenter = 149.851, phi0Center = -1.37181, phiCenter = 149.851
module_odd: crystal_id = 538, phiCenter = 150.133, phi0Center = -1.37181, phiCenter = 150.133
module_odd: crystal_id = 539, phiCenter = 150.415, phi0Center = -1.37181, phiCenter = 150.415
module_odd: crystal_id = 540, phiCenter = 150.697, phi0Center = -1.37181, phiCenter = 150.697
module_odd: crystal_id = 541, phiCenter = 150.979, phi0Center = -1.37181, phiCenter = 150.979
module_odd: crystal_id = 542, phiCenter = 151.261, phi0Center = -1.37181, phiCenter = 151.261
module_odd: crystal_id = 543, phiCenter = 151.544, phi0Center = -1.37181, phiCenter = 151.544
module_odd: crystal_id = 544, phiCenter = 151.826, phi0Center = -1.37181, phiCenter = 151.826
module_odd: crystal_id = 545, phiCenter = 152.108, phi0Center = -1.37181, phiCenter = 152.108
module_odd: crystal_id = 546, phiCenter = 152.39, phi0Center = -1.37181, phiCenter = 152.39
module_odd: crystal_id = 547, phiCenter = 152.672, phi0Center = -1.37181, phiCenter = 152.672
module_odd: crystal_id = 548, phiCenter = 152.954, phi0Center = -1.37181, phiCenter = 152.954
module_odd: crystal_id = 549, phiCenter = 153.236, phi0Center = -1.37181, phiCenter = 153.236
module_odd: crystal_id = 550, phiCenter = 153.518, phi0Center = -1.37181, phiCenter = 153.518
module_odd: crystal_id = 551, phiCenter = 153.801, phi0Center = -1.37181, phiCenter = 153.801
module_odd: crystal_id = 552, phiCenter = 154.083, phi0Center = -1.37181, phiCenter = 154.083
module_odd: crystal_id = 553, phiCenter = 154.365, phi0Center = -1.37181, phiCenter = 154.365
module_odd: crystal_id = 554, phiCenter = 154.647, phi0Center = -1.37181, phiCenter = 154.647
module_odd: crystal_id = 555, phiCenter = 154.929, phi0Center = -1.37181, phiCenter = 154.929
module_odd: crystal_id = 556, phiCenter = 155.211, phi0Center = -1.37181, phiCenter = 155.211
module_odd: crystal_id = 557, phiCenter = 155.493, phi0Center = -1.37181, phiCenter = 155.493
module_odd: crystal_id = 558, phiCenter = 155.776, phi0Center = -1.37181, phiCenter = 155.776
module_odd: crystal_id = 559, phiCenter = 156.058, phi0Center = -1.37181, phiCenter = 156.058
module_odd: crystal_id = 560, phiCenter = 156.34, phi0Center = -1.37181, phiCenter = 156.34
module_odd: crystal_id = 561, phiCenter = 156.622, phi0Center = -1.37181, phiCenter = 156.622
module_odd: crystal_id = 562, phiCenter = 156.904, phi0Center = -1.37181, phiCenter = 156.904
module_odd: crystal_id = 563, phiCenter = 157.186, phi0Center = -1.37181, phiCenter = 157.186
module_odd: crystal_id = 564, phiCenter = 157.468, phi0Center = -1.37181, phiCenter = 157.468
module_odd: crystal_id = 565, phiCenter = 157.75, phi0Center = -1.37181, phiCenter = 157.75
module_odd: crystal_id = 566, phiCenter = 158.033, phi0Center = -1.37181, phiCenter = 158.033
module_odd: crystal_id = 567, phiCenter = 158.315, phi0Center = -1.37181, phiCenter = 158.315
module_odd: crystal_id = 568, phiCenter = 158.597, phi0Center = -1.37181, phiCenter = 158.597
module_odd: crystal_id = 569, phiCenter = 158.879, phi0Center = -1.37181, phiCenter = 158.879
module_odd: crystal_id = 570, phiCenter = 159.161, phi0Center = -1.37181, phiCenter = 159.161
module_odd: crystal_id = 571, phiCenter = 159.443, phi0Center = -1.37181, phiCenter = 159.443
module_odd: crystal_id = 572, phiCenter = 159.725, phi0Center = -1.37181, phiCenter = 159.725
module_odd: crystal_id = 573, phiCenter = 160.007, phi0Center = -1.37181, phiCenter = 160.007
module_odd: crystal_id = 574, phiCenter = 160.29, phi0Center = -1.37181, phiCenter = 160.29
module_odd: crystal_id = 575, phiCenter = 160.572, phi0Center = -1.37181, phiCenter = 160.572
module_odd: crystal_id = 576, phiCenter = 160.854, phi0Center = -1.37181, phiCenter = 160.854
module_odd: crystal_id = 577, phiCenter = 161.136, phi0Center = -1.37181, phiCenter = 161.136
module_odd: crystal_id = 578, phiCenter = 161.418, phi0Center = -1.37181, phiCenter = 161.418
module_odd: crystal_id = 579, phiCenter = 161.7, phi0Center = -1.37181, phiCenter = 161.7
module_odd: crystal_id = 580, phiCenter = 161.982, phi0Center = -1.37181, phiCenter = 161.982
module_odd: crystal_id = 581, phiCenter = 162.265, phi0Center = -1.37181, phiCenter = 162.265
module_odd: crystal_id = 582, phiCenter = 162.547, phi0Center = -1.37181, phiCenter = 162.547
module_odd: crystal_id = 583, phiCenter = 162.829, phi0Center = -1.37181, phiCenter = 162.829
module_odd: crystal_id = 584, phiCenter = 163.111, phi0Center = -1.37181, phiCenter = 163.111
module_odd: crystal_id = 585, phiCenter = 163.393, phi0Center = -1.37181, phiCenter = 163.393
module_odd: crystal_id = 586, phiCenter = 163.675, phi0Center = -1.37181, phiCenter = 163.675
module_odd: crystal_id = 587, phiCenter = 163.957, phi0Center = -1.37181, phiCenter = 163.957
module_odd: crystal_id = 588, phiCenter = 164.239, phi0Center = -1.37181, phiCenter = 164.239
module_odd: crystal_id = 589, phiCenter = 164.522, phi0Center = -1.37181, phiCenter = 164.522
module_odd: crystal_id = 590, phiCenter = 164.804, phi0Center = -1.37181, phiCenter = 164.804
module_odd: crystal_id = 591, phiCenter = 165.086, phi0Center = -1.37181, phiCenter = 165.086
module_odd: crystal_id = 592, phiCenter = 165.368, phi0Center = -1.37181, phiCenter = 165.368
module_odd: crystal_id = 593, phiCenter = 165.65, phi0Center = -1.37181, phiCenter = 165.65
module_odd: crystal_id = 594, phiCenter = 165.932, phi0Center = -1.37181, phiCenter = 165.932
module_odd: crystal_id = 595, phiCenter = 166.214, phi0Center = -1.37181, phiCenter = 166.214
module_odd: crystal_id = 596, phiCenter = 166.497, phi0Center = -1.37181, phiCenter = 166.497
module_odd: crystal_id = 597, phiCenter = 166.779, phi0Center = -1.37181, phiCenter = 166.779
module_odd: crystal_id = 598, phiCenter = 167.061, phi0Center = -1.37181, phiCenter = 167.061
module_odd: crystal_id = 599, phiCenter = 167.343, phi0Center = -1.37181, phiCenter = 167.343
module_odd: crystal_id = 600, phiCenter = 167.625, phi0Center = -1.37181, phiCenter = 167.625
module_odd: crystal_id = 601, phiCenter = 167.907, phi0Center = -1.37181, phiCenter = 167.907
module_odd: crystal_id = 602, phiCenter = 168.189, phi0Center = -1.37181, phiCenter = 168.189
module_odd: crystal_id = 603, phiCenter = 168.471, phi0Center = -1.37181, phiCenter = 168.471
module_odd: crystal_id = 604, phiCenter = 168.754, phi0Center = -1.37181, phiCenter = 168.754
module_odd: crystal_id = 605, phiCenter = 169.036, phi0Center = -1.37181, phiCenter = 169.036
module_odd: crystal_id = 606, phiCenter = 169.318, phi0Center = -1.37181, phiCenter = 169.318
module_odd: crystal_id = 607, phiCenter = 169.6, phi0Center = -1.37181, phiCenter = 169.6
module_odd: crystal_id = 608, phiCenter = 169.882, phi0Center = -1.37181, phiCenter = 169.882
module_odd: crystal_id = 609, phiCenter = 170.164, phi0Center = -1.37181, phiCenter = 170.164
module_odd: crystal_id = 610, phiCenter = 170.446, phi0Center = -1.37181, phiCenter = 170.446
module_odd: crystal_id = 611, phiCenter = 170.729, phi0Center = -1.37181, phiCenter = 170.729
module_odd: crystal_id = 612, phiCenter = 171.011, phi0Center = -1.37181, phiCenter = 171.011
module_odd: crystal_id = 613, phiCenter = 171.293, phi0Center = -1.37181, phiCenter = 171.293
module_odd: crystal_id = 614, phiCenter = 171.575, phi0Center = -1.37181, phiCenter = 171.575
module_odd: crystal_id = 615, phiCenter = 171.857, phi0Center = -1.37181, phiCenter = 171.857
module_odd: crystal_id = 616, phiCenter = 172.139, phi0Center = -1.37181, phiCenter = 172.139
module_odd: crystal_id = 617, phiCenter = 172.421, phi0Center = -1.37181, phiCenter = 172.421
module_odd: crystal_id = 618, phiCenter = 172.703, phi0Center = -1.37181, phiCenter = 172.703
module_odd: crystal_id = 619, phiCenter = 172.986, phi0Center = -1.37181, phiCenter = 172.986
module_odd: crystal_id = 620, phiCenter = 173.268, phi0Center = -1.37181, phiCenter = 173.268
module_odd: crystal_id = 621, phiCenter = 173.55, phi0Center = -1.37181, phiCenter = 173.55
module_odd: crystal_id = 622, phiCenter = 173.832, phi0Center = -1.37181, phiCenter = 173.832
module_odd: crystal_id = 623, phiCenter = 174.114, phi0Center = -1.37181, phiCenter = 174.114
module_odd: crystal_id = 624, phiCenter = 174.396, phi0Center = -1.37181, phiCenter = 174.396
module_odd: crystal_id = 625, phiCenter = 174.678, phi0Center = -1.37181, phiCenter = 174.678
module_odd: crystal_id = 626, phiCenter = 174.96, phi0Center = -1.37181, phiCenter = 174.96
module_odd: crystal_id = 627, phiCenter = 175.243, phi0Center = -1.37181, phiCenter = 175.243
module_odd: crystal_id = 628, phiCenter = 175.525, phi0Center = -1.37181, phiCenter = 175.525
module_odd: crystal_id = 629, phiCenter = 175.807, phi0Center = -1.37181, phiCenter = 175.807
module_odd: crystal_id = 630, phiCenter = 176.089, phi0Center = -1.37181, phiCenter = 176.089
module_odd: crystal_id = 631, phiCenter = 176.371, phi0Center = -1.37181, phiCenter = 176.371
module_odd: crystal_id = 632, phiCenter = 176.653, phi0Center = -1.37181, phiCenter = 176.653
module_odd: crystal_id = 633, phiCenter = 176.935, phi0Center = -1.37181, phiCenter = 176.935
module_odd: crystal_id = 634, phiCenter = 177.218, phi0Center = -1.37181, phiCenter = 177.218
module_odd: crystal_id = 635, phiCenter = 177.5, phi0Center = -1.37181, phiCenter = 177.5
module_odd: crystal_id = 636, phiCenter = 177.782, phi0Center = -1.37181, phiCenter = 177.782
module_odd: crystal_id = 637, phiCenter = 178.064, phi0Center = -1.37181, phiCenter = 178.064
module_odd: crystal_id = 638, phiCenter = 178.346, phi0Center = -1.37181, phiCenter = 178.346
module_odd: crystal_id = 639, phiCenter = 178.628, phi0Center = -1.37181, phiCenter = 178.628
module_odd: crystal_id = 640, phiCenter = 178.91, phi0Center = -1.37181, phiCenter = 178.91
module_odd: crystal_id = 641, phiCenter = 179.192, phi0Center = -1.37181, phiCenter = 179.192
module_odd: crystal_id = 642, phiCenter = 179.475, phi0Center = -1.37181, phiCenter = 179.475
module_odd: crystal_id = 643, phiCenter = 179.757, phi0Center = -1.37181, phiCenter = 179.757
module_odd: crystal_id = 644, phiCenter = 180.039, phi0Center = -1.37181, phiCenter = 180.039
module_odd: crystal_id = 645, phiCenter = 180.321, phi0Center = -1.37181, phiCenter = 180.321
module_odd: crystal_id = 646, phiCenter = 180.603, phi0Center = -1.37181, phiCenter = 180.603
module_odd: crystal_id = 647, phiCenter = 180.885, phi0Center = -1.37181, phiCenter = 180.885
module_odd: crystal_id = 648, phiCenter = 181.167, phi0Center = -1.37181, phiCenter = 181.167
module_odd: crystal_id = 649, phiCenter = 181.45, phi0Center = -1.37181, phiCenter = 181.45
module_odd: crystal_id = 650, phiCenter = 181.732, phi0Center = -1.37181, phiCenter = 181.732
module_odd: crystal_id = 651, phiCenter = 182.014, phi0Center = -1.37181, phiCenter = 182.014
module_odd: crystal_id = 652, phiCenter = 182.296, phi0Center = -1.37181, phiCenter = 182.296
module_odd: crystal_id = 653, phiCenter = 182.578, phi0Center = -1.37181, phiCenter = 182.578
module_odd: crystal_id = 654, phiCenter = 182.86, phi0Center = -1.37181, phiCenter = 182.86
module_odd: crystal_id = 655, phiCenter = 183.142, phi0Center = -1.37181, phiCenter = 183.142
module_odd: crystal_id = 656, phiCenter = 183.424, phi0Center = -1.37181, phiCenter = 183.424
module_odd: crystal_id = 657, phiCenter = 183.707, phi0Center = -1.37181, phiCenter = 183.707
module_odd: crystal_id = 658, phiCenter = 183.989, phi0Center = -1.37181, phiCenter = 183.989
module_odd: crystal_id = 659, phiCenter = 184.271, phi0Center = -1.37181, phiCenter = 184.271
module_odd: crystal_id = 660, phiCenter = 184.553, phi0Center = -1.37181, phiCenter = 184.553
module_odd: crystal_id = 661, phiCenter = 184.835, phi0Center = -1.37181, phiCenter = 184.835
module_odd: crystal_id = 662, phiCenter = 185.117, phi0Center = -1.37181, phiCenter = 185.117
module_odd: crystal_id = 663, phiCenter = 185.399, phi0Center = -1.37181, phiCenter = 185.399
module_odd: crystal_id = 664, phiCenter = 185.681, phi0Center = -1.37181, phiCenter = 185.681
module_odd: crystal_id = 665, phiCenter = 185.964, phi0Center = -1.37181, phiCenter = 185.964
module_odd: crystal_id = 666, phiCenter = 186.246, phi0Center = -1.37181, phiCenter = 186.246
module_odd: crystal_id = 667, phiCenter = 186.528, phi0Center = -1.37181, phiCenter = 186.528
module_odd: crystal_id = 668, phiCenter = 186.81, phi0Center = -1.37181, phiCenter = 186.81
module_odd: crystal_id = 669, phiCenter = 187.092, phi0Center = -1.37181, phiCenter = 187.092
module_odd: crystal_id = 670, phiCenter = 187.374, phi0Center = -1.37181, phiCenter = 187.374
module_odd: crystal_id = 671, phiCenter = 187.656, phi0Center = -1.37181, phiCenter = 187.656
module_odd: crystal_id = 672, phiCenter = 187.939, phi0Center = -1.37181, phiCenter = 187.939
module_odd: crystal_id = 673, phiCenter = 188.221, phi0Center = -1.37181, phiCenter = 188.221
module_odd: crystal_id = 674, phiCenter = 188.503, phi0Center = -1.37181, phiCenter = 188.503
module_odd: crystal_id = 675, phiCenter = 188.785, phi0Center = -1.37181, phiCenter = 188.785
module_odd: crystal_id = 676, phiCenter = 189.067, phi0Center = -1.37181, phiCenter = 189.067
module_odd: crystal_id = 677, phiCenter = 189.349, phi0Center = -1.37181, phiCenter = 189.349
module_odd: crystal_id = 678, phiCenter = 189.631, phi0Center = -1.37181, phiCenter = 189.631
module_odd: crystal_id = 679, phiCenter = 189.913, phi0Center = -1.37181, phiCenter = 189.913
module_odd: crystal_id = 680, phiCenter = 190.196, phi0Center = -1.37181, phiCenter = 190.196
module_odd: crystal_id = 681, phiCenter = 190.478, phi0Center = -1.37181, phiCenter = 190.478
module_odd: crystal_id = 682, phiCenter = 190.76, phi0Center = -1.37181, phiCenter = 190.76
module_odd: crystal_id = 683, phiCenter = 191.042, phi0Center = -1.37181, phiCenter = 191.042
module_odd: crystal_id = 684, phiCenter = 191.324, phi0Center = -1.37181, phiCenter = 191.324
module_odd: crystal_id = 685, phiCenter = 191.606, phi0Center = -1.37181, phiCenter = 191.606
module_odd: crystal_id = 686, phiCenter = 191.888, phi0Center = -1.37181, phiCenter = 191.888
module_odd: crystal_id = 687, phiCenter = 192.171, phi0Center = -1.37181, phiCenter = 192.171
module_odd: crystal_id = 688, phiCenter = 192.453, phi0Center = -1.37181, phiCenter = 192.453
module_odd: crystal_id = 689, phiCenter = 192.735, phi0Center = -1.37181, phiCenter = 192.735
module_odd: crystal_id = 690, phiCenter = 193.017, phi0Center = -1.37181, phiCenter = 193.017
module_odd: crystal_id = 691, phiCenter = 193.299, phi0Center = -1.37181, phiCenter = 193.299
module_odd: crystal_id = 692, phiCenter = 193.581, phi0Center = -1.37181, phiCenter = 193.581
module_odd: crystal_id = 693, phiCenter = 193.863, phi0Center = -1.37181, phiCenter = 193.863
module_odd: crystal_id = 694, phiCenter = 194.145, phi0Center = -1.37181, phiCenter = 194.145
module_odd: crystal_id = 695, phiCenter = 194.428, phi0Center = -1.37181, phiCenter = 194.428
module_odd: crystal_id = 696, phiCenter = 194.71, phi0Center = -1.37181, phiCenter = 194.71
module_odd: crystal_id = 697, phiCenter = 194.992, phi0Center = -1.37181, phiCenter = 194.992
module_odd: crystal_id = 698, phiCenter = 195.274, phi0Center = -1.37181, phiCenter = 195.274
module_odd: crystal_id = 699, phiCenter = 195.556, phi0Center = -1.37181, phiCenter = 195.556
module_odd: crystal_id = 700, phiCenter = 195.838, phi0Center = -1.37181, phiCenter = 195.838
module_odd: crystal_id = 701, phiCenter = 196.12, phi0Center = -1.37181, phiCenter = 196.12
module_odd: crystal_id = 702, phiCenter = 196.402, phi0Center = -1.37181, phiCenter = 196.402
module_odd: crystal_id = 703, phiCenter = 196.685, phi0Center = -1.37181, phiCenter = 196.685
module_odd: crystal_id = 704, phiCenter = 196.967, phi0Center = -1.37181, phiCenter = 196.967
module_odd: crystal_id = 705, phiCenter = 197.249, phi0Center = -1.37181, phiCenter = 197.249
module_odd: crystal_id = 706, phiCenter = 197.531, phi0Center = -1.37181, phiCenter = 197.531
module_odd: crystal_id = 707, phiCenter = 197.813, phi0Center = -1.37181, phiCenter = 197.813
module_odd: crystal_id = 708, phiCenter = 198.095, phi0Center = -1.37181, phiCenter = 198.095
module_odd: crystal_id = 709, phiCenter = 198.377, phi0Center = -1.37181, phiCenter = 198.377
module_odd: crystal_id = 710, phiCenter = 198.66, phi0Center = -1.37181, phiCenter = 198.66
module_odd: crystal_id = 711, phiCenter = 198.942, phi0Center = -1.37181, phiCenter = 198.942
module_odd: crystal_id = 712, phiCenter = 199.224, phi0Center = -1.37181, phiCenter = 199.224
module_odd: crystal_id = 713, phiCenter = 199.506, phi0Center = -1.37181, phiCenter = 199.506
module_odd: crystal_id = 714, phiCenter = 199.788, phi0Center = -1.37181, phiCenter = 199.788
module_odd: crystal_id = 715, phiCenter = 200.07, phi0Center = -1.37181, phiCenter = 200.07
module_odd: crystal_id = 716, phiCenter = 200.352, phi0Center = -1.37181, phiCenter = 200.352
module_odd: crystal_id = 717, phiCenter = 200.634, phi0Center = -1.37181, phiCenter = 200.634
module_odd: crystal_id = 718, phiCenter = 200.917, phi0Center = -1.37181, phiCenter = 200.917
module_odd: crystal_id = 719, phiCenter = 201.199, phi0Center = -1.37181, phiCenter = 201.199
module_odd: crystal_id = 720, phiCenter = 201.481, phi0Center = -1.37181, phiCenter = 201.481
module_odd: crystal_id = 721, phiCenter = 201.763, phi0Center = -1.37181, phiCenter = 201.763
module_odd: crystal_id = 722, phiCenter = 202.045, phi0Center = -1.37181, phiCenter = 202.045
module_odd: crystal_id = 723, phiCenter = 202.327, phi0Center = -1.37181, phiCenter = 202.327
module_odd: crystal_id = 724, phiCenter = 202.609, phi0Center = -1.37181, phiCenter = 202.609
module_odd: crystal_id = 725, phiCenter = 202.892, phi0Center = -1.37181, phiCenter = 202.892
module_odd: crystal_id = 726, phiCenter = 203.174, phi0Center = -1.37181, phiCenter = 203.174
module_odd: crystal_id = 727, phiCenter = 203.456, phi0Center = -1.37181, phiCenter = 203.456
module_odd: crystal_id = 728, phiCenter = 203.738, phi0Center = -1.37181, phiCenter = 203.738
module_odd: crystal_id = 729, phiCenter = 204.02, phi0Center = -1.37181, phiCenter = 204.02
module_odd: crystal_id = 730, phiCenter = 204.302, phi0Center = -1.37181, phiCenter = 204.302
module_odd: crystal_id = 731, phiCenter = 204.584, phi0Center = -1.37181, phiCenter = 204.584
module_odd: crystal_id = 732, phiCenter = 204.866, phi0Center = -1.37181, phiCenter = 204.866
module_odd: crystal_id = 733, phiCenter = 205.149, phi0Center = -1.37181, phiCenter = 205.149
module_odd: crystal_id = 734, phiCenter = 205.431, phi0Center = -1.37181, phiCenter = 205.431
module_odd: crystal_id = 735, phiCenter = 205.713, phi0Center = -1.37181, phiCenter = 205.713
module_odd: crystal_id = 736, phiCenter = 205.995, phi0Center = -1.37181, phiCenter = 205.995
module_odd: crystal_id = 737, phiCenter = 206.277, phi0Center = -1.37181, phiCenter = 206.277
module_odd: crystal_id = 738, phiCenter = 206.559, phi0Center = -1.37181, phiCenter = 206.559
module_odd: crystal_id = 739, phiCenter = 206.841, phi0Center = -1.37181, phiCenter = 206.841
module_odd: crystal_id = 740, phiCenter = 207.123, phi0Center = -1.37181, phiCenter = 207.123
module_odd: crystal_id = 741, phiCenter = 207.406, phi0Center = -1.37181, phiCenter = 207.406
module_odd: crystal_id = 742, phiCenter = 207.688, phi0Center = -1.37181, phiCenter = 207.688
module_odd: crystal_id = 743, phiCenter = 207.97, phi0Center = -1.37181, phiCenter = 207.97
module_odd: crystal_id = 744, phiCenter = 208.252, phi0Center = -1.37181, phiCenter = 208.252
module_odd: crystal_id = 745, phiCenter = 208.534, phi0Center = -1.37181, phiCenter = 208.534
module_odd: crystal_id = 746, phiCenter = 208.816, phi0Center = -1.37181, phiCenter = 208.816
module_odd: crystal_id = 747, phiCenter = 209.098, phi0Center = -1.37181, phiCenter = 209.098
module_odd: crystal_id = 748, phiCenter = 209.381, phi0Center = -1.37181, phiCenter = 209.381
module_odd: crystal_id = 749, phiCenter = 209.663, phi0Center = -1.37181, phiCenter = 209.663
module_odd: crystal_id = 750, phiCenter = 209.945, phi0Center = -1.37181, phiCenter = 209.945
module_odd: crystal_id = 751, phiCenter = 210.227, phi0Center = -1.37181, phiCenter = 210.227
module_odd: crystal_id = 752, phiCenter = 210.509, phi0Center = -1.37181, phiCenter = 210.509
module_odd: crystal_id = 753, phiCenter = 210.791, phi0Center = -1.37181, phiCenter = 210.791
module_odd: crystal_id = 754, phiCenter = 211.073, phi0Center = -1.37181, phiCenter = 211.073
module_odd: crystal_id = 755, phiCenter = 211.355, phi0Center = -1.37181, phiCenter = 211.355
module_odd: crystal_id = 756, phiCenter = 211.638, phi0Center = -1.37181, phiCenter = 211.638
module_odd: crystal_id = 757, phiCenter = 211.92, phi0Center = -1.37181, phiCenter = 211.92
module_odd: crystal_id = 758, phiCenter = 212.202, phi0Center = -1.37181, phiCenter = 212.202
module_odd: crystal_id = 759, phiCenter = 212.484, phi0Center = -1.37181, phiCenter = 212.484
module_odd: crystal_id = 760, phiCenter = 212.766, phi0Center = -1.37181, phiCenter = 212.766
module_odd: crystal_id = 761, phiCenter = 213.048, phi0Center = -1.37181, phiCenter = 213.048
module_odd: crystal_id = 762, phiCenter = 213.33, phi0Center = -1.37181, phiCenter = 213.33
module_odd: crystal_id = 763, phiCenter = 213.613, phi0Center = -1.37181, phiCenter = 213.613
module_odd: crystal_id = 764, phiCenter = 213.895, phi0Center = -1.37181, phiCenter = 213.895
module_odd: crystal_id = 765, phiCenter = 214.177, phi0Center = -1.37181, phiCenter = 214.177
module_odd: crystal_id = 766, phiCenter = 214.459, phi0Center = -1.37181, phiCenter = 214.459
module_odd: crystal_id = 767, phiCenter = 214.741, phi0Center = -1.37181, phiCenter = 214.741
module_odd: crystal_id = 768, phiCenter = 215.023, phi0Center = -1.37181, phiCenter = 215.023
module_odd: crystal_id = 769, phiCenter = 215.305, phi0Center = -1.37181, phiCenter = 215.305
module_odd: crystal_id = 770, phiCenter = 215.587, phi0Center = -1.37181, phiCenter = 215.587
module_odd: crystal_id = 771, phiCenter = 215.87, phi0Center = -1.37181, phiCenter = 215.87
module_odd: crystal_id = 772, phiCenter = 216.152, phi0Center = -1.37181, phiCenter = 216.152
module_odd: crystal_id = 773, phiCenter = 216.434, phi0Center = -1.37181, phiCenter = 216.434
module_odd: crystal_id = 774, phiCenter = 216.716, phi0Center = -1.37181, phiCenter = 216.716
module_odd: crystal_id = 775, phiCenter = 216.998, phi0Center = -1.37181, phiCenter = 216.998
module_odd: crystal_id = 776, phiCenter = 217.28, phi0Center = -1.37181, phiCenter = 217.28
module_odd: crystal_id = 777, phiCenter = 217.562, phi0Center = -1.37181, phiCenter = 217.562
module_odd: crystal_id = 778, phiCenter = 217.844, phi0Center = -1.37181, phiCenter = 217.844
module_odd: crystal_id = 779, phiCenter = 218.127, phi0Center = -1.37181, phiCenter = 218.127
module_odd: crystal_id = 780, phiCenter = 218.409, phi0Center = -1.37181, phiCenter = 218.409
module_odd: crystal_id = 781, phiCenter = 218.691, phi0Center = -1.37181, phiCenter = 218.691
module_odd: crystal_id = 782, phiCenter = 218.973, phi0Center = -1.37181, phiCenter = 218.973
module_odd: crystal_id = 783, phiCenter = 219.255, phi0Center = -1.37181, phiCenter = 219.255
module_odd: crystal_id = 784, phiCenter = 219.537, phi0Center = -1.37181, phiCenter = 219.537
module_odd: crystal_id = 785, phiCenter = 219.819, phi0Center = -1.37181, phiCenter = 219.819
module_odd: crystal_id = 786, phiCenter = 220.102, phi0Center = -1.37181, phiCenter = 220.102
module_odd: crystal_id = 787, phiCenter = 220.384, phi0Center = -1.37181, phiCenter = 220.384
module_odd: crystal_id = 788, phiCenter = 220.666, phi0Center = -1.37181, phiCenter = 220.666
module_odd: crystal_id = 789, phiCenter = 220.948, phi0Center = -1.37181, phiCenter = 220.948
module_odd: crystal_id = 790, phiCenter = 221.23, phi0Center = -1.37181, phiCenter = 221.23
module_odd: crystal_id = 791, phiCenter = 221.512, phi0Center = -1.37181, phiCenter = 221.512
module_odd: crystal_id = 792, phiCenter = 221.794, phi0Center = -1.37181, phiCenter = 221.794
module_odd: crystal_id = 793, phiCenter = 222.076, phi0Center = -1.37181, phiCenter = 222.076
module_odd: crystal_id = 794, phiCenter = 222.359, phi0Center = -1.37181, phiCenter = 222.359
module_odd: crystal_id = 795, phiCenter = 222.641, phi0Center = -1.37181, phiCenter = 222.641
module_odd: crystal_id = 796, phiCenter = 222.923, phi0Center = -1.37181, phiCenter = 222.923
module_odd: crystal_id = 797, phiCenter = 223.205, phi0Center = -1.37181, phiCenter = 223.205
module_odd: crystal_id = 798, phiCenter = 223.487, phi0Center = -1.37181, phiCenter = 223.487
module_odd: crystal_id = 799, phiCenter = 223.769, phi0Center = -1.37181, phiCenter = 223.769
module_odd: crystal_id = 800, phiCenter = 224.051, phi0Center = -1.37181, phiCenter = 224.051
module_odd: crystal_id = 801, phiCenter = 224.334, phi0Center = -1.37181, phiCenter = 224.334
module_odd: crystal_id = 802, phiCenter = 224.616, phi0Center = -1.37181, phiCenter = 224.616
module_odd: crystal_id = 803, phiCenter = 224.898, phi0Center = -1.37181, phiCenter = 224.898
module_odd: crystal_id = 804, phiCenter = 225.18, phi0Center = -1.37181, phiCenter = 225.18
module_odd: crystal_id = 805, phiCenter = 225.462, phi0Center = -1.37181, phiCenter = 225.462
module_odd: crystal_id = 806, phiCenter = 225.744, phi0Center = -1.37181, phiCenter = 225.744
module_odd: crystal_id = 807, phiCenter = 226.026, phi0Center = -1.37181, phiCenter = 226.026
module_odd: crystal_id = 808, phiCenter = 226.308, phi0Center = -1.37181, phiCenter = 226.308
module_odd: crystal_id = 809, phiCenter = 226.591, phi0Center = -1.37181, phiCenter = 226.591
module_odd: crystal_id = 810, phiCenter = 226.873, phi0Center = -1.37181, phiCenter = 226.873
module_odd: crystal_id = 811, phiCenter = 227.155, phi0Center = -1.37181, phiCenter = 227.155
module_odd: crystal_id = 812, phiCenter = 227.437, phi0Center = -1.37181, phiCenter = 227.437
module_odd: crystal_id = 813, phiCenter = 227.719, phi0Center = -1.37181, phiCenter = 227.719
module_odd: crystal_id = 814, phiCenter = 228.001, phi0Center = -1.37181, phiCenter = 228.001
module_odd: crystal_id = 815, phiCenter = 228.283, phi0Center = -1.37181, phiCenter = 228.283
module_odd: crystal_id = 816, phiCenter = 228.565, phi0Center = -1.37181, phiCenter = 228.565
module_odd: crystal_id = 817, phiCenter = 228.848, phi0Center = -1.37181, phiCenter = 228.848
module_odd: crystal_id = 818, phiCenter = 229.13, phi0Center = -1.37181, phiCenter = 229.13
module_odd: crystal_id = 819, phiCenter = 229.412, phi0Center = -1.37181, phiCenter = 229.412
module_odd: crystal_id = 820, phiCenter = 229.694, phi0Center = -1.37181, phiCenter = 229.694
module_odd: crystal_id = 821, phiCenter = 229.976, phi0Center = -1.37181, phiCenter = 229.976
module_odd: crystal_id = 822, phiCenter = 230.258, phi0Center = -1.37181, phiCenter = 230.258
module_odd: crystal_id = 823, phiCenter = 230.54, phi0Center = -1.37181, phiCenter = 230.54
module_odd: crystal_id = 824, phiCenter = 230.823, phi0Center = -1.37181, phiCenter = 230.823
module_odd: crystal_id = 825, phiCenter = 231.105, phi0Center = -1.37181, phiCenter = 231.105
module_odd: crystal_id = 826, phiCenter = 231.387, phi0Center = -1.37181, phiCenter = 231.387
module_odd: crystal_id = 827, phiCenter = 231.669, phi0Center = -1.37181, phiCenter = 231.669
module_odd: crystal_id = 828, phiCenter = 231.951, phi0Center = -1.37181, phiCenter = 231.951
module_odd: crystal_id = 829, phiCenter = 232.233, phi0Center = -1.37181, phiCenter = 232.233
module_odd: crystal_id = 830, phiCenter = 232.515, phi0Center = -1.37181, phiCenter = 232.515
module_odd: crystal_id = 831, phiCenter = 232.797, phi0Center = -1.37181, phiCenter = 232.797
module_odd: crystal_id = 832, phiCenter = 233.08, phi0Center = -1.37181, phiCenter = 233.08
module_odd: crystal_id = 833, phiCenter = 233.362, phi0Center = -1.37181, phiCenter = 233.362
module_odd: crystal_id = 834, phiCenter = 233.644, phi0Center = -1.37181, phiCenter = 233.644
module_odd: crystal_id = 835, phiCenter = 233.926, phi0Center = -1.37181, phiCenter = 233.926
module_odd: crystal_id = 836, phiCenter = 234.208, phi0Center = -1.37181, phiCenter = 234.208
module_odd: crystal_id = 837, phiCenter = 234.49, phi0Center = -1.37181, phiCenter = 234.49
module_odd: crystal_id = 838, phiCenter = 234.772, phi0Center = -1.37181, phiCenter = 234.772
module_odd: crystal_id = 839, phiCenter = 235.055, phi0Center = -1.37181, phiCenter = 235.055
module_odd: crystal_id = 840, phiCenter = 235.337, phi0Center = -1.37181, phiCenter = 235.337
module_odd: crystal_id = 841, phiCenter = 235.619, phi0Center = -1.37181, phiCenter = 235.619
module_odd: crystal_id = 842, phiCenter = 235.901, phi0Center = -1.37181, phiCenter = 235.901
module_odd: crystal_id = 843, phiCenter = 236.183, phi0Center = -1.37181, phiCenter = 236.183
module_odd: crystal_id = 844, phiCenter = 236.465, phi0Center = -1.37181, phiCenter = 236.465
module_odd: crystal_id = 845, phiCenter = 236.747, phi0Center = -1.37181, phiCenter = 236.747
module_odd: crystal_id = 846, phiCenter = 237.029, phi0Center = -1.37181, phiCenter = 237.029
module_odd: crystal_id = 847, phiCenter = 237.312, phi0Center = -1.37181, phiCenter = 237.312
module_odd: crystal_id = 848, phiCenter = 237.594, phi0Center = -1.37181, phiCenter = 237.594
module_odd: crystal_id = 849, phiCenter = 237.876, phi0Center = -1.37181, phiCenter = 237.876
module_odd: crystal_id = 850, phiCenter = 238.158, phi0Center = -1.37181, phiCenter = 238.158
module_odd: crystal_id = 851, phiCenter = 238.44, phi0Center = -1.37181, phiCenter = 238.44
module_odd: crystal_id = 852, phiCenter = 238.722, phi0Center = -1.37181, phiCenter = 238.722
module_odd: crystal_id = 853, phiCenter = 239.004, phi0Center = -1.37181, phiCenter = 239.004
module_odd: crystal_id = 854, phiCenter = 239.286, phi0Center = -1.37181, phiCenter = 239.286
module_odd: crystal_id = 855, phiCenter = 239.569, phi0Center = -1.37181, phiCenter = 239.569
module_odd: crystal_id = 856, phiCenter = 239.851, phi0Center = -1.37181, phiCenter = 239.851
module_odd: crystal_id = 857, phiCenter = 240.133, phi0Center = -1.37181, phiCenter = 240.133
module_odd: crystal_id = 858, phiCenter = 240.415, phi0Center = -1.37181, phiCenter = 240.415
module_odd: crystal_id = 859, phiCenter = 240.697, phi0Center = -1.37181, phiCenter = 240.697
module_odd: crystal_id = 860, phiCenter = 240.979, phi0Center = -1.37181, phiCenter = 240.979
module_odd: crystal_id = 861, phiCenter = 241.261, phi0Center = -1.37181, phiCenter = 241.261
module_odd: crystal_id = 862, phiCenter = 241.544, phi0Center = -1.37181, phiCenter = 241.544
module_odd: crystal_id = 863, phiCenter = 241.826, phi0Center = -1.37181, phiCenter = 241.826
module_odd: crystal_id = 864, phiCenter = 242.108, phi0Center = -1.37181, phiCenter = 242.108
module_odd: crystal_id = 865, phiCenter = 242.39, phi0Center = -1.37181, phiCenter = 242.39
module_odd: crystal_id = 866, phiCenter = 242.672, phi0Center = -1.37181, phiCenter = 242.672
module_odd: crystal_id = 867, phiCenter = 242.954, phi0Center = -1.37181, phiCenter = 242.954
module_odd: crystal_id = 868, phiCenter = 243.236, phi0Center = -1.37181, phiCenter = 243.236
module_odd: crystal_id = 869, phiCenter = 243.518, phi0Center = -1.37181, phiCenter = 243.518
module_odd: crystal_id = 870, phiCenter = 243.801, phi0Center = -1.37181, phiCenter = 243.801
module_odd: crystal_id = 871, phiCenter = 244.083, phi0Center = -1.37181, phiCenter = 244.083
module_odd: crystal_id = 872, phiCenter = 244.365, phi0Center = -1.37181, phiCenter = 244.365
module_odd: crystal_id = 873, phiCenter = 244.647, phi0Center = -1.37181, phiCenter = 244.647
module_odd: crystal_id = 874, phiCenter = 244.929, phi0Center = -1.37181, phiCenter = 244.929
module_odd: crystal_id = 875, phiCenter = 245.211, phi0Center = -1.37181, phiCenter = 245.211
module_odd: crystal_id = 876, phiCenter = 245.493, phi0Center = -1.37181, phiCenter = 245.493
module_odd: crystal_id = 877, phiCenter = 245.776, phi0Center = -1.37181, phiCenter = 245.776
module_odd: crystal_id = 878, phiCenter = 246.058, phi0Center = -1.37181, phiCenter = 246.058
module_odd: crystal_id = 879, phiCenter = 246.34, phi0Center = -1.37181, phiCenter = 246.34
module_odd: crystal_id = 880, phiCenter = 246.622, phi0Center = -1.37181, phiCenter = 246.622
module_odd: crystal_id = 881, phiCenter = 246.904, phi0Center = -1.37181, phiCenter = 246.904
module_odd: crystal_id = 882, phiCenter = 247.186, phi0Center = -1.37181, phiCenter = 247.186
module_odd: crystal_id = 883, phiCenter = 247.468, phi0Center = -1.37181, phiCenter = 247.468
module_odd: crystal_id = 884, phiCenter = 247.75, phi0Center = -1.37181, phiCenter = 247.75
module_odd: crystal_id = 885, phiCenter = 248.033, phi0Center = -1.37181, phiCenter = 248.033
module_odd: crystal_id = 886, phiCenter = 248.315, phi0Center = -1.37181, phiCenter = 248.315
module_odd: crystal_id = 887, phiCenter = 248.597, phi0Center = -1.37181, phiCenter = 248.597
module_odd: crystal_id = 888, phiCenter = 248.879, phi0Center = -1.37181, phiCenter = 248.879
module_odd: crystal_id = 889, phiCenter = 249.161, phi0Center = -1.37181, phiCenter = 249.161
module_odd: crystal_id = 890, phiCenter = 249.443, phi0Center = -1.37181, phiCenter = 249.443
module_odd: crystal_id = 891, phiCenter = 249.725, phi0Center = -1.37181, phiCenter = 249.725
module_odd: crystal_id = 892, phiCenter = 250.007, phi0Center = -1.37181, phiCenter = 250.007
module_odd: crystal_id = 893, phiCenter = 250.29, phi0Center = -1.37181, phiCenter = 250.29
module_odd: crystal_id = 894, phiCenter = 250.572, phi0Center = -1.37181, phiCenter = 250.572
module_odd: crystal_id = 895, phiCenter = 250.854, phi0Center = -1.37181, phiCenter = 250.854
module_odd: crystal_id = 896, phiCenter = 251.136, phi0Center = -1.37181, phiCenter = 251.136
module_odd: crystal_id = 897, phiCenter = 251.418, phi0Center = -1.37181, phiCenter = 251.418
module_odd: crystal_id = 898, phiCenter = 251.7, phi0Center = -1.37181, phiCenter = 251.7
module_odd: crystal_id = 899, phiCenter = 251.982, phi0Center = -1.37181, phiCenter = 251.982
module_odd: crystal_id = 900, phiCenter = 252.265, phi0Center = -1.37181, phiCenter = 252.265
module_odd: crystal_id = 901, phiCenter = 252.547, phi0Center = -1.37181, phiCenter = 252.547
module_odd: crystal_id = 902, phiCenter = 252.829, phi0Center = -1.37181, phiCenter = 252.829
module_odd: crystal_id = 903, phiCenter = 253.111, phi0Center = -1.37181, phiCenter = 253.111
module_odd: crystal_id = 904, phiCenter = 253.393, phi0Center = -1.37181, phiCenter = 253.393
module_odd: crystal_id = 905, phiCenter = 253.675, phi0Center = -1.37181, phiCenter = 253.675
module_odd: crystal_id = 906, phiCenter = 253.957, phi0Center = -1.37181, phiCenter = 253.957
module_odd: crystal_id = 907, phiCenter = 254.239, phi0Center = -1.37181, phiCenter = 254.239
module_odd: crystal_id = 908, phiCenter = 254.522, phi0Center = -1.37181, phiCenter = 254.522
module_odd: crystal_id = 909, phiCenter = 254.804, phi0Center = -1.37181, phiCenter = 254.804
module_odd: crystal_id = 910, phiCenter = 255.086, phi0Center = -1.37181, phiCenter = 255.086
module_odd: crystal_id = 911, phiCenter = 255.368, phi0Center = -1.37181, phiCenter = 255.368
module_odd: crystal_id = 912, phiCenter = 255.65, phi0Center = -1.37181, phiCenter = 255.65
module_odd: crystal_id = 913, phiCenter = 255.932, phi0Center = -1.37181, phiCenter = 255.932
module_odd: crystal_id = 914, phiCenter = 256.214, phi0Center = -1.37181, phiCenter = 256.214
module_odd: crystal_id = 915, phiCenter = 256.497, phi0Center = -1.37181, phiCenter = 256.497
module_odd: crystal_id = 916, phiCenter = 256.779, phi0Center = -1.37181, phiCenter = 256.779
module_odd: crystal_id = 917, phiCenter = 257.061, phi0Center = -1.37181, phiCenter = 257.061
module_odd: crystal_id = 918, phiCenter = 257.343, phi0Center = -1.37181, phiCenter = 257.343
module_odd: crystal_id = 919, phiCenter = 257.625, phi0Center = -1.37181, phiCenter = 257.625
module_odd: crystal_id = 920, phiCenter = 257.907, phi0Center = -1.37181, phiCenter = 257.907
module_odd: crystal_id = 921, phiCenter = 258.189, phi0Center = -1.37181, phiCenter = 258.189
module_odd: crystal_id = 922, phiCenter = 258.471, phi0Center = -1.37181, phiCenter = 258.471
module_odd: crystal_id = 923, phiCenter = 258.754, phi0Center = -1.37181, phiCenter = 258.754
module_odd: crystal_id = 924, phiCenter = 259.036, phi0Center = -1.37181, phiCenter = 259.036
module_odd: crystal_id = 925, phiCenter = 259.318, phi0Center = -1.37181, phiCenter = 259.318
module_odd: crystal_id = 926, phiCenter = 259.6, phi0Center = -1.37181, phiCenter = 259.6
module_odd: crystal_id = 927, phiCenter = 259.882, phi0Center = -1.37181, phiCenter = 259.882
module_odd: crystal_id = 928, phiCenter = 260.164, phi0Center = -1.37181, phiCenter = 260.164
module_odd: crystal_id = 929, phiCenter = 260.446, phi0Center = -1.37181, phiCenter = 260.446
module_odd: crystal_id = 930, phiCenter = 260.729, phi0Center = -1.37181, phiCenter = 260.729
module_odd: crystal_id = 931, phiCenter = 261.011, phi0Center = -1.37181, phiCenter = 261.011
module_odd: crystal_id = 932, phiCenter = 261.293, phi0Center = -1.37181, phiCenter = 261.293
module_odd: crystal_id = 933, phiCenter = 261.575, phi0Center = -1.37181, phiCenter = 261.575
module_odd: crystal_id = 934, phiCenter = 261.857, phi0Center = -1.37181, phiCenter = 261.857
module_odd: crystal_id = 935, phiCenter = 262.139, phi0Center = -1.37181, phiCenter = 262.139
module_odd: crystal_id = 936, phiCenter = 262.421, phi0Center = -1.37181, phiCenter = 262.421
module_odd: crystal_id = 937, phiCenter = 262.703, phi0Center = -1.37181, phiCenter = 262.703
module_odd: crystal_id = 938, phiCenter = 262.986, phi0Center = -1.37181, phiCenter = 262.986
module_odd: crystal_id = 939, phiCenter = 263.268, phi0Center = -1.37181, phiCenter = 263.268
module_odd: crystal_id = 940, phiCenter = 263.55, phi0Center = -1.37181, phiCenter = 263.55
module_odd: crystal_id = 941, phiCenter = 263.832, phi0Center = -1.37181, phiCenter = 263.832
module_odd: crystal_id = 942, phiCenter = 264.114, phi0Center = -1.37181, phiCenter = 264.114
module_odd: crystal_id = 943, phiCenter = 264.396, phi0Center = -1.37181, phiCenter = 264.396
module_odd: crystal_id = 944, phiCenter = 264.678, phi0Center = -1.37181, phiCenter = 264.678
module_odd: crystal_id = 945, phiCenter = 264.96, phi0Center = -1.37181, phiCenter = 264.96
module_odd: crystal_id = 946, phiCenter = 265.243, phi0Center = -1.37181, phiCenter = 265.243
module_odd: crystal_id = 947, phiCenter = 265.525, phi0Center = -1.37181, phiCenter = 265.525
module_odd: crystal_id = 948, phiCenter = 265.807, phi0Center = -1.37181, phiCenter = 265.807
module_odd: crystal_id = 949, phiCenter = 266.089, phi0Center = -1.37181, phiCenter = 266.089
module_odd: crystal_id = 950, phiCenter = 266.371, phi0Center = -1.37181, phiCenter = 266.371
module_odd: crystal_id = 951, phiCenter = 266.653, phi0Center = -1.37181, phiCenter = 266.653
module_odd: crystal_id = 952, phiCenter = 266.935, phi0Center = -1.37181, phiCenter = 266.935
module_odd: crystal_id = 953, phiCenter = 267.218, phi0Center = -1.37181, phiCenter = 267.218
module_odd: crystal_id = 954, phiCenter = 267.5, phi0Center = -1.37181, phiCenter = 267.5
module_odd: crystal_id = 955, phiCenter = 267.782, phi0Center = -1.37181, phiCenter = 267.782
module_odd: crystal_id = 956, phiCenter = 268.064, phi0Center = -1.37181, phiCenter = 268.064
module_odd: crystal_id = 957, phiCenter = 268.346, phi0Center = -1.37181, phiCenter = 268.346
module_odd: crystal_id = 958, phiCenter = 268.628, phi0Center = -1.37181, phiCenter = 268.628
module_odd: crystal_id = 959, phiCenter = 268.91, phi0Center = -1.37181, phiCenter = 268.91
module_odd: crystal_id = 960, phiCenter = 269.192, phi0Center = -1.37181, phiCenter = 269.192
module_odd: crystal_id = 961, phiCenter = 269.475, phi0Center = -1.37181, phiCenter = 269.475
module_odd: crystal_id = 962, phiCenter = 269.757, phi0Center = -1.37181, phiCenter = 269.757
module_odd: crystal_id = 963, phiCenter = 270.039, phi0Center = -1.37181, phiCenter = 270.039
module_odd: crystal_id = 964, phiCenter = 270.321, phi0Center = -1.37181, phiCenter = 270.321
module_odd: crystal_id = 965, phiCenter = 270.603, phi0Center = -1.37181, phiCenter = 270.603
module_odd: crystal_id = 966, phiCenter = 270.885, phi0Center = -1.37181, phiCenter = 270.885
module_odd: crystal_id = 967, phiCenter = 271.167, phi0Center = -1.37181, phiCenter = 271.167
module_odd: crystal_id = 968, phiCenter = 271.45, phi0Center = -1.37181, phiCenter = 271.45
module_odd: crystal_id = 969, phiCenter = 271.732, phi0Center = -1.37181, phiCenter = 271.732
module_odd: crystal_id = 970, phiCenter = 272.014, phi0Center = -1.37181, phiCenter = 272.014
module_odd: crystal_id = 971, phiCenter = 272.296, phi0Center = -1.37181, phiCenter = 272.296
module_odd: crystal_id = 972, phiCenter = 272.578, phi0Center = -1.37181, phiCenter = 272.578
module_odd: crystal_id = 973, phiCenter = 272.86, phi0Center = -1.37181, phiCenter = 272.86
module_odd: crystal_id = 974, phiCenter = 273.142, phi0Center = -1.37181, phiCenter = 273.142
module_odd: crystal_id = 975, phiCenter = 273.424, phi0Center = -1.37181, phiCenter = 273.424
module_odd: crystal_id = 976, phiCenter = 273.707, phi0Center = -1.37181, phiCenter = 273.707
module_odd: crystal_id = 977, phiCenter = 273.989, phi0Center = -1.37181, phiCenter = 273.989
module_odd: crystal_id = 978, phiCenter = 274.271, phi0Center = -1.37181, phiCenter = 274.271
module_odd: crystal_id = 979, phiCenter = 274.553, phi0Center = -1.37181, phiCenter = 274.553
module_odd: crystal_id = 980, phiCenter = 274.835, phi0Center = -1.37181, phiCenter = 274.835
module_odd: crystal_id = 981, phiCenter = 275.117, phi0Center = -1.37181, phiCenter = 275.117
module_odd: crystal_id = 982, phiCenter = 275.399, phi0Center = -1.37181, phiCenter = 275.399
module_odd: crystal_id = 983, phiCenter = 275.681, phi0Center = -1.37181, phiCenter = 275.681
module_odd: crystal_id = 984, phiCenter = 275.964, phi0Center = -1.37181, phiCenter = 275.964
module_odd: crystal_id = 985, phiCenter = 276.246, phi0Center = -1.37181, phiCenter = 276.246
module_odd: crystal_id = 986, phiCenter = 276.528, phi0Center = -1.37181, phiCenter = 276.528
module_odd: crystal_id = 987, phiCenter = 276.81, phi0Center = -1.37181, phiCenter = 276.81
module_odd: crystal_id = 988, phiCenter = 277.092, phi0Center = -1.37181, phiCenter = 277.092
module_odd: crystal_id = 989, phiCenter = 277.374, phi0Center = -1.37181, phiCenter = 277.374
module_odd: crystal_id = 990, phiCenter = 277.656, phi0Center = -1.37181, phiCenter = 277.656
module_odd: crystal_id = 991, phiCenter = 277.939, phi0Center = -1.37181, phiCenter = 277.939
module_odd: crystal_id = 992, phiCenter = 278.221, phi0Center = -1.37181, phiCenter = 278.221
module_odd: crystal_id = 993, phiCenter = 278.503, phi0Center = -1.37181, phiCenter = 278.503
module_odd: crystal_id = 994, phiCenter = 278.785, phi0Center = -1.37181, phiCenter = 278.785
module_odd: crystal_id = 995, phiCenter = 279.067, phi0Center = -1.37181, phiCenter = 279.067
module_odd: crystal_id = 996, phiCenter = 279.349, phi0Center = -1.37181, phiCenter = 279.349
module_odd: crystal_id = 997, phiCenter = 279.631, phi0Center = -1.37181, phiCenter = 279.631
module_odd: crystal_id = 998, phiCenter = 279.913, phi0Center = -1.37181, phiCenter = 279.913
module_odd: crystal_id = 999, phiCenter = 280.196, phi0Center = -1.37181, phiCenter = 280.196
module_odd: crystal_id = 1000, phiCenter = 280.478, phi0Center = -1.37181, phiCenter = 280.478
module_odd: crystal_id = 1001, phiCenter = 280.76, phi0Center = -1.37181, phiCenter = 280.76
module_odd: crystal_id = 1002, phiCenter = 281.042, phi0Center = -1.37181, phiCenter = 281.042
module_odd: crystal_id = 1003, phiCenter = 281.324, phi0Center = -1.37181, phiCenter = 281.324
module_odd: crystal_id = 1004, phiCenter = 281.606, phi0Center = -1.37181, phiCenter = 281.606
module_odd: crystal_id = 1005, phiCenter = 281.888, phi0Center = -1.37181, phiCenter = 281.888
module_odd: crystal_id = 1006, phiCenter = 282.171, phi0Center = -1.37181, phiCenter = 282.171
module_odd: crystal_id = 1007, phiCenter = 282.453, phi0Center = -1.37181, phiCenter = 282.453
module_odd: crystal_id = 1008, phiCenter = 282.735, phi0Center = -1.37181, phiCenter = 282.735
module_odd: crystal_id = 1009, phiCenter = 283.017, phi0Center = -1.37181, phiCenter = 283.017
module_odd: crystal_id = 1010, phiCenter = 283.299, phi0Center = -1.37181, phiCenter = 283.299
module_odd: crystal_id = 1011, phiCenter = 283.581, phi0Center = -1.37181, phiCenter = 283.581
module_odd: crystal_id = 1012, phiCenter = 283.863, phi0Center = -1.37181, phiCenter = 283.863
module_odd: crystal_id = 1013, phiCenter = 284.145, phi0Center = -1.37181, phiCenter = 284.145
module_odd: crystal_id = 1014, phiCenter = 284.428, phi0Center = -1.37181, phiCenter = 284.428
module_odd: crystal_id = 1015, phiCenter = 284.71, phi0Center = -1.37181, phiCenter = 284.71
module_odd: crystal_id = 1016, phiCenter = 284.992, phi0Center = -1.37181, phiCenter = 284.992
module_odd: crystal_id = 1017, phiCenter = 285.274, phi0Center = -1.37181, phiCenter = 285.274
module_odd: crystal_id = 1018, phiCenter = 285.556, phi0Center = -1.37181, phiCenter = 285.556
module_odd: crystal_id = 1019, phiCenter = 285.838, phi0Center = -1.37181, phiCenter = 285.838
module_odd: crystal_id = 1020, phiCenter = 286.12, phi0Center = -1.37181, phiCenter = 286.12
module_odd: crystal_id = 1021, phiCenter = 286.402, phi0Center = -1.37181, phiCenter = 286.402
module_odd: crystal_id = 1022, phiCenter = 286.685, phi0Center = -1.37181, phiCenter = 286.685
module_odd: crystal_id = 1023, phiCenter = 286.967, phi0Center = -1.37181, phiCenter = 286.967
module_odd: crystal_id = 1024, phiCenter = 287.249, phi0Center = -1.37181, phiCenter = 287.249
module_odd: crystal_id = 1025, phiCenter = 287.531, phi0Center = -1.37181, phiCenter = 287.531
module_odd: crystal_id = 1026, phiCenter = 287.813, phi0Center = -1.37181, phiCenter = 287.813
module_odd: crystal_id = 1027, phiCenter = 288.095, phi0Center = -1.37181, phiCenter = 288.095
module_odd: crystal_id = 1028, phiCenter = 288.377, phi0Center = -1.37181, phiCenter = 288.377
module_odd: crystal_id = 1029, phiCenter = 288.66, phi0Center = -1.37181, phiCenter = 288.66
module_odd: crystal_id = 1030, phiCenter = 288.942, phi0Center = -1.37181, phiCenter = 288.942
module_odd: crystal_id = 1031, phiCenter = 289.224, phi0Center = -1.37181, phiCenter = 289.224
module_odd: crystal_id = 1032, phiCenter = 289.506, phi0Center = -1.37181, phiCenter = 289.506
module_odd: crystal_id = 1033, phiCenter = 289.788, phi0Center = -1.37181, phiCenter = 289.788
module_odd: crystal_id = 1034, phiCenter = 290.07, phi0Center = -1.37181, phiCenter = 290.07
module_odd: crystal_id = 1035, phiCenter = 290.352, phi0Center = -1.37181, phiCenter = 290.352
module_odd: crystal_id = 1036, phiCenter = 290.634, phi0Center = -1.37181, phiCenter = 290.634
module_odd: crystal_id = 1037, phiCenter = 290.917, phi0Center = -1.37181, phiCenter = 290.917
module_odd: crystal_id = 1038, phiCenter = 291.199, phi0Center = -1.37181, phiCenter = 291.199
module_odd: crystal_id = 1039, phiCenter = 291.481, phi0Center = -1.37181, phiCenter = 291.481
module_odd: crystal_id = 1040, phiCenter = 291.763, phi0Center = -1.37181, phiCenter = 291.763
module_odd: crystal_id = 1041, phiCenter = 292.045, phi0Center = -1.37181, phiCenter = 292.045
module_odd: crystal_id = 1042, phiCenter = 292.327, phi0Center = -1.37181, phiCenter = 292.327
module_odd: crystal_id = 1043, phiCenter = 292.609, phi0Center = -1.37181, phiCenter = 292.609
module_odd: crystal_id = 1044, phiCenter = 292.892, phi0Center = -1.37181, phiCenter = 292.892
module_odd: crystal_id = 1045, phiCenter = 293.174, phi0Center = -1.37181, phiCenter = 293.174
module_odd: crystal_id = 1046, phiCenter = 293.456, phi0Center = -1.37181, phiCenter = 293.456
module_odd: crystal_id = 1047, phiCenter = 293.738, phi0Center = -1.37181, phiCenter = 293.738
module_odd: crystal_id = 1048, phiCenter = 294.02, phi0Center = -1.37181, phiCenter = 294.02
module_odd: crystal_id = 1049, phiCenter = 294.302, phi0Center = -1.37181, phiCenter = 294.302
module_odd: crystal_id = 1050, phiCenter = 294.584, phi0Center = -1.37181, phiCenter = 294.584
module_odd: crystal_id = 1051, phiCenter = 294.866, phi0Center = -1.37181, phiCenter = 294.866
module_odd: crystal_id = 1052, phiCenter = 295.149, phi0Center = -1.37181, phiCenter = 295.149
module_odd: crystal_id = 1053, phiCenter = 295.431, phi0Center = -1.37181, phiCenter = 295.431
module_odd: crystal_id = 1054, phiCenter = 295.713, phi0Center = -1.37181, phiCenter = 295.713
module_odd: crystal_id = 1055, phiCenter = 295.995, phi0Center = -1.37181, phiCenter = 295.995
module_odd: crystal_id = 1056, phiCenter = 296.277, phi0Center = -1.37181, phiCenter = 296.277
module_odd: crystal_id = 1057, phiCenter = 296.559, phi0Center = -1.37181, phiCenter = 296.559
module_odd: crystal_id = 1058, phiCenter = 296.841, phi0Center = -1.37181, phiCenter = 296.841
module_odd: crystal_id = 1059, phiCenter = 297.123, phi0Center = -1.37181, phiCenter = 297.123
module_odd: crystal_id = 1060, phiCenter = 297.406, phi0Center = -1.37181, phiCenter = 297.406
module_odd: crystal_id = 1061, phiCenter = 297.688, phi0Center = -1.37181, phiCenter = 297.688
module_odd: crystal_id = 1062, phiCenter = 297.97, phi0Center = -1.37181, phiCenter = 297.97
module_odd: crystal_id = 1063, phiCenter = 298.252, phi0Center = -1.37181, phiCenter = 298.252
module_odd: crystal_id = 1064, phiCenter = 298.534, phi0Center = -1.37181, phiCenter = 298.534
module_odd: crystal_id = 1065, phiCenter = 298.816, phi0Center = -1.37181, phiCenter = 298.816
module_odd: crystal_id = 1066, phiCenter = 299.098, phi0Center = -1.37181, phiCenter = 299.098
module_odd: crystal_id = 1067, phiCenter = 299.381, phi0Center = -1.37181, phiCenter = 299.381
module_odd: crystal_id = 1068, phiCenter = 299.663, phi0Center = -1.37181, phiCenter = 299.663
module_odd: crystal_id = 1069, phiCenter = 299.945, phi0Center = -1.37181, phiCenter = 299.945
module_odd: crystal_id = 1070, phiCenter = 300.227, phi0Center = -1.37181, phiCenter = 300.227
module_odd: crystal_id = 1071, phiCenter = 300.509, phi0Center = -1.37181, phiCenter = 300.509
module_odd: crystal_id = 1072, phiCenter = 300.791, phi0Center = -1.37181, phiCenter = 300.791
module_odd: crystal_id = 1073, phiCenter = 301.073, phi0Center = -1.37181, phiCenter = 301.073
module_odd: crystal_id = 1074, phiCenter = 301.355, phi0Center = -1.37181, phiCenter = 301.355
module_odd: crystal_id = 1075, phiCenter = 301.638, phi0Center = -1.37181, phiCenter = 301.638
module_odd: crystal_id = 1076, phiCenter = 301.92, phi0Center = -1.37181, phiCenter = 301.92
module_odd: crystal_id = 1077, phiCenter = 302.202, phi0Center = -1.37181, phiCenter = 302.202
module_odd: crystal_id = 1078, phiCenter = 302.484, phi0Center = -1.37181, phiCenter = 302.484
module_odd: crystal_id = 1079, phiCenter = 302.766, phi0Center = -1.37181, phiCenter = 302.766
module_odd: crystal_id = 1080, phiCenter = 303.048, phi0Center = -1.37181, phiCenter = 303.048
module_odd: crystal_id = 1081, phiCenter = 303.33, phi0Center = -1.37181, phiCenter = 303.33
module_odd: crystal_id = 1082, phiCenter = 303.613, phi0Center = -1.37181, phiCenter = 303.613
module_odd: crystal_id = 1083, phiCenter = 303.895, phi0Center = -1.37181, phiCenter = 303.895
module_odd: crystal_id = 1084, phiCenter = 304.177, phi0Center = -1.37181, phiCenter = 304.177
module_odd: crystal_id = 1085, phiCenter = 304.459, phi0Center = -1.37181, phiCenter = 304.459
module_odd: crystal_id = 1086, phiCenter = 304.741, phi0Center = -1.37181, phiCenter = 304.741
module_odd: crystal_id = 1087, phiCenter = 305.023, phi0Center = -1.37181, phiCenter = 305.023
module_odd: crystal_id = 1088, phiCenter = 305.305, phi0Center = -1.37181, phiCenter = 305.305
module_odd: crystal_id = 1089, phiCenter = 305.587, phi0Center = -1.37181, phiCenter = 305.587
module_odd: crystal_id = 1090, phiCenter = 305.87, phi0Center = -1.37181, phiCenter = 305.87
module_odd: crystal_id = 1091, phiCenter = 306.152, phi0Center = -1.37181, phiCenter = 306.152
module_odd: crystal_id = 1092, phiCenter = 306.434, phi0Center = -1.37181, phiCenter = 306.434
module_odd: crystal_id = 1093, phiCenter = 306.716, phi0Center = -1.37181, phiCenter = 306.716
module_odd: crystal_id = 1094, phiCenter = 306.998, phi0Center = -1.37181, phiCenter = 306.998
module_odd: crystal_id = 1095, phiCenter = 307.28, phi0Center = -1.37181, phiCenter = 307.28
module_odd: crystal_id = 1096, phiCenter = 307.562, phi0Center = -1.37181, phiCenter = 307.562
module_odd: crystal_id = 1097, phiCenter = 307.844, phi0Center = -1.37181, phiCenter = 307.844
module_odd: crystal_id = 1098, phiCenter = 308.127, phi0Center = -1.37181, phiCenter = 308.127
module_odd: crystal_id = 1099, phiCenter = 308.409, phi0Center = -1.37181, phiCenter = 308.409
module_odd: crystal_id = 1100, phiCenter = 308.691, phi0Center = -1.37181, phiCenter = 308.691
module_odd: crystal_id = 1101, phiCenter = 308.973, phi0Center = -1.37181, phiCenter = 308.973
module_odd: crystal_id = 1102, phiCenter = 309.255, phi0Center = -1.37181, phiCenter = 309.255
module_odd: crystal_id = 1103, phiCenter = 309.537, phi0Center = -1.37181, phiCenter = 309.537
module_odd: crystal_id = 1104, phiCenter = 309.819, phi0Center = -1.37181, phiCenter = 309.819
module_odd: crystal_id = 1105, phiCenter = 310.102, phi0Center = -1.37181, phiCenter = 310.102
module_odd: crystal_id = 1106, phiCenter = 310.384, phi0Center = -1.37181, phiCenter = 310.384
module_odd: crystal_id = 1107, phiCenter = 310.666, phi0Center = -1.37181, phiCenter = 310.666
module_odd: crystal_id = 1108, phiCenter = 310.948, phi0Center = -1.37181, phiCenter = 310.948
module_odd: crystal_id = 1109, phiCenter = 311.23, phi0Center = -1.37181, phiCenter = 311.23
module_odd: crystal_id = 1110, phiCenter = 311.512, phi0Center = -1.37181, phiCenter = 311.512
module_odd: crystal_id = 1111, phiCenter = 311.794, phi0Center = -1.37181, phiCenter = 311.794
module_odd: crystal_id = 1112, phiCenter = 312.076, phi0Center = -1.37181, phiCenter = 312.076
module_odd: crystal_id = 1113, phiCenter = 312.359, phi0Center = -1.37181, phiCenter = 312.359
module_odd: crystal_id = 1114, phiCenter = 312.641, phi0Center = -1.37181, phiCenter = 312.641
module_odd: crystal_id = 1115, phiCenter = 312.923, phi0Center = -1.37181, phiCenter = 312.923
module_odd: crystal_id = 1116, phiCenter = 313.205, phi0Center = -1.37181, phiCenter = 313.205
module_odd: crystal_id = 1117, phiCenter = 313.487, phi0Center = -1.37181, phiCenter = 313.487
module_odd: crystal_id = 1118, phiCenter = 313.769, phi0Center = -1.37181, phiCenter = 313.769
module_odd: crystal_id = 1119, phiCenter = 314.051, phi0Center = -1.37181, phiCenter = 314.051
module_odd: crystal_id = 1120, phiCenter = 314.334, phi0Center = -1.37181, phiCenter = 314.334
module_odd: crystal_id = 1121, phiCenter = 314.616, phi0Center = -1.37181, phiCenter = 314.616
module_odd: crystal_id = 1122, phiCenter = 314.898, phi0Center = -1.37181, phiCenter = 314.898
module_odd: crystal_id = 1123, phiCenter = 315.18, phi0Center = -1.37181, phiCenter = 315.18
module_odd: crystal_id = 1124, phiCenter = 315.462, phi0Center = -1.37181, phiCenter = 315.462
module_odd: crystal_id = 1125, phiCenter = 315.744, phi0Center = -1.37181, phiCenter = 315.744
module_odd: crystal_id = 1126, phiCenter = 316.026, phi0Center = -1.37181, phiCenter = 316.026
module_odd: crystal_id = 1127, phiCenter = 316.308, phi0Center = -1.37181, phiCenter = 316.308
module_odd: crystal_id = 1128, phiCenter = 316.591, phi0Center = -1.37181, phiCenter = 316.591
module_odd: crystal_id = 1129, phiCenter = 316.873, phi0Center = -1.37181, phiCenter = 316.873
module_odd: crystal_id = 1130, phiCenter = 317.155, phi0Center = -1.37181, phiCenter = 317.155
module_odd: crystal_id = 1131, phiCenter = 317.437, phi0Center = -1.37181, phiCenter = 317.437
module_odd: crystal_id = 1132, phiCenter = 317.719, phi0Center = -1.37181, phiCenter = 317.719
module_odd: crystal_id = 1133, phiCenter = 318.001, phi0Center = -1.37181, phiCenter = 318.001
module_odd: crystal_id = 1134, phiCenter = 318.283, phi0Center = -1.37181, phiCenter = 318.283
module_odd: crystal_id = 1135, phiCenter = 318.565, phi0Center = -1.37181, phiCenter = 318.565
module_odd: crystal_id = 1136, phiCenter = 318.848, phi0Center = -1.37181, phiCenter = 318.848
module_odd: crystal_id = 1137, phiCenter = 319.13, phi0Center = -1.37181, phiCenter = 319.13
module_odd: crystal_id = 1138, phiCenter = 319.412, phi0Center = -1.37181, phiCenter = 319.412
module_odd: crystal_id = 1139, phiCenter = 319.694, phi0Center = -1.37181, phiCenter = 319.694
module_odd: crystal_id = 1140, phiCenter = 319.976, phi0Center = -1.37181, phiCenter = 319.976
module_odd: crystal_id = 1141, phiCenter = 320.258, phi0Center = -1.37181, phiCenter = 320.258
module_odd: crystal_id = 1142, phiCenter = 320.54, phi0Center = -1.37181, phiCenter = 320.54
module_odd: crystal_id = 1143, phiCenter = 320.823, phi0Center = -1.37181, phiCenter = 320.823
module_odd: crystal_id = 1144, phiCenter = 321.105, phi0Center = -1.37181, phiCenter = 321.105
module_odd: crystal_id = 1145, phiCenter = 321.387, phi0Center = -1.37181, phiCenter = 321.387
module_odd: crystal_id = 1146, phiCenter = 321.669, phi0Center = -1.37181, phiCenter = 321.669
module_odd: crystal_id = 1147, phiCenter = 321.951, phi0Center = -1.37181, phiCenter = 321.951
module_odd: crystal_id = 1148, phiCenter = 322.233, phi0Center = -1.37181, phiCenter = 322.233
module_odd: crystal_id = 1149, phiCenter = 322.515, phi0Center = -1.37181, phiCenter = 322.515
module_odd: crystal_id = 1150, phiCenter = 322.797, phi0Center = -1.37181, phiCenter = 322.797
module_odd: crystal_id = 1151, phiCenter = 323.08, phi0Center = -1.37181, phiCenter = 323.08
module_odd: crystal_id = 1152, phiCenter = 323.362, phi0Center = -1.37181, phiCenter = 323.362
module_odd: crystal_id = 1153, phiCenter = 323.644, phi0Center = -1.37181, phiCenter = 323.644
module_odd: crystal_id = 1154, phiCenter = 323.926, phi0Center = -1.37181, phiCenter = 323.926
module_odd: crystal_id = 1155, phiCenter = 324.208, phi0Center = -1.37181, phiCenter = 324.208
module_odd: crystal_id = 1156, phiCenter = 324.49, phi0Center = -1.37181, phiCenter = 324.49
module_odd: crystal_id = 1157, phiCenter = 324.772, phi0Center = -1.37181, phiCenter = 324.772
module_odd: crystal_id = 1158, phiCenter = 325.055, phi0Center = -1.37181, phiCenter = 325.055
module_odd: crystal_id = 1159, phiCenter = 325.337, phi0Center = -1.37181, phiCenter = 325.337
module_odd: crystal_id = 1160, phiCenter = 325.619, phi0Center = -1.37181, phiCenter = 325.619
module_odd: crystal_id = 1161, phiCenter = 325.901, phi0Center = -1.37181, phiCenter = 325.901
module_odd: crystal_id = 1162, phiCenter = 326.183, phi0Center = -1.37181, phiCenter = 326.183
module_odd: crystal_id = 1163, phiCenter = 326.465, phi0Center = -1.37181, phiCenter = 326.465
module_odd: crystal_id = 1164, phiCenter = 326.747, phi0Center = -1.37181, phiCenter = 326.747
module_odd: crystal_id = 1165, phiCenter = 327.029, phi0Center = -1.37181, phiCenter = 327.029
module_odd: crystal_id = 1166, phiCenter = 327.312, phi0Center = -1.37181, phiCenter = 327.312
module_odd: crystal_id = 1167, phiCenter = 327.594, phi0Center = -1.37181, phiCenter = 327.594
module_odd: crystal_id = 1168, phiCenter = 327.876, phi0Center = -1.37181, phiCenter = 327.876
module_odd: crystal_id = 1169, phiCenter = 328.158, phi0Center = -1.37181, phiCenter = 328.158
module_odd: crystal_id = 1170, phiCenter = 328.44, phi0Center = -1.37181, phiCenter = 328.44
module_odd: crystal_id = 1171, phiCenter = 328.722, phi0Center = -1.37181, phiCenter = 328.722
module_odd: crystal_id = 1172, phiCenter = 329.004, phi0Center = -1.37181, phiCenter = 329.004
module_odd: crystal_id = 1173, phiCenter = 329.286, phi0Center = -1.37181, phiCenter = 329.286
module_odd: crystal_id = 1174, phiCenter = 329.569, phi0Center = -1.37181, phiCenter = 329.569
module_odd: crystal_id = 1175, phiCenter = 329.851, phi0Center = -1.37181, phiCenter = 329.851
module_odd: crystal_id = 1176, phiCenter = 330.133, phi0Center = -1.37181, phiCenter = 330.133
module_odd: crystal_id = 1177, phiCenter = 330.415, phi0Center = -1.37181, phiCenter = 330.415
module_odd: crystal_id = 1178, phiCenter = 330.697, phi0Center = -1.37181, phiCenter = 330.697
module_odd: crystal_id = 1179, phiCenter = 330.979, phi0Center = -1.37181, phiCenter = 330.979
module_odd: crystal_id = 1180, phiCenter = 331.261, phi0Center = -1.37181, phiCenter = 331.261
module_odd: crystal_id = 1181, phiCenter = 331.544, phi0Center = -1.37181, phiCenter = 331.544
module_odd: crystal_id = 1182, phiCenter = 331.826, phi0Center = -1.37181, phiCenter = 331.826
module_odd: crystal_id = 1183, phiCenter = 332.108, phi0Center = -1.37181, phiCenter = 332.108
module_odd: crystal_id = 1184, phiCenter = 332.39, phi0Center = -1.37181, phiCenter = 332.39
module_odd: crystal_id = 1185, phiCenter = 332.672, phi0Center = -1.37181, phiCenter = 332.672
module_odd: crystal_id = 1186, phiCenter = 332.954, phi0Center = -1.37181, phiCenter = 332.954
module_odd: crystal_id = 1187, phiCenter = 333.236, phi0Center = -1.37181, phiCenter = 333.236
module_odd: crystal_id = 1188, phiCenter = 333.518, phi0Center = -1.37181, phiCenter = 333.518
module_odd: crystal_id = 1189, phiCenter = 333.801, phi0Center = -1.37181, phiCenter = 333.801
module_odd: crystal_id = 1190, phiCenter = 334.083, phi0Center = -1.37181, phiCenter = 334.083
module_odd: crystal_id = 1191, phiCenter = 334.365, phi0Center = -1.37181, phiCenter = 334.365
module_odd: crystal_id = 1192, phiCenter = 334.647, phi0Center = -1.37181, phiCenter = 334.647
module_odd: crystal_id = 1193, phiCenter = 334.929, phi0Center = -1.37181, phiCenter = 334.929
module_odd: crystal_id = 1194, phiCenter = 335.211, phi0Center = -1.37181, phiCenter = 335.211
module_odd: crystal_id = 1195, phiCenter = 335.493, phi0Center = -1.37181, phiCenter = 335.493
module_odd: crystal_id = 1196, phiCenter = 335.776, phi0Center = -1.37181, phiCenter = 335.776
module_odd: crystal_id = 1197, phiCenter = 336.058, phi0Center = -1.37181, phiCenter = 336.058
module_odd: crystal_id = 1198, phiCenter = 336.34, phi0Center = -1.37181, phiCenter = 336.34
module_odd: crystal_id = 1199, phiCenter = 336.622, phi0Center = -1.37181, phiCenter = 336.622
module_odd: crystal_id = 1200, phiCenter = 336.904, phi0Center = -1.37181, phiCenter = 336.904
module_odd: crystal_id = 1201, phiCenter = 337.186, phi0Center = -1.37181, phiCenter = 337.186
module_odd: crystal_id = 1202, phiCenter = 337.468, phi0Center = -1.37181, phiCenter = 337.468
module_odd: crystal_id = 1203, phiCenter = 337.75, phi0Center = -1.37181, phiCenter = 337.75
module_odd: crystal_id = 1204, phiCenter = 338.033, phi0Center = -1.37181, phiCenter = 338.033
module_odd: crystal_id = 1205, phiCenter = 338.315, phi0Center = -1.37181, phiCenter = 338.315
module_odd: crystal_id = 1206, phiCenter = 338.597, phi0Center = -1.37181, phiCenter = 338.597
module_odd: crystal_id = 1207, phiCenter = 338.879, phi0Center = -1.37181, phiCenter = 338.879
module_odd: crystal_id = 1208, phiCenter = 339.161, phi0Center = -1.37181, phiCenter = 339.161
module_odd: crystal_id = 1209, phiCenter = 339.443, phi0Center = -1.37181, phiCenter = 339.443
module_odd: crystal_id = 1210, phiCenter = 339.725, phi0Center = -1.37181, phiCenter = 339.725
module_odd: crystal_id = 1211, phiCenter = 340.007, phi0Center = -1.37181, phiCenter = 340.007
module_odd: crystal_id = 1212, phiCenter = 340.29, phi0Center = -1.37181, phiCenter = 340.29
module_odd: crystal_id = 1213, phiCenter = 340.572, phi0Center = -1.37181, phiCenter = 340.572
module_odd: crystal_id = 1214, phiCenter = 340.854, phi0Center = -1.37181, phiCenter = 340.854
module_odd: crystal_id = 1215, phiCenter = 341.136, phi0Center = -1.37181, phiCenter = 341.136
module_odd: crystal_id = 1216, phiCenter = 341.418, phi0Center = -1.37181, phiCenter = 341.418
module_odd: crystal_id = 1217, phiCenter = 341.7, phi0Center = -1.37181, phiCenter = 341.7
module_odd: crystal_id = 1218, phiCenter = 341.982, phi0Center = -1.37181, phiCenter = 341.982
module_odd: crystal_id = 1219, phiCenter = 342.265, phi0Center = -1.37181, phiCenter = 342.265
module_odd: crystal_id = 1220, phiCenter = 342.547, phi0Center = -1.37181, phiCenter = 342.547
module_odd: crystal_id = 1221, phiCenter = 342.829, phi0Center = -1.37181, phiCenter = 342.829
module_odd: crystal_id = 1222, phiCenter = 343.111, phi0Center = -1.37181, phiCenter = 343.111
module_odd: crystal_id = 1223, phiCenter = 343.393, phi0Center = -1.37181, phiCenter = 343.393
module_odd: crystal_id = 1224, phiCenter = 343.675, phi0Center = -1.37181, phiCenter = 343.675
module_odd: crystal_id = 1225, phiCenter = 343.957, phi0Center = -1.37181, phiCenter = 343.957
module_odd: crystal_id = 1226, phiCenter = 344.239, phi0Center = -1.37181, phiCenter = 344.239
module_odd: crystal_id = 1227, phiCenter = 344.522, phi0Center = -1.37181, phiCenter = 344.522
module_odd: crystal_id = 1228, phiCenter = 344.804, phi0Center = -1.37181, phiCenter = 344.804
module_odd: crystal_id = 1229, phiCenter = 345.086, phi0Center = -1.37181, phiCenter = 345.086
module_odd: crystal_id = 1230, phiCenter = 345.368, phi0Center = -1.37181, phiCenter = 345.368
module_odd: crystal_id = 1231, phiCenter = 345.65, phi0Center = -1.37181, phiCenter = 345.65
module_odd: crystal_id = 1232, phiCenter = 345.932, phi0Center = -1.37181, phiCenter = 345.932
module_odd: crystal_id = 1233, phiCenter = 346.214, phi0Center = -1.37181, phiCenter = 346.214
module_odd: crystal_id = 1234, phiCenter = 346.497, phi0Center = -1.37181, phiCenter = 346.497
module_odd: crystal_id = 1235, phiCenter = 346.779, phi0Center = -1.37181, phiCenter = 346.779
module_odd: crystal_id = 1236, phiCenter = 347.061, phi0Center = -1.37181, phiCenter = 347.061
module_odd: crystal_id = 1237, phiCenter = 347.343, phi0Center = -1.37181, phiCenter = 347.343
module_odd: crystal_id = 1238, phiCenter = 347.625, phi0Center = -1.37181, phiCenter = 347.625
module_odd: crystal_id = 1239, phiCenter = 347.907, phi0Center = -1.37181, phiCenter = 347.907
module_odd: crystal_id = 1240, phiCenter = 348.189, phi0Center = -1.37181, phiCenter = 348.189
module_odd: crystal_id = 1241, phiCenter = 348.471, phi0Center = -1.37181, phiCenter = 348.471
module_odd: crystal_id = 1242, phiCenter = 348.754, phi0Center = -1.37181, phiCenter = 348.754
module_odd: crystal_id = 1243, phiCenter = 349.036, phi0Center = -1.37181, phiCenter = 349.036
module_odd: crystal_id = 1244, phiCenter = 349.318, phi0Center = -1.37181, phiCenter = 349.318
module_odd: crystal_id = 1245, phiCenter = 349.6, phi0Center = -1.37181, phiCenter = 349.6
module_odd: crystal_id = 1246, phiCenter = 349.882, phi0Center = -1.37181, phiCenter = 349.882
module_odd: crystal_id = 1247, phiCenter = 350.164, phi0Center = -1.37181, phiCenter = 350.164
module_odd: crystal_id = 1248, phiCenter = 350.446, phi0Center = -1.37181, phiCenter = 350.446
module_odd: crystal_id = 1249, phiCenter = 350.729, phi0Center = -1.37181, phiCenter = 350.729
module_odd: crystal_id = 1250, phiCenter = 351.011, phi0Center = -1.37181, phiCenter = 351.011
module_odd: crystal_id = 1251, phiCenter = 351.293, phi0Center = -1.37181, phiCenter = 351.293
module_odd: crystal_id = 1252, phiCenter = 351.575, phi0Center = -1.37181, phiCenter = 351.575
module_odd: crystal_id = 1253, phiCenter = 351.857, phi0Center = -1.37181, phiCenter = 351.857
module_odd: crystal_id = 1254, phiCenter = 352.139, phi0Center = -1.37181, phiCenter = 352.139
module_odd: crystal_id = 1255, phiCenter = 352.421, phi0Center = -1.37181, phiCenter = 352.421
module_odd: crystal_id = 1256, phiCenter = 352.703, phi0Center = -1.37181, phiCenter = 352.703
module_odd: crystal_id = 1257, phiCenter = 352.986, phi0Center = -1.37181, phiCenter = 352.986
module_odd: crystal_id = 1258, phiCenter = 353.268, phi0Center = -1.37181, phiCenter = 353.268
module_odd: crystal_id = 1259, phiCenter = 353.55, phi0Center = -1.37181, phiCenter = 353.55
module_odd: crystal_id = 1260, phiCenter = 353.832, phi0Center = -1.37181, phiCenter = 353.832
module_odd: crystal_id = 1261, phiCenter = 354.114, phi0Center = -1.37181, phiCenter = 354.114
module_odd: crystal_id = 1262, phiCenter = 354.396, phi0Center = -1.37181, phiCenter = 354.396
module_odd: crystal_id = 1263, phiCenter = 354.678, phi0Center = -1.37181, phiCenter = 354.678
module_odd: crystal_id = 1264, phiCenter = 354.96, phi0Center = -1.37181, phiCenter = 354.96
module_odd: crystal_id = 1265, phiCenter = 355.243, phi0Center = -1.37181, phiCenter = 355.243
module_odd: crystal_id = 1266, phiCenter = 355.525, phi0Center = -1.37181, phiCenter = 355.525
module_odd: crystal_id = 1267, phiCenter = 355.807, phi0Center = -1.37181, phiCenter = 355.807
module_odd: crystal_id = 1268, phiCenter = 356.089, phi0Center = -1.37181, phiCenter = 356.089
module_odd: crystal_id = 1269, phiCenter = 356.371, phi0Center = -1.37181, phiCenter = 356.371
module_odd: crystal_id = 1270, phiCenter = 356.653, phi0Center = -1.37181, phiCenter = 356.653
module_odd: crystal_id = 1271, phiCenter = 356.935, phi0Center = -1.37181, phiCenter = 356.935
module_odd: crystal_id = 1272, phiCenter = 357.218, phi0Center = -1.37181, phiCenter = 357.218
module_odd: crystal_id = 1273, phiCenter = 357.5, phi0Center = -1.37181, phiCenter = 357.5
module_odd: crystal_id = 1274, phiCenter = 357.782, phi0Center = -1.37181, phiCenter = 357.782
module_odd: crystal_id = 1275, phiCenter = 358.064, phi0Center = -1.37181, phiCenter = 358.064
module_odd: crystal_id = 1276, phiCenter = 358.346, phi0Center = -1.37181, phiCenter = 358.346
module_even: crystal_id = 1, phiCenter = -1.37181
module_even: crystal_id = 2, phiCenter = -1.08968
module_even: crystal_id = 3, phiCenter = -0.80755
module_even: crystal_id = 4, phiCenter = -0.525418
module_even: crystal_id = 5, phiCenter = -0.243287
module_even: crystal_id = 6, phiCenter = 0.0388449
module_even: crystal_id = 7, phiCenter = 0.320977
module_even: crystal_id = 8, phiCenter = 0.603108
module_even: crystal_id = 9, phiCenter = 0.88524
module_even: crystal_id = 10, phiCenter = 1.16737
module_even: crystal_id = 11, phiCenter = 1.4495
module_even: crystal_id = 12, phiCenter = 1.73163
module_even: crystal_id = 13, phiCenter = 2.01377
module_even: crystal_id = 14, phiCenter = 2.2959
module_even: crystal_id = 15, phiCenter = 2.57803
module_even: crystal_id = 16, phiCenter = 2.86016
module_even: crystal_id = 17, phiCenter = 3.14229
module_even: crystal_id = 18, phiCenter = 3.42442
module_even: crystal_id = 19, phiCenter = 3.70656
module_even: crystal_id = 20, phiCenter = 3.98869
module_even: crystal_id = 21, phiCenter = 4.27082
module_even: crystal_id = 22, phiCenter = 4.55295
module_even: crystal_id = 23, phiCenter = 4.83508
module_even: crystal_id = 24, phiCenter = 5.11721
module_even: crystal_id = 25, phiCenter = 5.39935
module_even: crystal_id = 26, phiCenter = 5.68148
module_even: crystal_id = 27, phiCenter = 5.96361
module_even: crystal_id = 28, phiCenter = 6.24574
module_even: crystal_id = 29, phiCenter = 6.52787
module_even: crystal_id = 30, phiCenter = 6.81
module_even: crystal_id = 31, phiCenter = 7.09214
module_even: crystal_id = 32, phiCenter = 7.37427
module_even: crystal_id = 33, phiCenter = 7.6564
module_even: crystal_id = 34, phiCenter = 7.93853
module_even: crystal_id = 35, phiCenter = 8.22066
module_even: crystal_id = 36, phiCenter = 8.50279
module_even: crystal_id = 37, phiCenter = 8.78493
module_even: crystal_id = 38, phiCenter = 9.06706
module_even: crystal_id = 39, phiCenter = 9.34919
module_even: crystal_id = 40, phiCenter = 9.63132
module_even: crystal_id = 41, phiCenter = 9.91345
module_even: crystal_id = 42, phiCenter = 10.1956
module_even: crystal_id = 43, phiCenter = 10.4777
module_even: crystal_id = 44, phiCenter = 10.7598
module_even: crystal_id = 45, phiCenter = 11.042
module_even: crystal_id = 46, phiCenter = 11.3241
module_even: crystal_id = 47, phiCenter = 11.6062
module_even: crystal_id = 48, phiCenter = 11.8884
module_even: crystal_id = 49, phiCenter = 12.1705
module_even: crystal_id = 50, phiCenter = 12.4526
module_even: crystal_id = 51, phiCenter = 12.7348
module_even: crystal_id = 52, phiCenter = 13.0169
module_even: crystal_id = 53, phiCenter = 13.299
module_even: crystal_id = 54, phiCenter = 13.5812
module_even: crystal_id = 55, phiCenter = 13.8633
module_even: crystal_id = 56, phiCenter = 14.1454
module_even: crystal_id = 57, phiCenter = 14.4276
module_even: crystal_id = 58, phiCenter = 14.7097
module_even: crystal_id = 59, phiCenter = 14.9918
module_even: crystal_id = 60, phiCenter = 15.274
module_even: crystal_id = 61, phiCenter = 15.5561
module_even: crystal_id = 62, phiCenter = 15.8382
module_even: crystal_id = 63, phiCenter = 16.1203
module_even: crystal_id = 64, phiCenter = 16.4025
module_even: crystal_id = 65, phiCenter = 16.6846
module_even: crystal_id = 66, phiCenter = 16.9667
module_even: crystal_id = 67, phiCenter = 17.2489
module_even: crystal_id = 68, phiCenter = 17.531
module_even: crystal_id = 69, phiCenter = 17.8131
module_even: crystal_id = 70, phiCenter = 18.0953
module_even: crystal_id = 71, phiCenter = 18.3774
module_even: crystal_id = 72, phiCenter = 18.6595
module_even: crystal_id = 73, phiCenter = 18.9417
module_even: crystal_id = 74, phiCenter = 19.2238
module_even: crystal_id = 75, phiCenter = 19.5059
module_even: crystal_id = 76, phiCenter = 19.7881
module_even: crystal_id = 77, phiCenter = 20.0702
module_even: crystal_id = 78, phiCenter = 20.3523
module_even: crystal_id = 79, phiCenter = 20.6345
module_even: crystal_id = 80, phiCenter = 20.9166
module_even: crystal_id = 81, phiCenter = 21.1987
module_even: crystal_id = 82, phiCenter = 21.4809
module_even: crystal_id = 83, phiCenter = 21.763
module_even: crystal_id = 84, phiCenter = 22.0451
module_even: crystal_id = 85, phiCenter = 22.3272
module_even: crystal_id = 86, phiCenter = 22.6094
module_even: crystal_id = 87, phiCenter = 22.8915
module_even: crystal_id = 88, phiCenter = 23.1736
module_even: crystal_id = 89, phiCenter = 23.4558
module_even: crystal_id = 90, phiCenter = 23.7379
module_even: crystal_id = 91, phiCenter = 24.02
module_even: crystal_id = 92, phiCenter = 24.3022
module_even: crystal_id = 93, phiCenter = 24.5843
module_even: crystal_id = 94, phiCenter = 24.8664
module_even: crystal_id = 95, phiCenter = 25.1486
module_even: crystal_id = 96, phiCenter = 25.4307
module_even: crystal_id = 97, phiCenter = 25.7128
module_even: crystal_id = 98, phiCenter = 25.995
module_even: crystal_id = 99, phiCenter = 26.2771
module_even: crystal_id = 100, phiCenter = 26.5592
module_even: crystal_id = 101, phiCenter = 26.8414
module_even: crystal_id = 102, phiCenter = 27.1235
module_even: crystal_id = 103, phiCenter = 27.4056
module_even: crystal_id = 104, phiCenter = 27.6877
module_even: crystal_id = 105, phiCenter = 27.9699
module_even: crystal_id = 106, phiCenter = 28.252
module_even: crystal_id = 107, phiCenter = 28.5341
module_even: crystal_id = 108, phiCenter = 28.8163
module_even: crystal_id = 109, phiCenter = 29.0984
module_even: crystal_id = 110, phiCenter = 29.3805
module_even: crystal_id = 111, phiCenter = 29.6627
module_even: crystal_id = 112, phiCenter = 29.9448
module_even: crystal_id = 113, phiCenter = 30.2269
module_even: crystal_id = 114, phiCenter = 30.5091
module_even: crystal_id = 115, phiCenter = 30.7912
module_even: crystal_id = 116, phiCenter = 31.0733
module_even: crystal_id = 117, phiCenter = 31.3555
module_even: crystal_id = 118, phiCenter = 31.6376
module_even: crystal_id = 119, phiCenter = 31.9197
module_even: crystal_id = 120, phiCenter = 32.2019
module_even: crystal_id = 121, phiCenter = 32.484
module_even: crystal_id = 122, phiCenter = 32.7661
module_even: crystal_id = 123, phiCenter = 33.0482
module_even: crystal_id = 124, phiCenter = 33.3304
module_even: crystal_id = 125, phiCenter = 33.6125
module_even: crystal_id = 126, phiCenter = 33.8946
module_even: crystal_id = 127, phiCenter = 34.1768
module_even: crystal_id = 128, phiCenter = 34.4589
module_even: crystal_id = 129, phiCenter = 34.741
module_even: crystal_id = 130, phiCenter = 35.0232
module_even: crystal_id = 131, phiCenter = 35.3053
module_even: crystal_id = 132, phiCenter = 35.5874
module_even: crystal_id = 133, phiCenter = 35.8696
module_even: crystal_id = 134, phiCenter = 36.1517
module_even: crystal_id = 135, phiCenter = 36.4338
module_even: crystal_id = 136, phiCenter = 36.716
module_even: crystal_id = 137, phiCenter = 36.9981
module_even: crystal_id = 138, phiCenter = 37.2802
module_even: crystal_id = 139, phiCenter = 37.5624
module_even: crystal_id = 140, phiCenter = 37.8445
module_even: crystal_id = 141, phiCenter = 38.1266
module_even: crystal_id = 142, phiCenter = 38.4088
module_even: crystal_id = 143, phiCenter = 38.6909
module_even: crystal_id = 144, phiCenter = 38.973
module_even: crystal_id = 145, phiCenter = 39.2551
module_even: crystal_id = 146, phiCenter = 39.5373
module_even: crystal_id = 147, phiCenter = 39.8194
module_even: crystal_id = 148, phiCenter = 40.1015
module_even: crystal_id = 149, phiCenter = 40.3837
module_even: crystal_id = 150, phiCenter = 40.6658
module_even: crystal_id = 151, phiCenter = 40.9479
module_even: crystal_id = 152, phiCenter = 41.2301
module_even: crystal_id = 153, phiCenter = 41.5122
module_even: crystal_id = 154, phiCenter = 41.7943
module_even: crystal_id = 155, phiCenter = 42.0765
module_even: crystal_id = 156, phiCenter = 42.3586
module_even: crystal_id = 157, phiCenter = 42.6407
module_even: crystal_id = 158, phiCenter = 42.9229
module_even: crystal_id = 159, phiCenter = 43.205
module_even: crystal_id = 160, phiCenter = 43.4871
module_even: crystal_id = 161, phiCenter = 43.7693
module_even: crystal_id = 162, phiCenter = 44.0514
module_even: crystal_id = 163, phiCenter = 44.3335
module_even: crystal_id = 164, phiCenter = 44.6156
module_even: crystal_id = 165, phiCenter = 44.8978
module_even: crystal_id = 166, phiCenter = 45.1799
module_even: crystal_id = 167, phiCenter = 45.462
module_even: crystal_id = 168, phiCenter = 45.7442
module_even: crystal_id = 169, phiCenter = 46.0263
module_even: crystal_id = 170, phiCenter = 46.3084
module_even: crystal_id = 171, phiCenter = 46.5906
module_even: crystal_id = 172, phiCenter = 46.8727
module_even: crystal_id = 173, phiCenter = 47.1548
module_even: crystal_id = 174, phiCenter = 47.437
module_even: crystal_id = 175, phiCenter = 47.7191
module_even: crystal_id = 176, phiCenter = 48.0012
module_even: crystal_id = 177, phiCenter = 48.2834
module_even: crystal_id = 178, phiCenter = 48.5655
module_even: crystal_id = 179, phiCenter = 48.8476
module_even: crystal_id = 180, phiCenter = 49.1298
module_even: crystal_id = 181, phiCenter = 49.4119
module_even: crystal_id = 182, phiCenter = 49.694
module_even: crystal_id = 183, phiCenter = 49.9761
module_even: crystal_id = 184, phiCenter = 50.2583
module_even: crystal_id = 185, phiCenter = 50.5404
module_even: crystal_id = 186, phiCenter = 50.8225
module_even: crystal_id = 187, phiCenter = 51.1047
module_even: crystal_id = 188, phiCenter = 51.3868
module_even: crystal_id = 189, phiCenter = 51.6689
module_even: crystal_id = 190, phiCenter = 51.9511
module_even: crystal_id = 191, phiCenter = 52.2332
module_even: crystal_id = 192, phiCenter = 52.5153
module_even: crystal_id = 193, phiCenter = 52.7975
module_even: crystal_id = 194, phiCenter = 53.0796
module_even: crystal_id = 195, phiCenter = 53.3617
module_even: crystal_id = 196, phiCenter = 53.6439
module_even: crystal_id = 197, phiCenter = 53.926
module_even: crystal_id = 198, phiCenter = 54.2081
module_even: crystal_id = 199, phiCenter = 54.4903
module_even: crystal_id = 200, phiCenter = 54.7724
module_even: crystal_id = 201, phiCenter = 55.0545
module_even: crystal_id = 202, phiCenter = 55.3367
module_even: crystal_id = 203, phiCenter = 55.6188
module_even: crystal_id = 204, phiCenter = 55.9009
module_even: crystal_id = 205, phiCenter = 56.183
module_even: crystal_id = 206, phiCenter = 56.4652
module_even: crystal_id = 207, phiCenter = 56.7473
module_even: crystal_id = 208, phiCenter = 57.0294
module_even: crystal_id = 209, phiCenter = 57.3116
module_even: crystal_id = 210, phiCenter = 57.5937
module_even: crystal_id = 211, phiCenter = 57.8758
module_even: crystal_id = 212, phiCenter = 58.158
module_even: crystal_id = 213, phiCenter = 58.4401
module_even: crystal_id = 214, phiCenter = 58.7222
module_even: crystal_id = 215, phiCenter = 59.0044
module_even: crystal_id = 216, phiCenter = 59.2865
module_even: crystal_id = 217, phiCenter = 59.5686
module_even: crystal_id = 218, phiCenter = 59.8508
module_even: crystal_id = 219, phiCenter = 60.1329
module_even: crystal_id = 220, phiCenter = 60.415
module_even: crystal_id = 221, phiCenter = 60.6972
module_even: crystal_id = 222, phiCenter = 60.9793
module_even: crystal_id = 223, phiCenter = 61.2614
module_even: crystal_id = 224, phiCenter = 61.5435
module_even: crystal_id = 225, phiCenter = 61.8257
module_even: crystal_id = 226, phiCenter = 62.1078
module_even: crystal_id = 227, phiCenter = 62.3899
module_even: crystal_id = 228, phiCenter = 62.6721
module_even: crystal_id = 229, phiCenter = 62.9542
module_even: crystal_id = 230, phiCenter = 63.2363
module_even: crystal_id = 231, phiCenter = 63.5185
module_even: crystal_id = 232, phiCenter = 63.8006
module_even: crystal_id = 233, phiCenter = 64.0827
module_even: crystal_id = 234, phiCenter = 64.3649
module_even: crystal_id = 235, phiCenter = 64.647
module_even: crystal_id = 236, phiCenter = 64.9291
module_even: crystal_id = 237, phiCenter = 65.2113
module_even: crystal_id = 238, phiCenter = 65.4934
module_even: crystal_id = 239, phiCenter = 65.7755
module_even: crystal_id = 240, phiCenter = 66.0577
module_even: crystal_id = 241, phiCenter = 66.3398
module_even: crystal_id = 242, phiCenter = 66.6219
module_even: crystal_id = 243, phiCenter = 66.904
module_even: crystal_id = 244, phiCenter = 67.1862
module_even: crystal_id = 245, phiCenter = 67.4683
module_even: crystal_id = 246, phiCenter = 67.7504
module_even: crystal_id = 247, phiCenter = 68.0326
module_even: crystal_id = 248, phiCenter = 68.3147
module_even: crystal_id = 249, phiCenter = 68.5968
module_even: crystal_id = 250, phiCenter = 68.879
module_even: crystal_id = 251, phiCenter = 69.1611
module_even: crystal_id = 252, phiCenter = 69.4432
module_even: crystal_id = 253, phiCenter = 69.7254
module_even: crystal_id = 254, phiCenter = 70.0075
module_even: crystal_id = 255, phiCenter = 70.2896
module_even: crystal_id = 256, phiCenter = 70.5718
module_even: crystal_id = 257, phiCenter = 70.8539
module_even: crystal_id = 258, phiCenter = 71.136
module_even: crystal_id = 259, phiCenter = 71.4182
module_even: crystal_id = 260, phiCenter = 71.7003
module_even: crystal_id = 261, phiCenter = 71.9824
module_even: crystal_id = 262, phiCenter = 72.2646
module_even: crystal_id = 263, phiCenter = 72.5467
module_even: crystal_id = 264, phiCenter = 72.8288
module_even: crystal_id = 265, phiCenter = 73.1109
module_even: crystal_id = 266, phiCenter = 73.3931
module_even: crystal_id = 267, phiCenter = 73.6752
module_even: crystal_id = 268, phiCenter = 73.9573
module_even: crystal_id = 269, phiCenter = 74.2395
module_even: crystal_id = 270, phiCenter = 74.5216
module_even: crystal_id = 271, phiCenter = 74.8037
module_even: crystal_id = 272, phiCenter = 75.0859
module_even: crystal_id = 273, phiCenter = 75.368
module_even: crystal_id = 274, phiCenter = 75.6501
module_even: crystal_id = 275, phiCenter = 75.9323
module_even: crystal_id = 276, phiCenter = 76.2144
module_even: crystal_id = 277, phiCenter = 76.4965
module_even: crystal_id = 278, phiCenter = 76.7787
module_even: crystal_id = 279, phiCenter = 77.0608
module_even: crystal_id = 280, phiCenter = 77.3429
module_even: crystal_id = 281, phiCenter = 77.6251
module_even: crystal_id = 282, phiCenter = 77.9072
module_even: crystal_id = 283, phiCenter = 78.1893
module_even: crystal_id = 284, phiCenter = 78.4714
module_even: crystal_id = 285, phiCenter = 78.7536
module_even: crystal_id = 286, phiCenter = 79.0357
module_even: crystal_id = 287, phiCenter = 79.3178
module_even: crystal_id = 288, phiCenter = 79.6
module_even: crystal_id = 289, phiCenter = 79.8821
module_even: crystal_id = 290, phiCenter = 80.1642
module_even: crystal_id = 291, phiCenter = 80.4464
module_even: crystal_id = 292, phiCenter = 80.7285
module_even: crystal_id = 293, phiCenter = 81.0106
module_even: crystal_id = 294, phiCenter = 81.2928
module_even: crystal_id = 295, phiCenter = 81.5749
module_even: crystal_id = 296, phiCenter = 81.857
module_even: crystal_id = 297, phiCenter = 82.1392
module_even: crystal_id = 298, phiCenter = 82.4213
module_even: crystal_id = 299, phiCenter = 82.7034
module_even: crystal_id = 300, phiCenter = 82.9856
module_even: crystal_id = 301, phiCenter = 83.2677
module_even: crystal_id = 302, phiCenter = 83.5498
module_even: crystal_id = 303, phiCenter = 83.8319
module_even: crystal_id = 304, phiCenter = 84.1141
module_even: crystal_id = 305, phiCenter = 84.3962
module_even: crystal_id = 306, phiCenter = 84.6783
module_even: crystal_id = 307, phiCenter = 84.9605
module_even: crystal_id = 308, phiCenter = 85.2426
module_even: crystal_id = 309, phiCenter = 85.5247
module_even: crystal_id = 310, phiCenter = 85.8069
module_even: crystal_id = 311, phiCenter = 86.089
module_even: crystal_id = 312, phiCenter = 86.3711
module_even: crystal_id = 313, phiCenter = 86.6533
module_even: crystal_id = 314, phiCenter = 86.9354
module_even: crystal_id = 315, phiCenter = 87.2175
module_even: crystal_id = 316, phiCenter = 87.4997
module_even: crystal_id = 317, phiCenter = 87.7818
module_even: crystal_id = 318, phiCenter = 88.0639
module_even: crystal_id = 319, phiCenter = 88.3461
module_even: crystal_id = 320, phiCenter = 88.6282
module_even: crystal_id = 321, phiCenter = 88.9103
module_even: crystal_id = 322, phiCenter = 89.1924
module_even: crystal_id = 323, phiCenter = 89.4746
module_even: crystal_id = 324, phiCenter = 89.7567
module_even: crystal_id = 325, phiCenter = 90.0388
module_even: crystal_id = 326, phiCenter = 90.321
module_even: crystal_id = 327, phiCenter = 90.6031
module_even: crystal_id = 328, phiCenter = 90.8852
module_even: crystal_id = 329, phiCenter = 91.1674
module_even: crystal_id = 330, phiCenter = 91.4495
module_even: crystal_id = 331, phiCenter = 91.7316
module_even: crystal_id = 332, phiCenter = 92.0138
module_even: crystal_id = 333, phiCenter = 92.2959
module_even: crystal_id = 334, phiCenter = 92.578
module_even: crystal_id = 335, phiCenter = 92.8602
module_even: crystal_id = 336, phiCenter = 93.1423
module_even: crystal_id = 337, phiCenter = 93.4244
module_even: crystal_id = 338, phiCenter = 93.7066
module_even: crystal_id = 339, phiCenter = 93.9887
module_even: crystal_id = 340, phiCenter = 94.2708
module_even: crystal_id = 341, phiCenter = 94.553
module_even: crystal_id = 342, phiCenter = 94.8351
module_even: crystal_id = 343, phiCenter = 95.1172
module_even: crystal_id = 344, phiCenter = 95.3993
module_even: crystal_id = 345, phiCenter = 95.6815
module_even: crystal_id = 346, phiCenter = 95.9636
module_even: crystal_id = 347, phiCenter = 96.2457
module_even: crystal_id = 348, phiCenter = 96.5279
module_even: crystal_id = 349, phiCenter = 96.81
module_even: crystal_id = 350, phiCenter = 97.0921
module_even: crystal_id = 351, phiCenter = 97.3743
module_even: crystal_id = 352, phiCenter = 97.6564
module_even: crystal_id = 353, phiCenter = 97.9385
module_even: crystal_id = 354, phiCenter = 98.2207
module_even: crystal_id = 355, phiCenter = 98.5028
module_even: crystal_id = 356, phiCenter = 98.7849
module_even: crystal_id = 357, phiCenter = 99.0671
module_even: crystal_id = 358, phiCenter = 99.3492
module_even: crystal_id = 359, phiCenter = 99.6313
module_even: crystal_id = 360, phiCenter = 99.9135
module_even: crystal_id = 361, phiCenter = 100.196
module_even: crystal_id = 362, phiCenter = 100.478
module_even: crystal_id = 363, phiCenter = 100.76
module_even: crystal_id = 364, phiCenter = 101.042
module_even: crystal_id = 365, phiCenter = 101.324
module_even: crystal_id = 366, phiCenter = 101.606
module_even: crystal_id = 367, phiCenter = 101.888
module_even: crystal_id = 368, phiCenter = 102.171
module_even: crystal_id = 369, phiCenter = 102.453
module_even: crystal_id = 370, phiCenter = 102.735
module_even: crystal_id = 371, phiCenter = 103.017
module_even: crystal_id = 372, phiCenter = 103.299
module_even: crystal_id = 373, phiCenter = 103.581
module_even: crystal_id = 374, phiCenter = 103.863
module_even: crystal_id = 375, phiCenter = 104.145
module_even: crystal_id = 376, phiCenter = 104.428
module_even: crystal_id = 377, phiCenter = 104.71
module_even: crystal_id = 378, phiCenter = 104.992
module_even: crystal_id = 379, phiCenter = 105.274
module_even: crystal_id = 380, phiCenter = 105.556
module_even: crystal_id = 381, phiCenter = 105.838
module_even: crystal_id = 382, phiCenter = 106.12
module_even: crystal_id = 383, phiCenter = 106.402
module_even: crystal_id = 384, phiCenter = 106.685
module_even: crystal_id = 385, phiCenter = 106.967
module_even: crystal_id = 386, phiCenter = 107.249
module_even: crystal_id = 387, phiCenter = 107.531
module_even: crystal_id = 388, phiCenter = 107.813
module_even: crystal_id = 389, phiCenter = 108.095
module_even: crystal_id = 390, phiCenter = 108.377
module_even: crystal_id = 391, phiCenter = 108.66
module_even: crystal_id = 392, phiCenter = 108.942
module_even: crystal_id = 393, phiCenter = 109.224
module_even: crystal_id = 394, phiCenter = 109.506
module_even: crystal_id = 395, phiCenter = 109.788
module_even: crystal_id = 396, phiCenter = 110.07
module_even: crystal_id = 397, phiCenter = 110.352
module_even: crystal_id = 398, phiCenter = 110.634
module_even: crystal_id = 399, phiCenter = 110.917
module_even: crystal_id = 400, phiCenter = 111.199
module_even: crystal_id = 401, phiCenter = 111.481
module_even: crystal_id = 402, phiCenter = 111.763
module_even: crystal_id = 403, phiCenter = 112.045
module_even: crystal_id = 404, phiCenter = 112.327
module_even: crystal_id = 405, phiCenter = 112.609
module_even: crystal_id = 406, phiCenter = 112.892
module_even: crystal_id = 407, phiCenter = 113.174
module_even: crystal_id = 408, phiCenter = 113.456
module_even: crystal_id = 409, phiCenter = 113.738
module_even: crystal_id = 410, phiCenter = 114.02
module_even: crystal_id = 411, phiCenter = 114.302
module_even: crystal_id = 412, phiCenter = 114.584
module_even: crystal_id = 413, phiCenter = 114.866
module_even: crystal_id = 414, phiCenter = 115.149
module_even: crystal_id = 415, phiCenter = 115.431
module_even: crystal_id = 416, phiCenter = 115.713
module_even: crystal_id = 417, phiCenter = 115.995
module_even: crystal_id = 418, phiCenter = 116.277
module_even: crystal_id = 419, phiCenter = 116.559
module_even: crystal_id = 420, phiCenter = 116.841
module_even: crystal_id = 421, phiCenter = 117.123
module_even: crystal_id = 422, phiCenter = 117.406
module_even: crystal_id = 423, phiCenter = 117.688
module_even: crystal_id = 424, phiCenter = 117.97
module_even: crystal_id = 425, phiCenter = 118.252
module_even: crystal_id = 426, phiCenter = 118.534
module_even: crystal_id = 427, phiCenter = 118.816
module_even: crystal_id = 428, phiCenter = 119.098
module_even: crystal_id = 429, phiCenter = 119.381
module_even: crystal_id = 430, phiCenter = 119.663
module_even: crystal_id = 431, phiCenter = 119.945
module_even: crystal_id = 432, phiCenter = 120.227
module_even: crystal_id = 433, phiCenter = 120.509
module_even: crystal_id = 434, phiCenter = 120.791
module_even: crystal_id = 435, phiCenter = 121.073
module_even: crystal_id = 436, phiCenter = 121.355
module_even: crystal_id = 437, phiCenter = 121.638
module_even: crystal_id = 438, phiCenter = 121.92
module_even: crystal_id = 439, phiCenter = 122.202
module_even: crystal_id = 440, phiCenter = 122.484
module_even: crystal_id = 441, phiCenter = 122.766
module_even: crystal_id = 442, phiCenter = 123.048
module_even: crystal_id = 443, phiCenter = 123.33
module_even: crystal_id = 444, phiCenter = 123.613
module_even: crystal_id = 445, phiCenter = 123.895
module_even: crystal_id = 446, phiCenter = 124.177
module_even: crystal_id = 447, phiCenter = 124.459
module_even: crystal_id = 448, phiCenter = 124.741
module_even: crystal_id = 449, phiCenter = 125.023
module_even: crystal_id = 450, phiCenter = 125.305
module_even: crystal_id = 451, phiCenter = 125.587
module_even: crystal_id = 452, phiCenter = 125.87
module_even: crystal_id = 453, phiCenter = 126.152
module_even: crystal_id = 454, phiCenter = 126.434
module_even: crystal_id = 455, phiCenter = 126.716
module_even: crystal_id = 456, phiCenter = 126.998
module_even: crystal_id = 457, phiCenter = 127.28
module_even: crystal_id = 458, phiCenter = 127.562
module_even: crystal_id = 459, phiCenter = 127.844
module_even: crystal_id = 460, phiCenter = 128.127
module_even: crystal_id = 461, phiCenter = 128.409
module_even: crystal_id = 462, phiCenter = 128.691
module_even: crystal_id = 463, phiCenter = 128.973
module_even: crystal_id = 464, phiCenter = 129.255
module_even: crystal_id = 465, phiCenter = 129.537
module_even: crystal_id = 466, phiCenter = 129.819
module_even: crystal_id = 467, phiCenter = 130.102
module_even: crystal_id = 468, phiCenter = 130.384
module_even: crystal_id = 469, phiCenter = 130.666
module_even: crystal_id = 470, phiCenter = 130.948
module_even: crystal_id = 471, phiCenter = 131.23
module_even: crystal_id = 472, phiCenter = 131.512
module_even: crystal_id = 473, phiCenter = 131.794
module_even: crystal_id = 474, phiCenter = 132.076
module_even: crystal_id = 475, phiCenter = 132.359
module_even: crystal_id = 476, phiCenter = 132.641
module_even: crystal_id = 477, phiCenter = 132.923
module_even: crystal_id = 478, phiCenter = 133.205
module_even: crystal_id = 479, phiCenter = 133.487
module_even: crystal_id = 480, phiCenter = 133.769
module_even: crystal_id = 481, phiCenter = 134.051
module_even: crystal_id = 482, phiCenter = 134.334
module_even: crystal_id = 483, phiCenter = 134.616
module_even: crystal_id = 484, phiCenter = 134.898
module_even: crystal_id = 485, phiCenter = 135.18
module_even: crystal_id = 486, phiCenter = 135.462
module_even: crystal_id = 487, phiCenter = 135.744
module_even: crystal_id = 488, phiCenter = 136.026
module_even: crystal_id = 489, phiCenter = 136.308
module_even: crystal_id = 490, phiCenter = 136.591
module_even: crystal_id = 491, phiCenter = 136.873
module_even: crystal_id = 492, phiCenter = 137.155
module_even: crystal_id = 493, phiCenter = 137.437
module_even: crystal_id = 494, phiCenter = 137.719
module_even: crystal_id = 495, phiCenter = 138.001
module_even: crystal_id = 496, phiCenter = 138.283
module_even: crystal_id = 497, phiCenter = 138.565
module_even: crystal_id = 498, phiCenter = 138.848
module_even: crystal_id = 499, phiCenter = 139.13
module_even: crystal_id = 500, phiCenter = 139.412
module_even: crystal_id = 501, phiCenter = 139.694
module_even: crystal_id = 502, phiCenter = 139.976
module_even: crystal_id = 503, phiCenter = 140.258
module_even: crystal_id = 504, phiCenter = 140.54
module_even: crystal_id = 505, phiCenter = 140.823
module_even: crystal_id = 506, phiCenter = 141.105
module_even: crystal_id = 507, phiCenter = 141.387
module_even: crystal_id = 508, phiCenter = 141.669
module_even: crystal_id = 509, phiCenter = 141.951
module_even: crystal_id = 510, phiCenter = 142.233
module_even: crystal_id = 511, phiCenter = 142.515
module_even: crystal_id = 512, phiCenter = 142.797
module_even: crystal_id = 513, phiCenter = 143.08
module_even: crystal_id = 514, phiCenter = 143.362
module_even: crystal_id = 515, phiCenter = 143.644
module_even: crystal_id = 516, phiCenter = 143.926
module_even: crystal_id = 517, phiCenter = 144.208
module_even: crystal_id = 518, phiCenter = 144.49
module_even: crystal_id = 519, phiCenter = 144.772
module_even: crystal_id = 520, phiCenter = 145.055
module_even: crystal_id = 521, phiCenter = 145.337
module_even: crystal_id = 522, phiCenter = 145.619
module_even: crystal_id = 523, phiCenter = 145.901
module_even: crystal_id = 524, phiCenter = 146.183
module_even: crystal_id = 525, phiCenter = 146.465
module_even: crystal_id = 526, phiCenter = 146.747
module_even: crystal_id = 527, phiCenter = 147.029
module_even: crystal_id = 528, phiCenter = 147.312
module_even: crystal_id = 529, phiCenter = 147.594
module_even: crystal_id = 530, phiCenter = 147.876
module_even: crystal_id = 531, phiCenter = 148.158
module_even: crystal_id = 532, phiCenter = 148.44
module_even: crystal_id = 533, phiCenter = 148.722
module_even: crystal_id = 534, phiCenter = 149.004
module_even: crystal_id = 535, phiCenter = 149.286
module_even: crystal_id = 536, phiCenter = 149.569
module_even: crystal_id = 537, phiCenter = 149.851
module_even: crystal_id = 538, phiCenter = 150.133
module_even: crystal_id = 539, phiCenter = 150.415
module_even: crystal_id = 540, phiCenter = 150.697
module_even: crystal_id = 541, phiCenter = 150.979
module_even: crystal_id = 542, phiCenter = 151.261
module_even: crystal_id = 543, phiCenter = 151.544
module_even: crystal_id = 544, phiCenter = 151.826
module_even: crystal_id = 545, phiCenter = 152.108
module_even: crystal_id = 546, phiCenter = 152.39
module_even: crystal_id = 547, phiCenter = 152.672
module_even: crystal_id = 548, phiCenter = 152.954
module_even: crystal_id = 549, phiCenter = 153.236
module_even: crystal_id = 550, phiCenter = 153.518
module_even: crystal_id = 551, phiCenter = 153.801
module_even: crystal_id = 552, phiCenter = 154.083
module_even: crystal_id = 553, phiCenter = 154.365
module_even: crystal_id = 554, phiCenter = 154.647
module_even: crystal_id = 555, phiCenter = 154.929
module_even: crystal_id = 556, phiCenter = 155.211
module_even: crystal_id = 557, phiCenter = 155.493
module_even: crystal_id = 558, phiCenter = 155.776
module_even: crystal_id = 559, phiCenter = 156.058
module_even: crystal_id = 560, phiCenter = 156.34
module_even: crystal_id = 561, phiCenter = 156.622
module_even: crystal_id = 562, phiCenter = 156.904
module_even: crystal_id = 563, phiCenter = 157.186
module_even: crystal_id = 564, phiCenter = 157.468
module_even: crystal_id = 565, phiCenter = 157.75
module_even: crystal_id = 566, phiCenter = 158.033
module_even: crystal_id = 567, phiCenter = 158.315
module_even: crystal_id = 568, phiCenter = 158.597
module_even: crystal_id = 569, phiCenter = 158.879
module_even: crystal_id = 570, phiCenter = 159.161
module_even: crystal_id = 571, phiCenter = 159.443
module_even: crystal_id = 572, phiCenter = 159.725
module_even: crystal_id = 573, phiCenter = 160.007
module_even: crystal_id = 574, phiCenter = 160.29
module_even: crystal_id = 575, phiCenter = 160.572
module_even: crystal_id = 576, phiCenter = 160.854
module_even: crystal_id = 577, phiCenter = 161.136
module_even: crystal_id = 578, phiCenter = 161.418
module_even: crystal_id = 579, phiCenter = 161.7
module_even: crystal_id = 580, phiCenter = 161.982
module_even: crystal_id = 581, phiCenter = 162.265
module_even: crystal_id = 582, phiCenter = 162.547
module_even: crystal_id = 583, phiCenter = 162.829
module_even: crystal_id = 584, phiCenter = 163.111
module_even: crystal_id = 585, phiCenter = 163.393
module_even: crystal_id = 586, phiCenter = 163.675
module_even: crystal_id = 587, phiCenter = 163.957
module_even: crystal_id = 588, phiCenter = 164.239
module_even: crystal_id = 589, phiCenter = 164.522
module_even: crystal_id = 590, phiCenter = 164.804
module_even: crystal_id = 591, phiCenter = 165.086
module_even: crystal_id = 592, phiCenter = 165.368
module_even: crystal_id = 593, phiCenter = 165.65
module_even: crystal_id = 594, phiCenter = 165.932
module_even: crystal_id = 595, phiCenter = 166.214
module_even: crystal_id = 596, phiCenter = 166.497
module_even: crystal_id = 597, phiCenter = 166.779
module_even: crystal_id = 598, phiCenter = 167.061
module_even: crystal_id = 599, phiCenter = 167.343
module_even: crystal_id = 600, phiCenter = 167.625
module_even: crystal_id = 601, phiCenter = 167.907
module_even: crystal_id = 602, phiCenter = 168.189
module_even: crystal_id = 603, phiCenter = 168.471
module_even: crystal_id = 604, phiCenter = 168.754
module_even: crystal_id = 605, phiCenter = 169.036
module_even: crystal_id = 606, phiCenter = 169.318
module_even: crystal_id = 607, phiCenter = 169.6
module_even: crystal_id = 608, phiCenter = 169.882
module_even: crystal_id = 609, phiCenter = 170.164
module_even: crystal_id = 610, phiCenter = 170.446
module_even: crystal_id = 611, phiCenter = 170.729
module_even: crystal_id = 612, phiCenter = 171.011
module_even: crystal_id = 613, phiCenter = 171.293
module_even: crystal_id = 614, phiCenter = 171.575
module_even: crystal_id = 615, phiCenter = 171.857
module_even: crystal_id = 616, phiCenter = 172.139
module_even: crystal_id = 617, phiCenter = 172.421
module_even: crystal_id = 618, phiCenter = 172.703
module_even: crystal_id = 619, phiCenter = 172.986
module_even: crystal_id = 620, phiCenter = 173.268
module_even: crystal_id = 621, phiCenter = 173.55
module_even: crystal_id = 622, phiCenter = 173.832
module_even: crystal_id = 623, phiCenter = 174.114
module_even: crystal_id = 624, phiCenter = 174.396
module_even: crystal_id = 625, phiCenter = 174.678
module_even: crystal_id = 626, phiCenter = 174.96
module_even: crystal_id = 627, phiCenter = 175.243
module_even: crystal_id = 628, phiCenter = 175.525
module_even: crystal_id = 629, phiCenter = 175.807
module_even: crystal_id = 630, phiCenter = 176.089
module_even: crystal_id = 631, phiCenter = 176.371
module_even: crystal_id = 632, phiCenter = 176.653
module_even: crystal_id = 633, phiCenter = 176.935
module_even: crystal_id = 634, phiCenter = 177.218
module_even: crystal_id = 635, phiCenter = 177.5
module_even: crystal_id = 636, phiCenter = 177.782
module_even: crystal_id = 637, phiCenter = 178.064
module_even: crystal_id = 638, phiCenter = 178.346
module_even: crystal_id = 639, phiCenter = 178.628
module_even: crystal_id = 640, phiCenter = 178.91
module_even: crystal_id = 641, phiCenter = 179.192
module_even: crystal_id = 642, phiCenter = 179.475
module_even: crystal_id = 643, phiCenter = 179.757
module_even: crystal_id = 644, phiCenter = 180.039
module_even: crystal_id = 645, phiCenter = 180.321
module_even: crystal_id = 646, phiCenter = 180.603
module_even: crystal_id = 647, phiCenter = 180.885
module_even: crystal_id = 648, phiCenter = 181.167
module_even: crystal_id = 649, phiCenter = 181.45
module_even: crystal_id = 650, phiCenter = 181.732
module_even: crystal_id = 651, phiCenter = 182.014
module_even: crystal_id = 652, phiCenter = 182.296
module_even: crystal_id = 653, phiCenter = 182.578
module_even: crystal_id = 654, phiCenter = 182.86
module_even: crystal_id = 655, phiCenter = 183.142
module_even: crystal_id = 656, phiCenter = 183.424
module_even: crystal_id = 657, phiCenter = 183.707
module_even: crystal_id = 658, phiCenter = 183.989
module_even: crystal_id = 659, phiCenter = 184.271
module_even: crystal_id = 660, phiCenter = 184.553
module_even: crystal_id = 661, phiCenter = 184.835
module_even: crystal_id = 662, phiCenter = 185.117
module_even: crystal_id = 663, phiCenter = 185.399
module_even: crystal_id = 664, phiCenter = 185.681
module_even: crystal_id = 665, phiCenter = 185.964
module_even: crystal_id = 666, phiCenter = 186.246
module_even: crystal_id = 667, phiCenter = 186.528
module_even: crystal_id = 668, phiCenter = 186.81
module_even: crystal_id = 669, phiCenter = 187.092
module_even: crystal_id = 670, phiCenter = 187.374
module_even: crystal_id = 671, phiCenter = 187.656
module_even: crystal_id = 672, phiCenter = 187.939
module_even: crystal_id = 673, phiCenter = 188.221
module_even: crystal_id = 674, phiCenter = 188.503
module_even: crystal_id = 675, phiCenter = 188.785
module_even: crystal_id = 676, phiCenter = 189.067
module_even: crystal_id = 677, phiCenter = 189.349
module_even: crystal_id = 678, phiCenter = 189.631
module_even: crystal_id = 679, phiCenter = 189.913
module_even: crystal_id = 680, phiCenter = 190.196
module_even: crystal_id = 681, phiCenter = 190.478
module_even: crystal_id = 682, phiCenter = 190.76
module_even: crystal_id = 683, phiCenter = 191.042
module_even: crystal_id = 684, phiCenter = 191.324
module_even: crystal_id = 685, phiCenter = 191.606
module_even: crystal_id = 686, phiCenter = 191.888
module_even: crystal_id = 687, phiCenter = 192.171
module_even: crystal_id = 688, phiCenter = 192.453
module_even: crystal_id = 689, phiCenter = 192.735
module_even: crystal_id = 690, phiCenter = 193.017
module_even: crystal_id = 691, phiCenter = 193.299
module_even: crystal_id = 692, phiCenter = 193.581
module_even: crystal_id = 693, phiCenter = 193.863
module_even: crystal_id = 694, phiCenter = 194.145
module_even: crystal_id = 695, phiCenter = 194.428
module_even: crystal_id = 696, phiCenter = 194.71
module_even: crystal_id = 697, phiCenter = 194.992
module_even: crystal_id = 698, phiCenter = 195.274
module_even: crystal_id = 699, phiCenter = 195.556
module_even: crystal_id = 700, phiCenter = 195.838
module_even: crystal_id = 701, phiCenter = 196.12
module_even: crystal_id = 702, phiCenter = 196.402
module_even: crystal_id = 703, phiCenter = 196.685
module_even: crystal_id = 704, phiCenter = 196.967
module_even: crystal_id = 705, phiCenter = 197.249
module_even: crystal_id = 706, phiCenter = 197.531
module_even: crystal_id = 707, phiCenter = 197.813
module_even: crystal_id = 708, phiCenter = 198.095
module_even: crystal_id = 709, phiCenter = 198.377
module_even: crystal_id = 710, phiCenter = 198.66
module_even: crystal_id = 711, phiCenter = 198.942
module_even: crystal_id = 712, phiCenter = 199.224
module_even: crystal_id = 713, phiCenter = 199.506
module_even: crystal_id = 714, phiCenter = 199.788
module_even: crystal_id = 715, phiCenter = 200.07
module_even: crystal_id = 716, phiCenter = 200.352
module_even: crystal_id = 717, phiCenter = 200.634
module_even: crystal_id = 718, phiCenter = 200.917
module_even: crystal_id = 719, phiCenter = 201.199
module_even: crystal_id = 720, phiCenter = 201.481
module_even: crystal_id = 721, phiCenter = 201.763
module_even: crystal_id = 722, phiCenter = 202.045
module_even: crystal_id = 723, phiCenter = 202.327
module_even: crystal_id = 724, phiCenter = 202.609
module_even: crystal_id = 725, phiCenter = 202.892
module_even: crystal_id = 726, phiCenter = 203.174
module_even: crystal_id = 727, phiCenter = 203.456
module_even: crystal_id = 728, phiCenter = 203.738
module_even: crystal_id = 729, phiCenter = 204.02
module_even: crystal_id = 730, phiCenter = 204.302
module_even: crystal_id = 731, phiCenter = 204.584
module_even: crystal_id = 732, phiCenter = 204.866
module_even: crystal_id = 733, phiCenter = 205.149
module_even: crystal_id = 734, phiCenter = 205.431
module_even: crystal_id = 735, phiCenter = 205.713
module_even: crystal_id = 736, phiCenter = 205.995
module_even: crystal_id = 737, phiCenter = 206.277
module_even: crystal_id = 738, phiCenter = 206.559
module_even: crystal_id = 739, phiCenter = 206.841
module_even: crystal_id = 740, phiCenter = 207.123
module_even: crystal_id = 741, phiCenter = 207.406
module_even: crystal_id = 742, phiCenter = 207.688
module_even: crystal_id = 743, phiCenter = 207.97
module_even: crystal_id = 744, phiCenter = 208.252
module_even: crystal_id = 745, phiCenter = 208.534
module_even: crystal_id = 746, phiCenter = 208.816
module_even: crystal_id = 747, phiCenter = 209.098
module_even: crystal_id = 748, phiCenter = 209.381
module_even: crystal_id = 749, phiCenter = 209.663
module_even: crystal_id = 750, phiCenter = 209.945
module_even: crystal_id = 751, phiCenter = 210.227
module_even: crystal_id = 752, phiCenter = 210.509
module_even: crystal_id = 753, phiCenter = 210.791
module_even: crystal_id = 754, phiCenter = 211.073
module_even: crystal_id = 755, phiCenter = 211.355
module_even: crystal_id = 756, phiCenter = 211.638
module_even: crystal_id = 757, phiCenter = 211.92
module_even: crystal_id = 758, phiCenter = 212.202
module_even: crystal_id = 759, phiCenter = 212.484
module_even: crystal_id = 760, phiCenter = 212.766
module_even: crystal_id = 761, phiCenter = 213.048
module_even: crystal_id = 762, phiCenter = 213.33
module_even: crystal_id = 763, phiCenter = 213.613
module_even: crystal_id = 764, phiCenter = 213.895
module_even: crystal_id = 765, phiCenter = 214.177
module_even: crystal_id = 766, phiCenter = 214.459
module_even: crystal_id = 767, phiCenter = 214.741
module_even: crystal_id = 768, phiCenter = 215.023
module_even: crystal_id = 769, phiCenter = 215.305
module_even: crystal_id = 770, phiCenter = 215.587
module_even: crystal_id = 771, phiCenter = 215.87
module_even: crystal_id = 772, phiCenter = 216.152
module_even: crystal_id = 773, phiCenter = 216.434
module_even: crystal_id = 774, phiCenter = 216.716
module_even: crystal_id = 775, phiCenter = 216.998
module_even: crystal_id = 776, phiCenter = 217.28
module_even: crystal_id = 777, phiCenter = 217.562
module_even: crystal_id = 778, phiCenter = 217.844
module_even: crystal_id = 779, phiCenter = 218.127
module_even: crystal_id = 780, phiCenter = 218.409
module_even: crystal_id = 781, phiCenter = 218.691
module_even: crystal_id = 782, phiCenter = 218.973
module_even: crystal_id = 783, phiCenter = 219.255
module_even: crystal_id = 784, phiCenter = 219.537
module_even: crystal_id = 785, phiCenter = 219.819
module_even: crystal_id = 786, phiCenter = 220.102
module_even: crystal_id = 787, phiCenter = 220.384
module_even: crystal_id = 788, phiCenter = 220.666
module_even: crystal_id = 789, phiCenter = 220.948
module_even: crystal_id = 790, phiCenter = 221.23
module_even: crystal_id = 791, phiCenter = 221.512
module_even: crystal_id = 792, phiCenter = 221.794
module_even: crystal_id = 793, phiCenter = 222.076
module_even: crystal_id = 794, phiCenter = 222.359
module_even: crystal_id = 795, phiCenter = 222.641
module_even: crystal_id = 796, phiCenter = 222.923
module_even: crystal_id = 797, phiCenter = 223.205
module_even: crystal_id = 798, phiCenter = 223.487
module_even: crystal_id = 799, phiCenter = 223.769
module_even: crystal_id = 800, phiCenter = 224.051
module_even: crystal_id = 801, phiCenter = 224.334
module_even: crystal_id = 802, phiCenter = 224.616
module_even: crystal_id = 803, phiCenter = 224.898
module_even: crystal_id = 804, phiCenter = 225.18
module_even: crystal_id = 805, phiCenter = 225.462
module_even: crystal_id = 806, phiCenter = 225.744
module_even: crystal_id = 807, phiCenter = 226.026
module_even: crystal_id = 808, phiCenter = 226.308
module_even: crystal_id = 809, phiCenter = 226.591
module_even: crystal_id = 810, phiCenter = 226.873
module_even: crystal_id = 811, phiCenter = 227.155
module_even: crystal_id = 812, phiCenter = 227.437
module_even: crystal_id = 813, phiCenter = 227.719
module_even: crystal_id = 814, phiCenter = 228.001
module_even: crystal_id = 815, phiCenter = 228.283
module_even: crystal_id = 816, phiCenter = 228.565
module_even: crystal_id = 817, phiCenter = 228.848
module_even: crystal_id = 818, phiCenter = 229.13
module_even: crystal_id = 819, phiCenter = 229.412
module_even: crystal_id = 820, phiCenter = 229.694
module_even: crystal_id = 821, phiCenter = 229.976
module_even: crystal_id = 822, phiCenter = 230.258
module_even: crystal_id = 823, phiCenter = 230.54
module_even: crystal_id = 824, phiCenter = 230.823
module_even: crystal_id = 825, phiCenter = 231.105
module_even: crystal_id = 826, phiCenter = 231.387
module_even: crystal_id = 827, phiCenter = 231.669
module_even: crystal_id = 828, phiCenter = 231.951
module_even: crystal_id = 829, phiCenter = 232.233
module_even: crystal_id = 830, phiCenter = 232.515
module_even: crystal_id = 831, phiCenter = 232.797
module_even: crystal_id = 832, phiCenter = 233.08
module_even: crystal_id = 833, phiCenter = 233.362
module_even: crystal_id = 834, phiCenter = 233.644
module_even: crystal_id = 835, phiCenter = 233.926
module_even: crystal_id = 836, phiCenter = 234.208
module_even: crystal_id = 837, phiCenter = 234.49
module_even: crystal_id = 838, phiCenter = 234.772
module_even: crystal_id = 839, phiCenter = 235.055
module_even: crystal_id = 840, phiCenter = 235.337
module_even: crystal_id = 841, phiCenter = 235.619
module_even: crystal_id = 842, phiCenter = 235.901
module_even: crystal_id = 843, phiCenter = 236.183
module_even: crystal_id = 844, phiCenter = 236.465
module_even: crystal_id = 845, phiCenter = 236.747
module_even: crystal_id = 846, phiCenter = 237.029
module_even: crystal_id = 847, phiCenter = 237.312
module_even: crystal_id = 848, phiCenter = 237.594
module_even: crystal_id = 849, phiCenter = 237.876
module_even: crystal_id = 850, phiCenter = 238.158
module_even: crystal_id = 851, phiCenter = 238.44
module_even: crystal_id = 852, phiCenter = 238.722
module_even: crystal_id = 853, phiCenter = 239.004
module_even: crystal_id = 854, phiCenter = 239.286
module_even: crystal_id = 855, phiCenter = 239.569
module_even: crystal_id = 856, phiCenter = 239.851
module_even: crystal_id = 857, phiCenter = 240.133
module_even: crystal_id = 858, phiCenter = 240.415
module_even: crystal_id = 859, phiCenter = 240.697
module_even: crystal_id = 860, phiCenter = 240.979
module_even: crystal_id = 861, phiCenter = 241.261
module_even: crystal_id = 862, phiCenter = 241.544
module_even: crystal_id = 863, phiCenter = 241.826
module_even: crystal_id = 864, phiCenter = 242.108
module_even: crystal_id = 865, phiCenter = 242.39
module_even: crystal_id = 866, phiCenter = 242.672
module_even: crystal_id = 867, phiCenter = 242.954
module_even: crystal_id = 868, phiCenter = 243.236
module_even: crystal_id = 869, phiCenter = 243.518
module_even: crystal_id = 870, phiCenter = 243.801
module_even: crystal_id = 871, phiCenter = 244.083
module_even: crystal_id = 872, phiCenter = 244.365
module_even: crystal_id = 873, phiCenter = 244.647
module_even: crystal_id = 874, phiCenter = 244.929
module_even: crystal_id = 875, phiCenter = 245.211
module_even: crystal_id = 876, phiCenter = 245.493
module_even: crystal_id = 877, phiCenter = 245.776
module_even: crystal_id = 878, phiCenter = 246.058
module_even: crystal_id = 879, phiCenter = 246.34
module_even: crystal_id = 880, phiCenter = 246.622
module_even: crystal_id = 881, phiCenter = 246.904
module_even: crystal_id = 882, phiCenter = 247.186
module_even: crystal_id = 883, phiCenter = 247.468
module_even: crystal_id = 884, phiCenter = 247.75
module_even: crystal_id = 885, phiCenter = 248.033
module_even: crystal_id = 886, phiCenter = 248.315
module_even: crystal_id = 887, phiCenter = 248.597
module_even: crystal_id = 888, phiCenter = 248.879
module_even: crystal_id = 889, phiCenter = 249.161
module_even: crystal_id = 890, phiCenter = 249.443
module_even: crystal_id = 891, phiCenter = 249.725
module_even: crystal_id = 892, phiCenter = 250.007
module_even: crystal_id = 893, phiCenter = 250.29
module_even: crystal_id = 894, phiCenter = 250.572
module_even: crystal_id = 895, phiCenter = 250.854
module_even: crystal_id = 896, phiCenter = 251.136
module_even: crystal_id = 897, phiCenter = 251.418
module_even: crystal_id = 898, phiCenter = 251.7
module_even: crystal_id = 899, phiCenter = 251.982
module_even: crystal_id = 900, phiCenter = 252.265
module_even: crystal_id = 901, phiCenter = 252.547
module_even: crystal_id = 902, phiCenter = 252.829
module_even: crystal_id = 903, phiCenter = 253.111
module_even: crystal_id = 904, phiCenter = 253.393
module_even: crystal_id = 905, phiCenter = 253.675
module_even: crystal_id = 906, phiCenter = 253.957
module_even: crystal_id = 907, phiCenter = 254.239
module_even: crystal_id = 908, phiCenter = 254.522
module_even: crystal_id = 909, phiCenter = 254.804
module_even: crystal_id = 910, phiCenter = 255.086
module_even: crystal_id = 911, phiCenter = 255.368
module_even: crystal_id = 912, phiCenter = 255.65
module_even: crystal_id = 913, phiCenter = 255.932
module_even: crystal_id = 914, phiCenter = 256.214
module_even: crystal_id = 915, phiCenter = 256.497
module_even: crystal_id = 916, phiCenter = 256.779
module_even: crystal_id = 917, phiCenter = 257.061
module_even: crystal_id = 918, phiCenter = 257.343
module_even: crystal_id = 919, phiCenter = 257.625
module_even: crystal_id = 920, phiCenter = 257.907
module_even: crystal_id = 921, phiCenter = 258.189
module_even: crystal_id = 922, phiCenter = 258.471
module_even: crystal_id = 923, phiCenter = 258.754
module_even: crystal_id = 924, phiCenter = 259.036
module_even: crystal_id = 925, phiCenter = 259.318
module_even: crystal_id = 926, phiCenter = 259.6
module_even: crystal_id = 927, phiCenter = 259.882
module_even: crystal_id = 928, phiCenter = 260.164
module_even: crystal_id = 929, phiCenter = 260.446
module_even: crystal_id = 930, phiCenter = 260.729
module_even: crystal_id = 931, phiCenter = 261.011
module_even: crystal_id = 932, phiCenter = 261.293
module_even: crystal_id = 933, phiCenter = 261.575
module_even: crystal_id = 934, phiCenter = 261.857
module_even: crystal_id = 935, phiCenter = 262.139
module_even: crystal_id = 936, phiCenter = 262.421
module_even: crystal_id = 937, phiCenter = 262.703
module_even: crystal_id = 938, phiCenter = 262.986
module_even: crystal_id = 939, phiCenter = 263.268
module_even: crystal_id = 940, phiCenter = 263.55
module_even: crystal_id = 941, phiCenter = 263.832
module_even: crystal_id = 942, phiCenter = 264.114
module_even: crystal_id = 943, phiCenter = 264.396
module_even: crystal_id = 944, phiCenter = 264.678
module_even: crystal_id = 945, phiCenter = 264.96
module_even: crystal_id = 946, phiCenter = 265.243
module_even: crystal_id = 947, phiCenter = 265.525
module_even: crystal_id = 948, phiCenter = 265.807
module_even: crystal_id = 949, phiCenter = 266.089
module_even: crystal_id = 950, phiCenter = 266.371
module_even: crystal_id = 951, phiCenter = 266.653
module_even: crystal_id = 952, phiCenter = 266.935
module_even: crystal_id = 953, phiCenter = 267.218
module_even: crystal_id = 954, phiCenter = 267.5
module_even: crystal_id = 955, phiCenter = 267.782
module_even: crystal_id = 956, phiCenter = 268.064
module_even: crystal_id = 957, phiCenter = 268.346
module_even: crystal_id = 958, phiCenter = 268.628
module_even: crystal_id = 959, phiCenter = 268.91
module_even: crystal_id = 960, phiCenter = 269.192
module_even: crystal_id = 961, phiCenter = 269.475
module_even: crystal_id = 962, phiCenter = 269.757
module_even: crystal_id = 963, phiCenter = 270.039
module_even: crystal_id = 964, phiCenter = 270.321
module_even: crystal_id = 965, phiCenter = 270.603
module_even: crystal_id = 966, phiCenter = 270.885
module_even: crystal_id = 967, phiCenter = 271.167
module_even: crystal_id = 968, phiCenter = 271.45
module_even: crystal_id = 969, phiCenter = 271.732
module_even: crystal_id = 970, phiCenter = 272.014
module_even: crystal_id = 971, phiCenter = 272.296
module_even: crystal_id = 972, phiCenter = 272.578
module_even: crystal_id = 973, phiCenter = 272.86
module_even: crystal_id = 974, phiCenter = 273.142
module_even: crystal_id = 975, phiCenter = 273.424
module_even: crystal_id = 976, phiCenter = 273.707
module_even: crystal_id = 977, phiCenter = 273.989
module_even: crystal_id = 978, phiCenter = 274.271
module_even: crystal_id = 979, phiCenter = 274.553
module_even: crystal_id = 980, phiCenter = 274.835
module_even: crystal_id = 981, phiCenter = 275.117
module_even: crystal_id = 982, phiCenter = 275.399
module_even: crystal_id = 983, phiCenter = 275.681
module_even: crystal_id = 984, phiCenter = 275.964
module_even: crystal_id = 985, phiCenter = 276.246
module_even: crystal_id = 986, phiCenter = 276.528
module_even: crystal_id = 987, phiCenter = 276.81
module_even: crystal_id = 988, phiCenter = 277.092
module_even: crystal_id = 989, phiCenter = 277.374
module_even: crystal_id = 990, phiCenter = 277.656
module_even: crystal_id = 991, phiCenter = 277.939
module_even: crystal_id = 992, phiCenter = 278.221
module_even: crystal_id = 993, phiCenter = 278.503
module_even: crystal_id = 994, phiCenter = 278.785
module_even: crystal_id = 995, phiCenter = 279.067
module_even: crystal_id = 996, phiCenter = 279.349
module_even: crystal_id = 997, phiCenter = 279.631
module_even: crystal_id = 998, phiCenter = 279.913
module_even: crystal_id = 999, phiCenter = 280.196
module_even: crystal_id = 1000, phiCenter = 280.478
module_even: crystal_id = 1001, phiCenter = 280.76
module_even: crystal_id = 1002, phiCenter = 281.042
module_even: crystal_id = 1003, phiCenter = 281.324
module_even: crystal_id = 1004, phiCenter = 281.606
module_even: crystal_id = 1005, phiCenter = 281.888
module_even: crystal_id = 1006, phiCenter = 282.171
module_even: crystal_id = 1007, phiCenter = 282.453
module_even: crystal_id = 1008, phiCenter = 282.735
module_even: crystal_id = 1009, phiCenter = 283.017
module_even: crystal_id = 1010, phiCenter = 283.299
module_even: crystal_id = 1011, phiCenter = 283.581
module_even: crystal_id = 1012, phiCenter = 283.863
module_even: crystal_id = 1013, phiCenter = 284.145
module_even: crystal_id = 1014, phiCenter = 284.428
module_even: crystal_id = 1015, phiCenter = 284.71
module_even: crystal_id = 1016, phiCenter = 284.992
module_even: crystal_id = 1017, phiCenter = 285.274
module_even: crystal_id = 1018, phiCenter = 285.556
module_even: crystal_id = 1019, phiCenter = 285.838
module_even: crystal_id = 1020, phiCenter = 286.12
module_even: crystal_id = 1021, phiCenter = 286.402
module_even: crystal_id = 1022, phiCenter = 286.685
module_even: crystal_id = 1023, phiCenter = 286.967
module_even: crystal_id = 1024, phiCenter = 287.249
module_even: crystal_id = 1025, phiCenter = 287.531
module_even: crystal_id = 1026, phiCenter = 287.813
module_even: crystal_id = 1027, phiCenter = 288.095
module_even: crystal_id = 1028, phiCenter = 288.377
module_even: crystal_id = 1029, phiCenter = 288.66
module_even: crystal_id = 1030, phiCenter = 288.942
module_even: crystal_id = 1031, phiCenter = 289.224
module_even: crystal_id = 1032, phiCenter = 289.506
module_even: crystal_id = 1033, phiCenter = 289.788
module_even: crystal_id = 1034, phiCenter = 290.07
module_even: crystal_id = 1035, phiCenter = 290.352
module_even: crystal_id = 1036, phiCenter = 290.634
module_even: crystal_id = 1037, phiCenter = 290.917
module_even: crystal_id = 1038, phiCenter = 291.199
module_even: crystal_id = 1039, phiCenter = 291.481
module_even: crystal_id = 1040, phiCenter = 291.763
module_even: crystal_id = 1041, phiCenter = 292.045
module_even: crystal_id = 1042, phiCenter = 292.327
module_even: crystal_id = 1043, phiCenter = 292.609
module_even: crystal_id = 1044, phiCenter = 292.892
module_even: crystal_id = 1045, phiCenter = 293.174
module_even: crystal_id = 1046, phiCenter = 293.456
module_even: crystal_id = 1047, phiCenter = 293.738
module_even: crystal_id = 1048, phiCenter = 294.02
module_even: crystal_id = 1049, phiCenter = 294.302
module_even: crystal_id = 1050, phiCenter = 294.584
module_even: crystal_id = 1051, phiCenter = 294.866
module_even: crystal_id = 1052, phiCenter = 295.149
module_even: crystal_id = 1053, phiCenter = 295.431
module_even: crystal_id = 1054, phiCenter = 295.713
module_even: crystal_id = 1055, phiCenter = 295.995
module_even: crystal_id = 1056, phiCenter = 296.277
module_even: crystal_id = 1057, phiCenter = 296.559
module_even: crystal_id = 1058, phiCenter = 296.841
module_even: crystal_id = 1059, phiCenter = 297.123
module_even: crystal_id = 1060, phiCenter = 297.406
module_even: crystal_id = 1061, phiCenter = 297.688
module_even: crystal_id = 1062, phiCenter = 297.97
module_even: crystal_id = 1063, phiCenter = 298.252
module_even: crystal_id = 1064, phiCenter = 298.534
module_even: crystal_id = 1065, phiCenter = 298.816
module_even: crystal_id = 1066, phiCenter = 299.098
module_even: crystal_id = 1067, phiCenter = 299.381
module_even: crystal_id = 1068, phiCenter = 299.663
module_even: crystal_id = 1069, phiCenter = 299.945
module_even: crystal_id = 1070, phiCenter = 300.227
module_even: crystal_id = 1071, phiCenter = 300.509
module_even: crystal_id = 1072, phiCenter = 300.791
module_even: crystal_id = 1073, phiCenter = 301.073
module_even: crystal_id = 1074, phiCenter = 301.355
module_even: crystal_id = 1075, phiCenter = 301.638
module_even: crystal_id = 1076, phiCenter = 301.92
module_even: crystal_id = 1077, phiCenter = 302.202
module_even: crystal_id = 1078, phiCenter = 302.484
module_even: crystal_id = 1079, phiCenter = 302.766
module_even: crystal_id = 1080, phiCenter = 303.048
module_even: crystal_id = 1081, phiCenter = 303.33
module_even: crystal_id = 1082, phiCenter = 303.613
module_even: crystal_id = 1083, phiCenter = 303.895
module_even: crystal_id = 1084, phiCenter = 304.177
module_even: crystal_id = 1085, phiCenter = 304.459
module_even: crystal_id = 1086, phiCenter = 304.741
module_even: crystal_id = 1087, phiCenter = 305.023
module_even: crystal_id = 1088, phiCenter = 305.305
module_even: crystal_id = 1089, phiCenter = 305.587
module_even: crystal_id = 1090, phiCenter = 305.87
module_even: crystal_id = 1091, phiCenter = 306.152
module_even: crystal_id = 1092, phiCenter = 306.434
module_even: crystal_id = 1093, phiCenter = 306.716
module_even: crystal_id = 1094, phiCenter = 306.998
module_even: crystal_id = 1095, phiCenter = 307.28
module_even: crystal_id = 1096, phiCenter = 307.562
module_even: crystal_id = 1097, phiCenter = 307.844
module_even: crystal_id = 1098, phiCenter = 308.127
module_even: crystal_id = 1099, phiCenter = 308.409
module_even: crystal_id = 1100, phiCenter = 308.691
module_even: crystal_id = 1101, phiCenter = 308.973
module_even: crystal_id = 1102, phiCenter = 309.255
module_even: crystal_id = 1103, phiCenter = 309.537
module_even: crystal_id = 1104, phiCenter = 309.819
module_even: crystal_id = 1105, phiCenter = 310.102
module_even: crystal_id = 1106, phiCenter = 310.384
module_even: crystal_id = 1107, phiCenter = 310.666
module_even: crystal_id = 1108, phiCenter = 310.948
module_even: crystal_id = 1109, phiCenter = 311.23
module_even: crystal_id = 1110, phiCenter = 311.512
module_even: crystal_id = 1111, phiCenter = 311.794
module_even: crystal_id = 1112, phiCenter = 312.076
module_even: crystal_id = 1113, phiCenter = 312.359
module_even: crystal_id = 1114, phiCenter = 312.641
module_even: crystal_id = 1115, phiCenter = 312.923
module_even: crystal_id = 1116, phiCenter = 313.205
module_even: crystal_id = 1117, phiCenter = 313.487
module_even: crystal_id = 1118, phiCenter = 313.769
module_even: crystal_id = 1119, phiCenter = 314.051
module_even: crystal_id = 1120, phiCenter = 314.334
module_even: crystal_id = 1121, phiCenter = 314.616
module_even: crystal_id = 1122, phiCenter = 314.898
module_even: crystal_id = 1123, phiCenter = 315.18
module_even: crystal_id = 1124, phiCenter = 315.462
module_even: crystal_id = 1125, phiCenter = 315.744
module_even: crystal_id = 1126, phiCenter = 316.026
module_even: crystal_id = 1127, phiCenter = 316.308
module_even: crystal_id = 1128, phiCenter = 316.591
module_even: crystal_id = 1129, phiCenter = 316.873
module_even: crystal_id = 1130, phiCenter = 317.155
module_even: crystal_id = 1131, phiCenter = 317.437
module_even: crystal_id = 1132, phiCenter = 317.719
module_even: crystal_id = 1133, phiCenter = 318.001
module_even: crystal_id = 1134, phiCenter = 318.283
module_even: crystal_id = 1135, phiCenter = 318.565
module_even: crystal_id = 1136, phiCenter = 318.848
module_even: crystal_id = 1137, phiCenter = 319.13
module_even: crystal_id = 1138, phiCenter = 319.412
module_even: crystal_id = 1139, phiCenter = 319.694
module_even: crystal_id = 1140, phiCenter = 319.976
module_even: crystal_id = 1141, phiCenter = 320.258
module_even: crystal_id = 1142, phiCenter = 320.54
module_even: crystal_id = 1143, phiCenter = 320.823
module_even: crystal_id = 1144, phiCenter = 321.105
module_even: crystal_id = 1145, phiCenter = 321.387
module_even: crystal_id = 1146, phiCenter = 321.669
module_even: crystal_id = 1147, phiCenter = 321.951
module_even: crystal_id = 1148, phiCenter = 322.233
module_even: crystal_id = 1149, phiCenter = 322.515
module_even: crystal_id = 1150, phiCenter = 322.797
module_even: crystal_id = 1151, phiCenter = 323.08
module_even: crystal_id = 1152, phiCenter = 323.362
module_even: crystal_id = 1153, phiCenter = 323.644
module_even: crystal_id = 1154, phiCenter = 323.926
module_even: crystal_id = 1155, phiCenter = 324.208
module_even: crystal_id = 1156, phiCenter = 324.49
module_even: crystal_id = 1157, phiCenter = 324.772
module_even: crystal_id = 1158, phiCenter = 325.055
module_even: crystal_id = 1159, phiCenter = 325.337
module_even: crystal_id = 1160, phiCenter = 325.619
module_even: crystal_id = 1161, phiCenter = 325.901
module_even: crystal_id = 1162, phiCenter = 326.183
module_even: crystal_id = 1163, phiCenter = 326.465
module_even: crystal_id = 1164, phiCenter = 326.747
module_even: crystal_id = 1165, phiCenter = 327.029
module_even: crystal_id = 1166, phiCenter = 327.312
module_even: crystal_id = 1167, phiCenter = 327.594
module_even: crystal_id = 1168, phiCenter = 327.876
module_even: crystal_id = 1169, phiCenter = 328.158
module_even: crystal_id = 1170, phiCenter = 328.44
module_even: crystal_id = 1171, phiCenter = 328.722
module_even: crystal_id = 1172, phiCenter = 329.004
module_even: crystal_id = 1173, phiCenter = 329.286
module_even: crystal_id = 1174, phiCenter = 329.569
module_even: crystal_id = 1175, phiCenter = 329.851
module_even: crystal_id = 1176, phiCenter = 330.133
module_even: crystal_id = 1177, phiCenter = 330.415
module_even: crystal_id = 1178, phiCenter = 330.697
module_even: crystal_id = 1179, phiCenter = 330.979
module_even: crystal_id = 1180, phiCenter = 331.261
module_even: crystal_id = 1181, phiCenter = 331.544
module_even: crystal_id = 1182, phiCenter = 331.826
module_even: crystal_id = 1183, phiCenter = 332.108
module_even: crystal_id = 1184, phiCenter = 332.39
module_even: crystal_id = 1185, phiCenter = 332.672
module_even: crystal_id = 1186, phiCenter = 332.954
module_even: crystal_id = 1187, phiCenter = 333.236
module_even: crystal_id = 1188, phiCenter = 333.518
module_even: crystal_id = 1189, phiCenter = 333.801
module_even: crystal_id = 1190, phiCenter = 334.083
module_even: crystal_id = 1191, phiCenter = 334.365
module_even: crystal_id = 1192, phiCenter = 334.647
module_even: crystal_id = 1193, phiCenter = 334.929
module_even: crystal_id = 1194, phiCenter = 335.211
module_even: crystal_id = 1195, phiCenter = 335.493
module_even: crystal_id = 1196, phiCenter = 335.776
module_even: crystal_id = 1197, phiCenter = 336.058
module_even: crystal_id = 1198, phiCenter = 336.34
module_even: crystal_id = 1199, phiCenter = 336.622
module_even: crystal_id = 1200, phiCenter = 336.904
module_even: crystal_id = 1201, phiCenter = 337.186
module_even: crystal_id = 1202, phiCenter = 337.468
module_even: crystal_id = 1203, phiCenter = 337.75
module_even: crystal_id = 1204, phiCenter = 338.033
module_even: crystal_id = 1205, phiCenter = 338.315
module_even: crystal_id = 1206, phiCenter = 338.597
module_even: crystal_id = 1207, phiCenter = 338.879
module_even: crystal_id = 1208, phiCenter = 339.161
module_even: crystal_id = 1209, phiCenter = 339.443
module_even: crystal_id = 1210, phiCenter = 339.725
module_even: crystal_id = 1211, phiCenter = 340.007
module_even: crystal_id = 1212, phiCenter = 340.29
module_even: crystal_id = 1213, phiCenter = 340.572
module_even: crystal_id = 1214, phiCenter = 340.854
module_even: crystal_id = 1215, phiCenter = 341.136
module_even: crystal_id = 1216, phiCenter = 341.418
module_even: crystal_id = 1217, phiCenter = 341.7
module_even: crystal_id = 1218, phiCenter = 341.982
module_even: crystal_id = 1219, phiCenter = 342.265
module_even: crystal_id = 1220, phiCenter = 342.547
module_even: crystal_id = 1221, phiCenter = 342.829
module_even: crystal_id = 1222, phiCenter = 343.111
module_even: crystal_id = 1223, phiCenter = 343.393
module_even: crystal_id = 1224, phiCenter = 343.675
module_even: crystal_id = 1225, phiCenter = 343.957
module_even: crystal_id = 1226, phiCenter = 344.239
module_even: crystal_id = 1227, phiCenter = 344.522
module_even: crystal_id = 1228, phiCenter = 344.804
module_even: crystal_id = 1229, phiCenter = 345.086
module_even: crystal_id = 1230, phiCenter = 345.368
module_even: crystal_id = 1231, phiCenter = 345.65
module_even: crystal_id = 1232, phiCenter = 345.932
module_even: crystal_id = 1233, phiCenter = 346.214
module_even: crystal_id = 1234, phiCenter = 346.497
module_even: crystal_id = 1235, phiCenter = 346.779
module_even: crystal_id = 1236, phiCenter = 347.061
module_even: crystal_id = 1237, phiCenter = 347.343
module_even: crystal_id = 1238, phiCenter = 347.625
module_even: crystal_id = 1239, phiCenter = 347.907
module_even: crystal_id = 1240, phiCenter = 348.189
module_even: crystal_id = 1241, phiCenter = 348.471
module_even: crystal_id = 1242, phiCenter = 348.754
module_even: crystal_id = 1243, phiCenter = 349.036
module_even: crystal_id = 1244, phiCenter = 349.318
module_even: crystal_id = 1245, phiCenter = 349.6
module_even: crystal_id = 1246, phiCenter = 349.882
module_even: crystal_id = 1247, phiCenter = 350.164
module_even: crystal_id = 1248, phiCenter = 350.446
module_even: crystal_id = 1249, phiCenter = 350.729
module_even: crystal_id = 1250, phiCenter = 351.011
module_even: crystal_id = 1251, phiCenter = 351.293
module_even: crystal_id = 1252, phiCenter = 351.575
module_even: crystal_id = 1253, phiCenter = 351.857
module_even: crystal_id = 1254, phiCenter = 352.139
module_even: crystal_id = 1255, phiCenter = 352.421
module_even: crystal_id = 1256, phiCenter = 352.703
module_even: crystal_id = 1257, phiCenter = 352.986
module_even: crystal_id = 1258, phiCenter = 353.268
module_even: crystal_id = 1259, phiCenter = 353.55
module_even: crystal_id = 1260, phiCenter = 353.832
module_even: crystal_id = 1261, phiCenter = 354.114
module_even: crystal_id = 1262, phiCenter = 354.396
module_even: crystal_id = 1263, phiCenter = 354.678
module_even: crystal_id = 1264, phiCenter = 354.96
module_even: crystal_id = 1265, phiCenter = 355.243
module_even: crystal_id = 1266, phiCenter = 355.525
module_even: crystal_id = 1267, phiCenter = 355.807
module_even: crystal_id = 1268, phiCenter = 356.089
module_even: crystal_id = 1269, phiCenter = 356.371
module_even: crystal_id = 1270, phiCenter = 356.653
module_even: crystal_id = 1271, phiCenter = 356.935
module_even: crystal_id = 1272, phiCenter = 357.218
module_even: crystal_id = 1273, phiCenter = 357.5
module_even: crystal_id = 1274, phiCenter = 357.782
module_even: crystal_id = 1275, phiCenter = 358.064
module_even: crystal_id = 1276, phiCenter = 358.346
module_id: 1
module_id: 2
module_id: 3
module_id: 4
module_id: 5
module_id: 6
module_id: 7
module_id: 8
module_id: 9
module_id: 10
module_id: 11
module_id: 12
module_id: 13
module_id: 14
module_id: 15
module_id: 16
module_id: 17
module_id: 18
module_id: 19
module_id: 20
module_id: 21
module_id: 22
module_id: 23
module_id: 24
module_id: 25
module_id: 26
module_id: 27
module_id: 28
module_id: 29
module_id: 30
module_id: 31
module_id: 32
module_id: 33
module_id: 34
module_id: 35
module_id: 36
module_id: 37
module_id: 38
module_id: 39
module_id: 40
module_id: 41
module_id: 42
module_id: 43
module_id: 44
module_id: 45
module_id: 46
module_id: 47
module_id: 48
module_id: 49
module_id: 50
module_id: 51
module_id: 52
module_id: 53
module_id: 54
module_id: 55
module_id: 56
module_id: 57
module_id: 58
module_id: 59
module_id: 60
module_id: 61
module_id: 62
module_id: 63
module_id: 64
module_id: 65
module_id: 66
module_id: 67
module_id: 68
module_id: 69
module_id: 70
module_id: 71
module_id: 72
module_id: 73
module_id: 74
module_id: 75
module_id: 76
module_id: 77
module_id: 78
module_id: 79
module_id: 80
module_id: 81
module_id: 82
module_id: 83
module_id: 84
module_id: 85
module_id: 86
module_id: 87
module_id: 88
module_id: 89
module_id: 90
module_id: 91
module_id: 92
module_id: 93
module_id: 94
module_id: 95
module_id: 96
module_id: 97
module_id: 98
module_id: 99
module_id: 100
module_id: 101
module_id: 102
module_id: 103
module_id: 104
module_id: 105
module_id: 106
module_id: 107
module_id: 108
module_id: 109
module_id: 110
module_id: 111
module_id: 112
module_id: 113
module_id: 114
module_id: 115
module_id: 116
module_id: 117
module_id: 118
module_id: 119
module_id: 120
module_id: 121
module_id: 122
module_id: 123
module_id: 124
module_id: 125
module_id: 126
module_id: 127
module_id: 128
module_id: 129
module_id: 130
module_id: 131
module_id: 132
module_id: 133
module_id: 134
module_id: 135
module_id: 136
module_id: 137
module_id: 138
module_id: 139
module_id: 140
module_id: 141
module_id: 142
module_id: 143
module_id: 144
module_id: 145
module_id: 146
module_id: 147
module_id: 148
module_id: 149
module_id: 150
module_id: 151
module_id: 152
module_id: 153
module_id: 154
module_id: 155
module_id: 156
module_id: 157
module_id: 158
module_id: 159
module_id: 160
module_id: 161
module_id: 162
module_id: 163
module_id: 164
module_id: 165
module_id: 166
module_id: 167
module_id: 168
module_id: 169
module_id: 170
module_id: 171
module_id: 172
module_id: 173
module_id: 174
module_id: 175
module_id: 176
module_id: 177
module_id: 178
module_id: 179
module_id: 180
module_id: 181
module_id: 182
module_id: 183
module_id: 184
module_id: 185
module_id: 186
module_id: 187
module_id: 188
module_id: 189
module_id: 190
module_id: 191
module_id: 192
module_id: 193
module_id: 194
module_id: 195
module_id: 196
module_id: 197
module_id: 198
module_id: 199
module_id: 200
module_id: 201
module_id: 202
module_id: 203
module_id: 204
module_id: 205
module_id: 206
module_id: 207
module_id: 208
module_id: 209
module_id: 210
module_id: 211
module_id: 212
module_id: 213
module_id: 214
module_id: 215
module_id: 216
module_id: 217
module_id: 218
module_id: 219
module_id: 220
module_id: 221
module_id: 222
module_id: 223
module_id: 224
module_id: 225
module_id: 226
module_id: 227
module_id: 228
module_id: 229
module_id: 230
module_id: 231
module_id: 232
module_id: 233
module_id: 234
module_id: 235
module_id: 236
module_id: 237
module_id: 238
module_id: 239
module_id: 240
module_id: 241
module_id: 242
module_id: 243
module_id: 244
module_id: 245
module_id: 246
module_id: 247
module_id: 248
module_id: 249
module_id: 250
module_id: 251
module_id: 252
module_id: 253
module_id: 254
module_id: 255
module_id: 256
module_id: 257
module_id: 258
module_id: 259
module_id: 260
module_id: 261
module_id: 262
module_id: 263
module_id: 264
module_id: 265
module_id: 266
module_id: 267
module_id: 268
module_id: 269
module_id: 270
module_id: 271
module_id: 272
module_id: 273
module_id: 274
module_id: 275
module_id: 276
module_id: 277
module_id: 278
module_id: 279
module_id: 280
module_id: 281
module_id: 282
module_id: 283
module_id: 284
module_id: 285
module_id: 286
module_id: 287
module_id: 288
module_id: 289
module_id: 290
module_id: 291
module_id: 292
module_id: 293
module_id: 294
module_id: 295
module_id: 296
module_id: 297
module_id: 298
module_id: 299
module_id: 300
module_id: 301
module_id: 302
module_id: 303
module_id: 304
module_id: 305
module_id: 306
module_id: 307
module_id: 308
module_id: 309
module_id: 310
module_id: 311
module_id: 312
module_id: 313
module_id: 314
module_id: 315
module_id: 316
module_id: 317
module_id: 318
module_id: 319
module_id: 320
module_id: 321
module_id: 322
module_id: 323
module_id: 324
module_id: 325
module_id: 326
module_id: 327
module_id: 328
module_id: 329
module_id: 330
module_id: 331
module_id: 332
module_id: 333
module_id: 334
module_id: 335
module_id: 336
module_id: 337
module_id: 338
module_id: 339
module_id: 340
module_id: 341
module_id: 342
module_id: 343
module_id: 344
module_id: 345
module_id: 346
module_id: 347
module_id: 348
module_id: 349
module_id: 350
module_id: 351
module_id: 352
module_id: 353
module_id: 354
module_id: 355
module_id: 356
module_id: 357
module_id: 358
module_id: 359
module_id: 360
module_id: 361
module_id: 362
module_id: 363
module_id: 364
module_id: 365
module_id: 366
module_id: 367
module_id: 368
module_id: 369
module_id: 370
module_id: 371
module_id: 372
module_id: 373
module_id: 374
module_id: 375
module_id: 376
module_id: 377
module_id: 378
module_id: 379
module_id: 380
module_id: 381
module_id: 382
module_id: 383
module_id: 384
module_id: 385
module_id: 386
module_id: 387
module_id: 388
module_id: 389
module_id: 390
module_id: 391
module_id: 392
module_id: 393
module_id: 394
module_id: 395
module_id: 396
module_id: 397
module_id: 398
module_id: 399
module_id: 400
module_id: 401
module_id: 402
module_id: 403
module_id: 404
module_id: 405
module_id: 406
module_id: 407
module_id: 408
module_id: 409
module_id: 410
module_id: 411
module_id: 412
module_id: 413
module_id: 414
module_id: 415
module_id: 416
module_id: 417
module_id: 418
module_id: 419
module_id: 420
module_id: 421
module_id: 422
module_id: 423
module_id: 424
module_id: 425
module_id: 426
module_id: 427
module_id: 428
module_id: 429
module_id: 430
module_id: 431
module_id: 432
module_id: 433
module_id: 434
module_id: 435
module_id: 436
module_id: 437
module_id: 438
module_id: 439
module_id: 440
module_id: 441
module_id: 442
module_id: 443
module_id: 444
module_id: 445
module_id: 446
module_id: 447
module_id: 448
module_id: 449
module_id: 450
module_id: 451
module_id: 452
module_id: 453
module_id: 454
module_id: 455
module_id: 456
module_id: 457
module_id: 458
module_id: 459
module_id: 460
module_id: 461
module_id: 462
module_id: 463
module_id: 464
module_id: 465
module_id: 466
module_id: 467
module_id: 468
module_id: 469
module_id: 470
module_id: 471
module_id: 472
module_id: 473
module_id: 474
module_id: 475
module_id: 476
module_id: 477
module_id: 478
module_id: 479
module_id: 480
module_id: 481
module_id: 482
module_id: 483
module_id: 484
module_id: 485
module_id: 486
module_id: 487
module_id: 488
module_id: 489
module_id: 490
module_id: 491
module_id: 492
module_id: 493
module_id: 494
module_id: 495
module_id: 496
module_id: 497
module_id: 498
module_id: 499
module_id: 500
module_id: 501
module_id: 502
module_id: 503
module_id: 504
module_id: 505
module_id: 506
module_id: 507
module_id: 508
module_id: 509
module_id: 510
module_id: 511
module_id: 512
module_id: 513
module_id: 514
module_id: 515
module_id: 516
module_id: 517
module_id: 518
module_id: 519
module_id: 520
module_id: 521
module_id: 522
module_id: 523
module_id: 524
module_id: 525
module_id: 526
module_id: 527
module_id: 528
module_id: 529
module_id: 530
module_id: 531
module_id: 532
module_id: 533
module_id: 534
module_id: 535
module_id: 536
module_id: 537
module_id: 538
module_id: 539
module_id: 540
module_id: 541
module_id: 542
module_id: 543
module_id: 544
module_id: 545
module_id: 546
module_id: 547
module_id: 548
module_id: 549
module_id: 550
module_id: 551
module_id: 552
module_id: 553
module_id: 554
module_id: 555
module_id: 556
module_id: 557
module_id: 558
module_id: 559
module_id: 560
module_id: 561
module_id: 562
module_id: 563
module_id: 564
module_id: 565
module_id: 566
module_id: 567
module_id: 568
module_id: 569
module_id: 570
module_id: 571
module_id: 572
module_id: 573
module_id: 574
module_id: 575
module_id: 576
module_id: 577
module_id: 578
module_id: 579
module_id: 580
module_id: 581
module_id: 582
module_id: 583
module_id: 584
module_id: 585
module_id: 586
module_id: 587
module_id: 588
module_id: 589
module_id: 590
module_id: 591
module_id: 592
module_id: 593
module_id: 594
module_id: 595
module_id: 596
module_id: 597
module_id: 598
module_id: 599
module_id: 600
module_id: 601
module_id: 602
module_id: 603
module_id: 604
module_id: 605
module_id: 606
module_id: 607
module_id: 608
module_id: 609
module_id: 610
module_id: 611
module_id: 612
module_id: 613
module_id: 614
module_id: 615
module_id: 616
module_id: 617
module_id: 618
module_id: 619
module_id: 620
module_id: 621
module_id: 622
module_id: 623
module_id: 624
module_id: 625
module_id: 626
module_id: 627
module_id: 628
module_id: 629
module_id: 630
module_id: 631
module_id: 632
module_id: 633
module_id: 634
module_id: 635
module_id: 636
module_id: 637
module_id: 638
module_id: 639
module_id: 640
module_id: 641
module_id: 642
module_id: 643
module_id: 644
module_id: 645
module_id: 646
module_id: 647
module_id: 648
module_id: 649
module_id: 650
module_id: 651
module_id: 652
module_id: 653
module_id: 654
module_id: 655
module_id: 656
module_id: 657
module_id: 658
module_id: 659
module_id: 660
module_id: 661
module_id: 662
module_id: 663
module_id: 664
module_id: 665
module_id: 666
module_id: 667
module_id: 668
module_id: 669
module_id: 670
Compact          INFO  ++ Converted subdetector:EcalBarrel of type DD4hep_RotatedCrystalCalorimeter_v01 [calorimeter]
Compact          INFO  ++ Converted field: Successfully created field InnerSolenoid [solenoid]
Compact          INFO  ++ Converted field: Successfully created field OuterSolenoid [solenoid]
TGeoManager::Ch...   INFO Fixing runtime shapes...
TGeoManager::Ch...   INFO ...Nothing to fix
TGeoManager::Cl...   INFO Counting nodes...
TGeoManager::Vo...   INFO Voxelizing...
TGeoManager::Cl...   INFO Building cache...
TGeoManager::Co...   INFO max level = 3, max placements = 1276
TGeoManager::Cl...   INFO 855592 nodes/ 6 volume UID's in Detector Geometry
TGeoManager::Cl...   INFO ----------------modeler ready----------------
Detector         INFO  +++ Patching names of anonymous shapes....
DetSimAlg            INFO Initialize DetSimAlg... 
DetSimAlg            INFO Random Seed is initialized to 257 in Geant4

**************************************************************
 Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)
                       Copyright : Geant4 Collaboration
                      References : NIM A 506 (2003), 250-303
                                 : IEEE-TNS 53 (2006), 270-278
                                 : NIM A 835 (2016), 186-225
                             WWW : http://geant4.org/
**************************************************************

G4PhysListFactory::GetReferencePhysList <QGSP_BERT>  EMoption= 0
<<< Geant4 Physics List simulation engine: QGSP_BERT


Geant4Converter  INFO  +++  Successfully converted geometry to Geant4.
ToolSvc.AnExamp...   INFO Type/Name: calorimeter/EcalBarrel
ToolSvc.AnExamp...   INFO Find the CalorimeterSensDetTool.
ToolSvc.Calorim...WARNING EcalBarrel set to merge true/false = 1
ToolSvc.AnExamp...   INFO create g4SD: 0x2162d8c0
ToolSvc.AnExamp...   INFO -> Total 1 senstive volumes are registered. 
### WARNING: ActivatePAI::GetRegion fails to find DriftChamberRegion

 hInelastic QGSP_BERT  Thresholds: 
    1) between BERT  and FTF/P over the interval 3 to 6 GeV. 
    2) between FTF/P and QGS/P over the interval 12 to 25 GeV. 
  -- quasiElastic: 1 for QGS  and 0 for FTF
### Adding tracking cuts for neutron  TimeCut(ns)= 10000  KinEnergyCut(MeV)= 0
            e+ : fastSimProcess_massGeom[geom:pWorld] 
            e- : fastSimProcess_massGeom[geom:pWorld] 
         gamma : fastSimProcess_massGeom[geom:pWorld] 
           mu- : fastSimProcess_massGeom[geom:pWorld] 
         nu_mu : fastSimProcess_massGeom[geom:pWorld] 
           pi+ : fastSimProcess_massGeom[geom:pWorld] 
           pi- : fastSimProcess_massGeom[geom:pWorld] 
           pi0 : fastSimProcess_massGeom[geom:pWorld] 
          tau+ : fastSimProcess_massGeom[geom:pWorld] 
          tau- : fastSimProcess_massGeom[geom:pWorld] 
=======================================================================
======                 Electromagnetic Physics Parameters      ========
=======================================================================
LPM effect enabled                                 1
Enable creation and use of sampling tables         0
Apply cuts on all EM processes                     0
Use combined TransportationWithMsc                 Disabled
Use general process                                1
Enable linear polarisation for gamma               0
Enable photoeffect sampling below K-shell          1
Enable sampling of quantum entanglement            0
X-section factor for integral approach             0.8
Min kinetic energy for tables                      100 eV 
Max kinetic energy for tables                      100 TeV
Number of bins per decade of a table               7
Verbose level                                      1
Verbose level for worker thread                    0
Bremsstrahlung energy threshold above which 
  primary e+- is added to the list of secondary    100 TeV
Bremsstrahlung energy threshold above which primary
  muon/hadron is added to the list of secondary    100 TeV
Lowest triplet kinetic energy                      1 MeV
Enable sampling of gamma linear polarisation       0
5D gamma conversion model type                     0
5D gamma conversion model on isolated ion          0
Livermore data directory                           epics_2017
=======================================================================
======                 Ionisation Parameters                   ========
=======================================================================
Step function for e+-                              (0.2, 1 mm)
Step function for muons/hadrons                    (0.2, 0.1 mm)
Step function for light ions                       (0.2, 0.1 mm)
Step function for general ions                     (0.2, 0.1 mm)
Lowest e+e- kinetic energy                         1 keV
Lowest muon/hadron kinetic energy                  1 keV
Use ICRU90 data                                    0
Fluctuations of dE/dx are enabled                  1
Type of fluctuation model for leptons and hadrons  Urban
Use built-in Birks satuaration                     0
Build CSDA range enabled                           0
Use cut as a final range enabled                   0
Enable angular generator interface                 0
Max kinetic energy for CSDA tables                 1 GeV
Max kinetic energy for NIEL computation            0 eV 
Linear loss limit                                  0.01
Read data from file for e+e- pair production by mu 0
=======================================================================
======                 Multiple Scattering Parameters          ========
=======================================================================
Type of msc step limit algorithm for e+-           1
Type of msc step limit algorithm for muons/hadrons 0
Msc lateral displacement for e+- enabled           1
Msc lateral displacement for muons and hadrons     0
Urban msc model lateral displacement alg96         1
Range factor for msc step limit for e+-            0.04
Range factor for msc step limit for muons/hadrons  0.2
Geometry factor for msc step limitation of e+-     2.5
Safety factor for msc step limit for e+-           0.6
Skin parameter for msc step limitation of e+-      1
Lambda limit for msc step limit for e+-            1 mm
Use Mott correction for e- scattering              0
Factor used for dynamic computation of angular 
  limit between single and multiple scattering     1
Fixed angular limit between single 
  and multiple scattering                          3.1416 rad
Upper energy limit for e+- multiple scattering     100 MeV
Type of electron single scattering model           0
Type of nuclear form-factor                        1
Screening factor                                   1
=======================================================================

phot:  for gamma SubType=12 BuildTable=0
      LambdaPrime table from 200 keV to 100 TeV in 61 bins 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
 LivermorePhElectric : Emin=    0 eV  Emax=  100 TeV  SauterGavrila Fluo

compt:  for gamma SubType=13 BuildTable=1
      Lambda table from 100 eV  to 1 MeV, 7 bins/decade, spline: 1
      LambdaPrime table from 1 MeV to 100 TeV in 56 bins 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
       Klein-Nishina : Emin=    0 eV  Emax=  100 TeV

conv:  for gamma SubType=14 BuildTable=1
      Lambda table from 1.022 MeV to 100 TeV, 18 bins/decade, spline: 1
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
     BetheHeitlerLPM : Emin=    0 eV  Emax=  100 TeV  ModifiedTsai

Rayl:  for gamma SubType=11 BuildTable=1
      Lambda table from 100 eV  to 150 keV, 7 bins/decade, spline: 0
      LambdaPrime table from 150 keV to 100 TeV in 62 bins 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
   LivermoreRayleigh : Emin=    0 eV  Emax=  100 TeV  CullenGenerator

msc:  for e-  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            UrbanMsc : Emin=    0 eV  Emax=  100 MeV Nbins=42 100 eV  - 100 MeV
          StepLim=UseSafety Rfact=0.04 Gfact=2.5 Sfact=0.6 DispFlag:1 Skin=1 Llim=1 mm
        WentzelVIUni : Emin=  100 MeV Emax=  100 TeV Nbins=42 100 MeV - 100 TeV
          StepLim=UseSafety Rfact=0.04 Gfact=2.5 Sfact=0.6 DispFlag:1 Skin=1 Llim=1 mm

eIoni:  for e-  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        MollerBhabha : Emin=    0 eV  Emax=  100 TeV

eBrem:  for e-  XStype:4  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      LPM flag: 1 for E > 1 GeV,  VertexHighEnergyTh(GeV)= 100000
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
             eBremSB : Emin=    0 eV  Emax=    1 GeV  ModifiedTsai
            eBremLPM : Emin=    1 GeV Emax=  100 TeV  ModifiedTsai

CoulombScat:  for e- XStype:1 SubType=1 BuildTable=1
      Lambda table from 100 MeV to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=  100 MeV Emax=  100 TeV

msc:  for e+  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            UrbanMsc : Emin=    0 eV  Emax=  100 MeV Nbins=42 100 eV  - 100 MeV
          StepLim=UseSafety Rfact=0.04 Gfact=2.5 Sfact=0.6 DispFlag:1 Skin=1 Llim=1 mm
        WentzelVIUni : Emin=  100 MeV Emax=  100 TeV Nbins=42 100 MeV - 100 TeV
          StepLim=UseSafety Rfact=0.04 Gfact=2.5 Sfact=0.6 DispFlag:1 Skin=1 Llim=1 mm

eIoni:  for e+  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        MollerBhabha : Emin=    0 eV  Emax=  100 TeV

eBrem:  for e+  XStype:4  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      LPM flag: 1 for E > 1 GeV,  VertexHighEnergyTh(GeV)= 100000
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
             eBremSB : Emin=    0 eV  Emax=    1 GeV  ModifiedTsai
            eBremLPM : Emin=    1 GeV Emax=  100 TeV  ModifiedTsai

annihil:  for e+ XStype:2 SubType=5 BuildTable=0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            eplus2gg : Emin=    0 eV  Emax=  100 TeV

CoulombScat:  for e+ XStype:1 SubType=1 BuildTable=1
      Lambda table from 100 MeV to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=  100 MeV Emax=  100 TeV

msc:  for proton  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for proton  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               Bragg : Emin=    0 eV  Emax=    2 MeV
          BetheBloch : Emin=    2 MeV Emax=  100 TeV

hBrems:  for proton  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for proton  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 17x1001; from 7.50618 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for proton XStype:1 SubType=1 BuildTable=1
      Lambda table from threshold  to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for GenericIon  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            UrbanMsc : Emin=    0 eV  Emax=  100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

ionIoni:  for GenericIon  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.02
      Stopping Power data for 17 ion/material pairs
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            BraggIon : Emin=    0 eV  Emax=    2 MeV
          BetheBloch : Emin=    2 MeV Emax=  100 TeV

msc:  for alpha  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            UrbanMsc : Emin=    0 eV  Emax=  100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

ionIoni:  for alpha  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.02
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            BraggIon : Emin=    0 eV  Emax=7.9452 MeV
          BetheBloch : Emin=7.9452 MeV Emax=  100 TeV

msc:  for anti_proton  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for anti_proton  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            ICRU73QO : Emin=    0 eV  Emax=    2 MeV
          BetheBloch : Emin=    2 MeV Emax=  100 TeV

hBrems:  for anti_proton  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for anti_proton  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 17x1001; from 7.50618 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for anti_proton XStype:1 SubType=1 BuildTable=1
      Lambda table from threshold  to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for kaon+  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for kaon+  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               Bragg : Emin=    0 eV  Emax=1.05231 MeV
          BetheBloch : Emin=1.05231 MeV Emax=  100 TeV

hBrems:  for kaon+  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for kaon+  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 18x1001; from 3.94942 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for kaon+ XStype:1 SubType=1 BuildTable=1
      Lambda table from threshold  to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for kaon-  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for kaon-  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            ICRU73QO : Emin=    0 eV  Emax=1.05231 MeV
          BetheBloch : Emin=1.05231 MeV Emax=  100 TeV

hBrems:  for kaon-  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for kaon-  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 18x1001; from 3.94942 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for kaon- XStype:1 SubType=1 BuildTable=1
      Used Lambda table of kaon+
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for mu+  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

muIoni:  for mu+  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               Bragg : Emin=    0 eV  Emax=  200 keV
        MuBetheBloch : Emin=  200 keV Emax=  100 TeV

muBrems:  for mu+  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
              MuBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

muPairProd:  for mu+  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 21x1001; from 0.85 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
          muPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for mu+ XStype:1 SubType=1 BuildTable=1
      Lambda table from threshold  to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for mu-  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

muIoni:  for mu-  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            ICRU73QO : Emin=    0 eV  Emax=  200 keV
        MuBetheBloch : Emin=  200 keV Emax=  100 TeV

muBrems:  for mu-  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
              MuBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

muPairProd:  for mu-  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 21x1001; from 0.85 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
          muPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for mu- XStype:1 SubType=1 BuildTable=1
      Used Lambda table of mu+
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for pi+  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for pi+  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               Bragg : Emin=    0 eV  Emax=297.505 keV
          BetheBloch : Emin=297.505 keV Emax=  100 TeV

hBrems:  for pi+  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for pi+  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 20x1001; from 1.11656 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for pi+ XStype:1 SubType=1 BuildTable=1
      Lambda table from threshold  to 100 TeV, 7 bins/decade, spline: 0
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

msc:  for pi-  SubType= 10
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
        WentzelVIUni : Emin=    0 eV  Emax=  100 TeV Nbins=84 100 eV  - 100 TeV
          StepLim=Minimal Rfact=0.2 Gfact=2.5 Sfact=0.6 DispFlag:0 Skin=1 Llim=1 mm

hIoni:  for pi-  XStype:3  SubType=2
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 1
      StepFunction=(0.2, 0.1 mm), integ: 3, fluct: 1, linLossLim= 0.01
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
            ICRU73QO : Emin=    0 eV  Emax=297.505 keV
          BetheBloch : Emin=297.505 keV Emax=  100 TeV

hBrems:  for pi-  XStype:1  SubType=3
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
               hBrem : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

hPairProd:  for pi-  XStype:1  SubType=4
      dE/dx and range tables from 100 eV  to 100 TeV in 84 bins
      Lambda tables from threshold to 100 TeV, 7 bins/decade, spline: 0
      Sampling table 20x1001; from 1.11656 GeV to 100 TeV 
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
           hPairProd : Emin=    0 eV  Emax=  100 TeV  ModifiedMephi

CoulombScat:  for pi- XStype:1 SubType=1 BuildTable=1
      Used Lambda table of pi+
      ThetaMin(p) < Theta(degree) < 180; pLimit(GeV^1)= 0.139531
      ===== EM models for the G4Region  DefaultRegionForTheWorld ======
  eCoulombScattering : Emin=    0 eV  Emax=  100 TeV

====================================================================
                  HADRONIC PROCESSES SUMMARY (verbose level 1)

---------------------------------------------------
                           Hadronic Processes for neutron

  Process: hadElastic
        Model:             hElasticCHIPS: 0 eV  ---> 100 TeV
     Cr_sctns:        G4NeutronElasticXS: 0 eV  ---> 100 TeV


  Process: neutronInelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:      G4NeutronInelasticXS: 0 eV  ---> 100 TeV


  Process: nCapture
        Model:               nRadCapture: 0 eV  ---> 100 TeV
     Cr_sctns:        G4NeutronCaptureXS: 0 eV  ---> 100 TeV


  Process: nKiller

---------------------------------------------------
                           Hadronic Processes for B-

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: B-Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 0 eV  ---> 25 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for D-

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: D-Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 0 eV  ---> 25 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for GenericIon

  Process: ionInelastic
        Model:  Binary Light Ion Cascade: 0 eV /n ---> 6 GeV/n
        Model:                      FTFP: 3 GeV/n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


---------------------------------------------------
                           Hadronic Processes for He3

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


  Process: He3Inelastic
        Model:  Binary Light Ion Cascade: 0 eV /n ---> 6 GeV/n
        Model:                      FTFP: 3 GeV/n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


---------------------------------------------------
                           Hadronic Processes for alpha

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


  Process: alphaInelastic
        Model:  Binary Light Ion Cascade: 0 eV /n ---> 6 GeV/n
        Model:                      FTFP: 3 GeV/n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


---------------------------------------------------
                           Hadronic Processes for anti_He3

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100.1 MeV/n
        Model:              AntiAElastic: 100 MeV/n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_He3Inelastic
        Model:                      FTFP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_alpha

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100.1 MeV/n
        Model:              AntiAElastic: 100 MeV/n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_alphaInelastic
        Model:                      FTFP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_deuteron

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100.1 MeV/n
        Model:              AntiAElastic: 100 MeV/n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_deuteronInelastic
        Model:                      FTFP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_hypertriton

  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_lambda

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: anti_lambdaInelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 0 eV  ---> 25 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_neutron

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100.1 MeV
        Model:              AntiAElastic: 100 MeV ---> 100 TeV
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_neutronInelastic
        Model:                      FTFP: 0 eV  ---> 100 TeV
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_proton

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100.1 MeV
        Model:              AntiAElastic: 100 MeV ---> 100 TeV
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_protonInelastic
        Model:                      FTFP: 0 eV  ---> 100 TeV
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for anti_triton

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100.1 MeV/n
        Model:              AntiAElastic: 100 MeV/n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: anti_tritonInelastic
        Model:                      FTFP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:              AntiAGlauber: 0 eV  ---> 25.6 PeV


  Process: hFritiofCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for deuteron

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


  Process: dInelastic
        Model:  Binary Light Ion Cascade: 0 eV /n ---> 6 GeV/n
        Model:                      FTFP: 3 GeV/n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


---------------------------------------------------
                           Hadronic Processes for e+

  Process: positronNuclear
        Model:   G4ElectroVDNuclearModel: 0 eV  ---> 1 PeV
     Cr_sctns:          ElectroNuclearXS: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for e-

  Process: electronNuclear
        Model:   G4ElectroVDNuclearModel: 0 eV  ---> 1 PeV
     Cr_sctns:          ElectroNuclearXS: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for gamma

  Process: photonNuclear
        Model:               GammaNPreco: 0 eV  ---> 200 MeV
        Model:            BertiniCascade: 199 MeV ---> 6 GeV
        Model:           TheoFSGenerator: 3 GeV ---> 100 TeV
     Cr_sctns:            GammaNuclearXS: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for kaon+

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: kaon+Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for kaon-

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: kaon-Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: hBertiniCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for lambda

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: lambdaInelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for mu+

  Process: muonNuclear
        Model:      G4MuonVDNuclearModel: 0 eV  ---> 1 PeV
     Cr_sctns:     KokoulinMuonNuclearXS: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for mu-

  Process: muonNuclear
        Model:      G4MuonVDNuclearModel: 0 eV  ---> 1 PeV
     Cr_sctns:     KokoulinMuonNuclearXS: 0 eV  ---> 100 TeV


  Process: muMinusCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for pi+

  Process: hadElastic
        Model:           hElasticGlauber: 0 eV  ---> 100 TeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


  Process: pi+Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for pi-

  Process: hadElastic
        Model:           hElasticGlauber: 0 eV  ---> 100 TeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


  Process: pi-Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


  Process: hBertiniCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for proton

  Process: hadElastic
        Model:             hElasticCHIPS: 0 eV  ---> 100 TeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


  Process: protonInelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:  BarashenkovGlauberGribov: 0 eV  ---> 100 TeV


---------------------------------------------------
                           Hadronic Processes for sigma-

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV  ---> 100 TeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: sigma-Inelastic
        Model:                      QGSP: 12 GeV ---> 100 TeV
        Model:                      FTFP: 3 GeV ---> 25 GeV
        Model:            BertiniCascade: 0 eV  ---> 6 GeV
     Cr_sctns:            Glauber-Gribov: 0 eV  ---> 100 TeV


  Process: hBertiniCaptureAtRest

---------------------------------------------------
                           Hadronic Processes for triton

  Process: hadElastic
        Model:              hElasticLHEP: 0 eV /n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


  Process: tInelastic
        Model:  Binary Light Ion Cascade: 0 eV /n ---> 6 GeV/n
        Model:                      FTFP: 3 GeV/n ---> 100 TeV/n
     Cr_sctns:  Glauber-Gribov Nucl-nucl: 0 eV  ---> 25.6 PeV


================================================================
=======================================================================
======       Pre-compound/De-excitation Physics Parameters     ========
=======================================================================
Type of pre-compound inverse x-section              3
Pre-compound model active                           1
Pre-compound excitation low energy                  100 keV
Pre-compound excitation high energy                 30 MeV
Type of de-excitation inverse x-section             3
Type of de-excitation factory                       Evaporation+GEM
Number of de-excitation channels                    68
Min excitation energy                               10 eV 
Min energy per nucleon for multifragmentation       200 GeV
Limit excitation energy for Fermi BreakUp           20 MeV
Level density (1/MeV)                               0.075
Use simple level density model                      1
Use discrete excitation energy of the residual      1
Time limit for long lived isomeres                  1 ns 
Isomer production flag                              1
Internal e- conversion flag                         1
Store e- internal conversion data                   0
Correlated gamma emission flag                      0
Max 2J for sampling of angular correlations         10
=======================================================================
Begin Run of detector simultion...
ToolSvc.Edm4hep...   INFO Tracker Region  R: 1723 Z: 2980
EventLoopMgr      WARNING Unable to locate service "EventSelector" 
EventLoopMgr      WARNING No events will be processed from external input.
ApplicationMgr       INFO Application Manager Initialized successfully
ApplicationMgr       INFO Application Manager Started successfully
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.28212, px=9.1152,py=1.75242,pz=5.68366e-16,theta=90,phi=10.8825
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.04141, px=1.01848,py=0.217338,pz=6.37682e-17,theta=90,phi=12.0459
DetSimAlg.G4Pri...   INFO Start a new event 0
ToolSvc.Edm4hep...   INFO Event 0
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 844 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 844 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
TInterpreter::A...  ERROR Error parsing payload code for class edm4hep::SimTrackerHitData with content:

#line 1 "libedm4hepDict dictionary payload"

#ifndef PODIO_JSON_OUTPUT
  #define PODIO_JSON_OUTPUT 1
#endif
#ifndef JSON_USE_IMPLICIT_CONVERSIONS
  #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif
#ifndef JSON_DIAGNOSTICS
  #define JSON_DIAGNOSTICS 0
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3f_H
#define EDM4HEP_Vector3f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3f
 *  
 *  @author: 
 */
class Vector3f {
public:
  float x{};
  float y{};
  float z{};

 constexpr Vector3f() : x(0),y(0),z(0) {}
 constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr float operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3d_H
#define EDM4HEP_Vector3d_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3d
 *  
 *  @author: 
 */
class Vector3d {
public:
  double x{};
  double y{};
  double z{};

 constexpr Vector3d() : x(0),y(0),z(0) {}
 constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr double operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3d& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3d& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2i_H
#define EDM4HEP_Vector2i_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2i
 *  
 *  @author: 
 */
class Vector2i {
public:
  std::int32_t a{};
  std::int32_t b{};

 constexpr Vector2i() : a(0),b(0) {}
 constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}
 constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }
 constexpr int operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2i& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2i& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2f_H
#define EDM4HEP_Vector2f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2f
 *  
 *  @author: 
 */
class Vector2f {
public:
  float a{};
  float b{};

 constexpr Vector2f() : a(0),b(0) {}
 constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}
 constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }
 constexpr float operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackState_H
#define EDM4HEP_TrackState_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class TrackState
 *  
 *  @author: 
 */
class TrackState {
public:
  std::int32_t location{}; ///< for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
  float D0{}; ///< transverse impact parameter
  float phi{}; ///< azimuthal angle
  float omega{}; ///< is the signed curvature of the track in [1/mm].
  float Z0{}; ///< longitudinal impact parameter
  float tanLambda{}; ///< lambda is the dip angle of the track in r-z
  float time{}; ///< time of the track at this trackstate
  ::edm4hep::Vector3f referencePoint{}; ///< Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
  std::array<float, 21> covMatrix{}; ///< lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.

 static const int AtOther = 0 ; // any location other than the ones defined below
 static const int AtIP = 1 ;
 static const int AtFirstHit = 2 ;
 static const int AtLastHit = 3 ;
 static const int AtCalorimeter = 4 ;
 static const int AtVertex = 5 ;
 static const int LastLocation = AtVertex  ;
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::TrackState& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackState& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ObjectID_H
#define EDM4HEP_ObjectID_H

#include <podio/ObjectID.h>
#include <cstdint>
#include <podio/ObjectID.h>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class ObjectID
 *  
 *  @author: 
 */
class ObjectID {
public:
  std::int32_t index{};
  std::int32_t collectionID{};

 ObjectID() = default;
 ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::ObjectID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ObjectID& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Quantity_H
#define EDM4HEP_Quantity_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Quantity
 *  
 *  @author: 
 */
class Quantity {
public:
  std::int16_t type{}; ///< flag identifying how to interpret the quantity
  float value{}; ///< value of the quantity
  float error{}; ///< error on the value of the quantity


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Quantity& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Quantity& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Hypothesis_H
#define EDM4HEP_Hypothesis_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Hypothesis
 *  
 *  @author: 
 */
class Hypothesis {
public:
  float chi2{}; ///< chi2
  float expected{}; ///< expected value
  float sigma{}; ///< sigma value


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Hypothesis& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Hypothesis& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_HitLevelData_H
#define EDM4HEP_HitLevelData_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class HitLevelData
 *  
 *  @author: 
 */
class HitLevelData {
public:
  std::uint64_t cellID{}; ///< cell id
  std::uint32_t N{}; ///< number of reconstructed ionization cluster.
  float eDep{}; ///< reconstructed energy deposit [GeV].
  float pathLength{}; ///< track path length [mm].


};

std::ostream& operator<<(std::ostream& o, const edm4hep::HitLevelData& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const HitLevelData& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderDATA_H
#define EDM4HEP_EventHeaderDATA_H

#include <cstdint>

namespace edm4hep {


/** @class EventHeaderData
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeaderData {
public:
  std::int32_t eventNumber{}; ///< event number
  std::int32_t runNumber{}; ///< run number
  std::uint64_t timeStamp{}; ///< time stamp
  float weight{}; ///< event weight

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_H
#define EDM4HEP_EventHeader_H

#include "edm4hep/EventHeaderObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableEventHeader;
class EventHeaderCollection;

/** @class EventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeader {

  friend class MutableEventHeader;
  friend class EventHeaderCollection;
  friend class EventHeaderCollectionIterator;

public:
  using mutable_type = MutableEventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  EventHeader();
  EventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  EventHeader(EventHeaderObj* obj);

  /// copy constructor
  EventHeader(const EventHeader& other);

  /// copy-assignment operator
  EventHeader& operator=(EventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~EventHeader();


public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const EventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableEventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const EventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(EventHeader& a, EventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const EventHeader& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableEventHeader_H
#define EDM4HEP_MutableEventHeader_H

#include "edm4hep/EventHeaderObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/EventHeader.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableEventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class MutableEventHeader {

  friend class EventHeaderCollection;
  friend class EventHeaderMutableCollectionIterator;
  friend class EventHeader;

public:
  using object_type = EventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  MutableEventHeader();
  MutableEventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  MutableEventHeader(EventHeaderObj* obj);

  /// copy constructor
  MutableEventHeader(const MutableEventHeader& other);

  /// copy-assignment operator
  MutableEventHeader& operator=(MutableEventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~MutableEventHeader();

  /// conversion to const object
  operator EventHeader() const;

public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;



  /// Set the event number
  void setEventNumber(std::int32_t value);

  /// Set the run number
  void setRunNumber(std::int32_t value);

  /// Set the time stamp
  void setTimeStamp(std::uint64_t value);

  /// Set the event weight
  void setWeight(float value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableEventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const EventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableEventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableEventHeader& a, MutableEventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableEventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderOBJ_H
#define EDM4HEP_EventHeaderOBJ_H

// data model specific includes
#include "edm4hep/EventHeaderData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class EventHeader;

class EventHeaderObj : public podio::ObjBase {
public:
  /// constructor
  EventHeaderObj();
  /// copy constructor (does a deep-copy of relation containers)
  EventHeaderObj(const EventHeaderObj&);
  /// constructor from ObjectID and EventHeaderData
  /// does not initialize the internal relation containers
  EventHeaderObj(const podio::ObjectID id, EventHeaderData data);
  /// No assignment operator
  EventHeaderObj& operator=(const EventHeaderObj&) = delete;
  virtual ~EventHeaderObj() = default;

public:
  EventHeaderData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_CollectionData_H
#define EDM4HEP_EventHeader_CollectionData_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeaderObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using EventHeaderObjPointerContainer = std::deque<EventHeaderObj*>;
using EventHeaderDataContainer = std::vector<EventHeaderData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class EventHeaderCollectionData {
public:
  /**
   * The Objs of this collection
   */
  EventHeaderObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  EventHeaderCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  EventHeaderCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  EventHeaderCollectionData(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData& operator=(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData(EventHeaderCollectionData&& other) = default;
  EventHeaderCollectionData& operator=(EventHeaderCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~EventHeaderCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<EventHeaderDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleDATA_H
#define EDM4HEP_MCParticleDATA_H

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class MCParticleData
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticleData {
public:
  std::int32_t PDG{}; ///< PDG code of the particle
  std::int32_t generatorStatus{}; ///< status of the particle as defined by the generator
  std::int32_t simulatorStatus{}; ///< status of the particle from the simulation program - use BIT constants below
  float charge{}; ///< particle charge
  float time{}; ///< creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  double mass{}; ///< mass of the particle in [GeV]
  ::edm4hep::Vector3d vertex{}; ///< production vertex of the particle in [mm].
  ::edm4hep::Vector3d endpoint{}; ///< endpoint of the particle in [mm]
  ::edm4hep::Vector3f momentum{}; ///< particle 3-momentum at the production vertex in [GeV]
  ::edm4hep::Vector3f momentumAtEndpoint{}; ///< particle 3-momentum at the endpoint in [GeV]
  ::edm4hep::Vector3f spin{}; ///< spin (helicity) vector of the particle.
  ::edm4hep::Vector2i colorFlow{}; ///< color flow as defined by the generator

  unsigned int parents_begin{};
  unsigned int parents_end{};
  unsigned int daughters_begin{};
  unsigned int daughters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_H
#define EDM4HEP_MCParticle_H

#include "edm4hep/MCParticleObj.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableMCParticle;
class MCParticleCollection;

/** @class MCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticle {

  friend class MutableMCParticle;
  friend class MCParticleCollection;
  friend class MCParticleCollectionIterator;

public:
  using mutable_type = MutableMCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MCParticle();
  MCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MCParticle(MCParticleObj* obj);

  /// copy constructor
  MCParticle(const MCParticle& other);

  /// copy-assignment operator
  MCParticle& operator=(MCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MCParticle();


public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCParticle& a, MCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCParticle_H
#define EDM4HEP_MutableMCParticle_H

#include "edm4hep/MCParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCParticle.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableMCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MutableMCParticle {

  friend class MCParticleCollection;
  friend class MCParticleMutableCollectionIterator;
  friend class MCParticle;

public:
  using object_type = MCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MutableMCParticle();
  MutableMCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MutableMCParticle(MCParticleObj* obj);

  /// copy constructor
  MutableMCParticle(const MutableMCParticle& other);

  /// copy-assignment operator
  MutableMCParticle& operator=(MutableMCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MutableMCParticle();

  /// conversion to const object
  operator MCParticle() const;

public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  /// Set the PDG code of the particle
  void setPDG(std::int32_t value);

  /// Set the status of the particle as defined by the generator
  void setGeneratorStatus(std::int32_t value);

  /// Set the status of the particle from the simulation program - use BIT constants below
  void setSimulatorStatus(std::int32_t value);

  /// Set the particle charge
  void setCharge(float value);

  /// Set the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  void setTime(float value);

  /// Set the mass of the particle in [GeV]
  void setMass(double value);

  /// Set the production vertex of the particle in [mm].
  void setVertex(edm4hep::Vector3d value);
  /// Get reference to production vertex of the particle in [mm].
  edm4hep::Vector3d& vertex();

  /// Set the endpoint of the particle in [mm]
  void setEndpoint(edm4hep::Vector3d value);
  /// Get reference to endpoint of the particle in [mm]
  edm4hep::Vector3d& endpoint();

  /// Set the particle 3-momentum at the production vertex in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the production vertex in [GeV]
  edm4hep::Vector3f& momentum();

  /// Set the particle 3-momentum at the endpoint in [GeV]
  void setMomentumAtEndpoint(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the endpoint in [GeV]
  edm4hep::Vector3f& momentumAtEndpoint();

  /// Set the spin (helicity) vector of the particle.
  void setSpin(edm4hep::Vector3f value);
  /// Get reference to spin (helicity) vector of the particle.
  edm4hep::Vector3f& spin();

  /// Set the color flow as defined by the generator
  void setColorFlow(edm4hep::Vector2i value);
  /// Get reference to color flow as defined by the generator
  edm4hep::Vector2i& colorFlow();



  void addToParents(edm4hep::MCParticle);
  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  void addToDaughters(edm4hep::MCParticle);
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               
 void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  		     
 void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  			     
 void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } 
 void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  		     
 void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  		     
 void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  			     
 void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  				     
 void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCParticle& a, MutableMCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleOBJ_H
#define EDM4HEP_MCParticleOBJ_H

// data model specific includes
#include "edm4hep/MCParticleData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class MCParticle;

class MCParticleObj : public podio::ObjBase {
public:
  /// constructor
  MCParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCParticleObj(const MCParticleObj&);
  /// constructor from ObjectID and MCParticleData
  /// does not initialize the internal relation containers
  MCParticleObj(const podio::ObjectID id, MCParticleData data);
  /// No assignment operator
  MCParticleObj& operator=(const MCParticleObj&) = delete;
  virtual ~MCParticleObj();

public:
  MCParticleData data;
  std::vector<edm4hep::MCParticle>* m_parents{nullptr};
  std::vector<edm4hep::MCParticle>* m_daughters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_CollectionData_H
#define EDM4HEP_MCParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticleObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCParticleObjPointerContainer = std::deque<MCParticleObj*>;
using MCParticleDataContainer = std::vector<MCParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCParticleCollectionData(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData& operator=(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData(MCParticleCollectionData&& other) = default;
  MCParticleCollectionData& operator=(MCParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(MCParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_parents;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_parents_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::MCParticle> m_rel_daughters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_daughters_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitDATA_H
#define EDM4HEP_SimTrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimTrackerHitData
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float EDep{}; ///< energy deposited in the hit [GeV].
  float time{}; ///< proper time of the hit in the lab frame in [ns].
  float pathLength{}; ///< path length of the particle in the sensitive material that resulted in this hit.
  std::int32_t quality{}; ///< quality bit flag.
  ::edm4hep::Vector3d position{}; ///< the hit position in [mm].
  ::edm4hep::Vector3f momentum{}; ///< the 3-momentum of the particle at the hits position in [GeV]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_H
#define EDM4HEP_SimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimTrackerHit;
class SimTrackerHitCollection;

/** @class SimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHit {

  friend class MutableSimTrackerHit;
  friend class SimTrackerHitCollection;
  friend class SimTrackerHitCollectionIterator;

public:
  using mutable_type = MutableSimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  SimTrackerHit();
  SimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  SimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  SimTrackerHit(const SimTrackerHit& other);

  /// copy-assignment operator
  SimTrackerHit& operator=(SimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~SimTrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimTrackerHit& a, SimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimTrackerHit_H
#define EDM4HEP_MutableSimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimTrackerHit.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableSimTrackerHit {

  friend class SimTrackerHitCollection;
  friend class SimTrackerHitMutableCollectionIterator;
  friend class SimTrackerHit;

public:
  using object_type = SimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  MutableSimTrackerHit();
  MutableSimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  MutableSimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  MutableSimTrackerHit(const MutableSimTrackerHit& other);

  /// copy-assignment operator
  MutableSimTrackerHit& operator=(MutableSimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~MutableSimTrackerHit();

  /// conversion to const object
  operator SimTrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy deposited in the hit [GeV].
  void setEDep(float value);

  /// Set the proper time of the hit in the lab frame in [ns].
  void setTime(float value);

  /// Set the path length of the particle in the sensitive material that resulted in this hit.
  void setPathLength(float value);

  /// Set the quality bit flag.
  void setQuality(std::int32_t value);

  /// Set the the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the the 3-momentum of the particle at the hits position in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to the 3-momentum of the particle at the hits position in [GeV]
  edm4hep::Vector3f& momentum();


  /// Set the MCParticle that caused the hit.
  void setMCParticle(edm4hep::MCParticle value);


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }
 void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }
 void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimTrackerHit& a, MutableSimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitOBJ_H
#define EDM4HEP_SimTrackerHitOBJ_H

// data model specific includes
#include "edm4hep/SimTrackerHitData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimTrackerHit;

class SimTrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  SimTrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimTrackerHitObj(const SimTrackerHitObj&);
  /// constructor from ObjectID and SimTrackerHitData
  /// does not initialize the internal relation containers
  SimTrackerHitObj(const podio::ObjectID id, SimTrackerHitData data);
  /// No assignment operator
  SimTrackerHitObj& operator=(const SimTrackerHitObj&) = delete;
  virtual ~SimTrackerHitObj();

public:
  SimTrackerHitData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_CollectionData_H
#define EDM4HEP_SimTrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimTrackerHitObjPointerContainer = std::deque<SimTrackerHitObj*>;
using SimTrackerHitDataContainer = std::vector<SimTrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimTrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimTrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimTrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimTrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimTrackerHitCollectionData(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData& operator=(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData(SimTrackerHitCollectionData&& other) = default;
  SimTrackerHitCollectionData& operator=(SimTrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimTrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimTrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionDATA_H
#define EDM4HEP_CaloHitContributionDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CaloHitContributionData
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContributionData {
public:
  std::int32_t PDG{}; ///< PDG code of the shower particle that caused this contribution.
  float energy{}; ///< energy in [GeV] of the this contribution
  float time{}; ///< time in [ns] of this contribution
  ::edm4hep::Vector3f stepPosition{}; ///< position of this energy deposition (step) [mm]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_H
#define EDM4HEP_CaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableCaloHitContribution;
class CaloHitContributionCollection;

/** @class CaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContribution {

  friend class MutableCaloHitContribution;
  friend class CaloHitContributionCollection;
  friend class CaloHitContributionCollectionIterator;

public:
  using mutable_type = MutableCaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  CaloHitContribution();
  CaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  CaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  CaloHitContribution(const CaloHitContribution& other);

  /// copy-assignment operator
  CaloHitContribution& operator=(CaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~CaloHitContribution();


public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CaloHitContribution& a, CaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CaloHitContribution& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCaloHitContribution_H
#define EDM4HEP_MutableCaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CaloHitContribution.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableCaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class MutableCaloHitContribution {

  friend class CaloHitContributionCollection;
  friend class CaloHitContributionMutableCollectionIterator;
  friend class CaloHitContribution;

public:
  using object_type = CaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  MutableCaloHitContribution();
  MutableCaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  MutableCaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  MutableCaloHitContribution(const MutableCaloHitContribution& other);

  /// copy-assignment operator
  MutableCaloHitContribution& operator=(MutableCaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~MutableCaloHitContribution();

  /// conversion to const object
  operator CaloHitContribution() const;

public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;

  /// Set the PDG code of the shower particle that caused this contribution.
  void setPDG(std::int32_t value);

  /// Set the energy in [GeV] of the this contribution
  void setEnergy(float value);

  /// Set the time in [ns] of this contribution
  void setTime(float value);

  /// Set the position of this energy deposition (step) [mm]
  void setStepPosition(edm4hep::Vector3f value);
  /// Get reference to position of this energy deposition (step) [mm]
  edm4hep::Vector3f& stepPosition();


  /// Set the primary MCParticle that caused the shower responsible for this contribution to the hit.
  void setParticle(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const CaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCaloHitContribution& a, MutableCaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionOBJ_H
#define EDM4HEP_CaloHitContributionOBJ_H

// data model specific includes
#include "edm4hep/CaloHitContributionData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class CaloHitContribution;

class CaloHitContributionObj : public podio::ObjBase {
public:
  /// constructor
  CaloHitContributionObj();
  /// copy constructor (does a deep-copy of relation containers)
  CaloHitContributionObj(const CaloHitContributionObj&);
  /// constructor from ObjectID and CaloHitContributionData
  /// does not initialize the internal relation containers
  CaloHitContributionObj(const podio::ObjectID id, CaloHitContributionData data);
  /// No assignment operator
  CaloHitContributionObj& operator=(const CaloHitContributionObj&) = delete;
  virtual ~CaloHitContributionObj();

public:
  CaloHitContributionData data;
  edm4hep::MCParticle* m_particle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_CollectionData_H
#define EDM4HEP_CaloHitContribution_CollectionData_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CaloHitContributionObjPointerContainer = std::deque<CaloHitContributionObj*>;
using CaloHitContributionDataContainer = std::vector<CaloHitContributionData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CaloHitContributionCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CaloHitContributionObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CaloHitContributionCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CaloHitContributionCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CaloHitContributionCollectionData(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData& operator=(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData(CaloHitContributionCollectionData&& other) = default;
  CaloHitContributionCollectionData& operator=(CaloHitContributionCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CaloHitContributionCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_particle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CaloHitContributionDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitDATA_H
#define EDM4HEP_SimCalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimCalorimeterHitData
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float energy{}; ///< energy of the hit in [GeV].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].

  unsigned int contributions_begin{};
  unsigned int contributions_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_H
#define EDM4HEP_SimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableSimCalorimeterHit;
class SimCalorimeterHitCollection;

/** @class SimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHit {

  friend class MutableSimCalorimeterHit;
  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableSimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  SimCalorimeterHit();
  SimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  SimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  SimCalorimeterHit(const SimCalorimeterHit& other);

  /// copy-assignment operator
  SimCalorimeterHit& operator=(SimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~SimCalorimeterHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimCalorimeterHit& a, SimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimCalorimeterHit_H
#define EDM4HEP_MutableSimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimCalorimeterHit.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableSimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableSimCalorimeterHit {

  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitMutableCollectionIterator;
  friend class SimCalorimeterHit;

public:
  using object_type = SimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  MutableSimCalorimeterHit();
  MutableSimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  MutableSimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  MutableSimCalorimeterHit(const MutableSimCalorimeterHit& other);

  /// copy-assignment operator
  MutableSimCalorimeterHit& operator=(MutableSimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~MutableSimCalorimeterHit();

  /// conversion to const object
  operator SimCalorimeterHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();



  void addToContributions(edm4hep::CaloHitContribution);
  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimCalorimeterHit& a, MutableSimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitOBJ_H
#define EDM4HEP_SimCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/CaloHitContribution.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class SimCalorimeterHit;

class SimCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  SimCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimCalorimeterHitObj(const SimCalorimeterHitObj&);
  /// constructor from ObjectID and SimCalorimeterHitData
  /// does not initialize the internal relation containers
  SimCalorimeterHitObj(const podio::ObjectID id, SimCalorimeterHitData data);
  /// No assignment operator
  SimCalorimeterHitObj& operator=(const SimCalorimeterHitObj&) = delete;
  virtual ~SimCalorimeterHitObj();

public:
  SimCalorimeterHitData data;
  std::vector<edm4hep::CaloHitContribution>* m_contributions{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_CollectionData_H
#define EDM4HEP_SimCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/CaloHitContribution.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimCalorimeterHitObjPointerContainer = std::deque<SimCalorimeterHitObj*>;
using SimCalorimeterHitDataContainer = std::vector<SimCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimCalorimeterHitCollectionData(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData& operator=(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData(SimCalorimeterHitCollectionData&& other) = default;
  SimCalorimeterHitCollectionData& operator=(SimCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimCalorimeterHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CaloHitContribution> m_rel_contributions;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CaloHitContribution>> m_rel_contributions_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitDATA_H
#define EDM4HEP_RawCalorimeterHitDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawCalorimeterHitData
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  std::int32_t amplitude{}; ///< amplitude of the hit in ADC counts.
  std::int32_t timeStamp{}; ///< time stamp for the hit.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_H
#define EDM4HEP_RawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawCalorimeterHit;
class RawCalorimeterHitCollection;

/** @class RawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHit {

  friend class MutableRawCalorimeterHit;
  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableRawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  RawCalorimeterHit();
  RawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  RawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  RawCalorimeterHit(const RawCalorimeterHit& other);

  /// copy-assignment operator
  RawCalorimeterHit& operator=(RawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~RawCalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawCalorimeterHit& a, RawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawCalorimeterHit_H
#define EDM4HEP_MutableRawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawCalorimeterHit.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableRawCalorimeterHit {

  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitMutableCollectionIterator;
  friend class RawCalorimeterHit;

public:
  using object_type = RawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  MutableRawCalorimeterHit();
  MutableRawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  MutableRawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  MutableRawCalorimeterHit(const MutableRawCalorimeterHit& other);

  /// copy-assignment operator
  MutableRawCalorimeterHit& operator=(MutableRawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~MutableRawCalorimeterHit();

  /// conversion to const object
  operator RawCalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the amplitude of the hit in ADC counts.
  void setAmplitude(std::int32_t value);

  /// Set the time stamp for the hit.
  void setTimeStamp(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawCalorimeterHit& a, MutableRawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitOBJ_H
#define EDM4HEP_RawCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/RawCalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class RawCalorimeterHit;

class RawCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  RawCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawCalorimeterHitObj(const RawCalorimeterHitObj&);
  /// constructor from ObjectID and RawCalorimeterHitData
  /// does not initialize the internal relation containers
  RawCalorimeterHitObj(const podio::ObjectID id, RawCalorimeterHitData data);
  /// No assignment operator
  RawCalorimeterHitObj& operator=(const RawCalorimeterHitObj&) = delete;
  virtual ~RawCalorimeterHitObj() = default;

public:
  RawCalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_CollectionData_H
#define EDM4HEP_RawCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawCalorimeterHitObjPointerContainer = std::deque<RawCalorimeterHitObj*>;
using RawCalorimeterHitDataContainer = std::vector<RawCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawCalorimeterHitCollectionData(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData& operator=(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData(RawCalorimeterHitCollectionData&& other) = default;
  RawCalorimeterHitCollectionData& operator=(RawCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitDATA_H
#define EDM4HEP_CalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CalorimeterHitData
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  float energy{}; ///< energy of the hit in [GeV].
  float energyError{}; ///< error of the hit energy in [GeV].
  float time{}; ///< time of the hit in [ns].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].
  std::int32_t type{}; ///< type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_H
#define EDM4HEP_CalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCalorimeterHit;
class CalorimeterHitCollection;

/** @class CalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHit {

  friend class MutableCalorimeterHit;
  friend class CalorimeterHitCollection;
  friend class CalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableCalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  CalorimeterHit();
  CalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  CalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  CalorimeterHit(const CalorimeterHit& other);

  /// copy-assignment operator
  CalorimeterHit& operator=(CalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~CalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CalorimeterHit& a, CalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCalorimeterHit_H
#define EDM4HEP_MutableCalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CalorimeterHit.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableCalorimeterHit {

  friend class CalorimeterHitCollection;
  friend class CalorimeterHitMutableCollectionIterator;
  friend class CalorimeterHit;

public:
  using object_type = CalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  MutableCalorimeterHit();
  MutableCalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  MutableCalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  MutableCalorimeterHit(const MutableCalorimeterHit& other);

  /// copy-assignment operator
  MutableCalorimeterHit& operator=(MutableCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~MutableCalorimeterHit();

  /// conversion to const object
  operator CalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the error of the hit energy in [GeV].
  void setEnergyError(float value);

  /// Set the time of the hit in [ns].
  void setTime(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();

  /// Set the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  void setType(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const CalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCalorimeterHit& a, MutableCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitOBJ_H
#define EDM4HEP_CalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/CalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class CalorimeterHit;

class CalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  CalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  CalorimeterHitObj(const CalorimeterHitObj&);
  /// constructor from ObjectID and CalorimeterHitData
  /// does not initialize the internal relation containers
  CalorimeterHitObj(const podio::ObjectID id, CalorimeterHitData data);
  /// No assignment operator
  CalorimeterHitObj& operator=(const CalorimeterHitObj&) = delete;
  virtual ~CalorimeterHitObj() = default;

public:
  CalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_CollectionData_H
#define EDM4HEP_CalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CalorimeterHitObjPointerContainer = std::deque<CalorimeterHitObj*>;
using CalorimeterHitDataContainer = std::vector<CalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CalorimeterHitCollectionData(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData& operator=(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData(CalorimeterHitCollectionData&& other) = default;
  CalorimeterHitCollectionData& operator=(CalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDDATA_H
#define EDM4HEP_ParticleIDDATA_H

#include <cstdint>

namespace edm4hep {


/** @class ParticleIDData
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleIDData {
public:
  std::int32_t type{}; ///< userdefined type
  std::int32_t PDG{}; ///< PDG code of this id - ( 999999 ) if unknown.
  std::int32_t algorithmType{}; ///< type of the algorithm/module that created this hypothesis
  float likelihood{}; ///< likelihood of this hypothesis - in a user defined normalization.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_H
#define EDM4HEP_ParticleID_H

#include "edm4hep/ParticleIDObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableParticleID;
class ParticleIDCollection;

/** @class ParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleID {

  friend class MutableParticleID;
  friend class ParticleIDCollection;
  friend class ParticleIDCollectionIterator;

public:
  using mutable_type = MutableParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  ParticleID();
  ParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  ParticleID(ParticleIDObj* obj);

  /// copy constructor
  ParticleID(const ParticleID& other);

  /// copy-assignment operator
  ParticleID& operator=(ParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~ParticleID();


public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ParticleID& a, ParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ParticleID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableParticleID_H
#define EDM4HEP_MutableParticleID_H

#include "edm4hep/ParticleIDObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ParticleID.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class MutableParticleID {

  friend class ParticleIDCollection;
  friend class ParticleIDMutableCollectionIterator;
  friend class ParticleID;

public:
  using object_type = ParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  MutableParticleID();
  MutableParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  MutableParticleID(ParticleIDObj* obj);

  /// copy constructor
  MutableParticleID(const MutableParticleID& other);

  /// copy-assignment operator
  MutableParticleID& operator=(MutableParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~MutableParticleID();

  /// conversion to const object
  operator ParticleID() const;

public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  /// Set the userdefined type
  void setType(std::int32_t value);

  /// Set the PDG code of this id - ( 999999 ) if unknown.
  void setPDG(std::int32_t value);

  /// Set the type of the algorithm/module that created this hypothesis
  void setAlgorithmType(std::int32_t value);

  /// Set the likelihood of this hypothesis - in a user defined normalization.
  void setLikelihood(float value);



  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const ParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableParticleID& a, MutableParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDOBJ_H
#define EDM4HEP_ParticleIDOBJ_H

// data model specific includes
#include "edm4hep/ParticleIDData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class ParticleID;

class ParticleIDObj : public podio::ObjBase {
public:
  /// constructor
  ParticleIDObj();
  /// copy constructor (does a deep-copy of relation containers)
  ParticleIDObj(const ParticleIDObj&);
  /// constructor from ObjectID and ParticleIDData
  /// does not initialize the internal relation containers
  ParticleIDObj(const podio::ObjectID id, ParticleIDData data);
  /// No assignment operator
  ParticleIDObj& operator=(const ParticleIDObj&) = delete;
  virtual ~ParticleIDObj();

public:
  ParticleIDData data;
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_CollectionData_H
#define EDM4HEP_ParticleID_CollectionData_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleIDObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ParticleIDObjPointerContainer = std::deque<ParticleIDObj*>;
using ParticleIDDataContainer = std::vector<ParticleIDData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ParticleIDCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ParticleIDObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ParticleIDCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ParticleIDCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ParticleIDCollectionData(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData& operator=(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData(ParticleIDCollectionData&& other) = default;
  ParticleIDCollectionData& operator=(ParticleIDCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ParticleIDCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ParticleIDObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ParticleIDDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterDATA_H
#define EDM4HEP_ClusterDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ClusterData
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class ClusterData {
public:
  std::int32_t type{}; ///< flagword that defines the type of cluster. Bits 16-31 are used internally.
  float energy{}; ///< energy of the cluster [GeV]
  float energyError{}; ///< error on the energy
  ::edm4hep::Vector3f position{}; ///< position of the cluster [mm]
  std::array<float, 6> positionError{}; ///< covariance matrix of the position (6 Parameters)
  float iTheta{}; ///< intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  float phi{}; ///< intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  ::edm4hep::Vector3f directionError{}; ///< covariance matrix of the direction (3 Parameters) [mm^2]

  unsigned int shapeParameters_begin{};
  unsigned int shapeParameters_end{};
  unsigned int subdetectorEnergies_begin{};
  unsigned int subdetectorEnergies_end{};
  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int hits_begin{};
  unsigned int hits_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_H
#define EDM4HEP_Cluster_H

#include "edm4hep/ClusterObj.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCluster;
class ClusterCollection;

/** @class Cluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class Cluster {

  friend class MutableCluster;
  friend class ClusterCollection;
  friend class ClusterCollectionIterator;

public:
  using mutable_type = MutableCluster;
  using collection_type = ClusterCollection;

  /// default constructor
  Cluster();
  Cluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  Cluster(ClusterObj* obj);

  /// copy constructor
  Cluster(const Cluster& other);

  /// copy-assignment operator
  Cluster& operator=(Cluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~Cluster();


public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Cluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Cluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Cluster& a, Cluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Cluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Cluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCluster_H
#define EDM4HEP_MutableCluster_H

#include "edm4hep/ClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Cluster.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class MutableCluster {

  friend class ClusterCollection;
  friend class ClusterMutableCollectionIterator;
  friend class Cluster;

public:
  using object_type = Cluster;
  using collection_type = ClusterCollection;

  /// default constructor
  MutableCluster();
  MutableCluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  MutableCluster(ClusterObj* obj);

  /// copy constructor
  MutableCluster(const MutableCluster& other);

  /// copy-assignment operator
  MutableCluster& operator=(MutableCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~MutableCluster();

  /// conversion to const object
  operator Cluster() const;

public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  /// Set the flagword that defines the type of cluster. Bits 16-31 are used internally.
  void setType(std::int32_t value);

  /// Set the energy of the cluster [GeV]
  void setEnergy(float value);

  /// Set the error on the energy
  void setEnergyError(float value);

  /// Set the position of the cluster [mm]
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the cluster [mm]
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (6 Parameters)
  void setPositionError(std::array<float, 6> value);
  void setPositionError(size_t i, float value);
  /// Get reference to covariance matrix of the position (6 Parameters)
  std::array<float, 6>& positionError();

  /// Set the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  void setITheta(float value);

  /// Set the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  void setPhi(float value);

  /// Set the covariance matrix of the direction (3 Parameters) [mm^2]
  void setDirectionError(edm4hep::Vector3f value);
  /// Get reference to covariance matrix of the direction (3 Parameters) [mm^2]
  edm4hep::Vector3f& directionError();



  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToHits(edm4hep::CalorimeterHit);
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  void addToShapeParameters(float);
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  void addToSubdetectorEnergies(float);
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const Cluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCluster& a, MutableCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterOBJ_H
#define EDM4HEP_ClusterOBJ_H

// data model specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Cluster;

class ClusterObj : public podio::ObjBase {
public:
  /// constructor
  ClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  ClusterObj(const ClusterObj&);
  /// constructor from ObjectID and ClusterData
  /// does not initialize the internal relation containers
  ClusterObj(const podio::ObjectID id, ClusterData data);
  /// No assignment operator
  ClusterObj& operator=(const ClusterObj&) = delete;
  virtual ~ClusterObj();

public:
  ClusterData data;
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::CalorimeterHit>* m_hits{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
  std::vector<float>* m_shapeParameters{nullptr};
  std::vector<float>* m_subdetectorEnergies{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_CollectionData_H
#define EDM4HEP_Cluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ClusterObjPointerContainer = std::deque<ClusterObj*>;
using ClusterDataContainer = std::vector<ClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ClusterCollectionData(const ClusterCollectionData&) = delete;
  ClusterCollectionData& operator=(const ClusterCollectionData&) = delete;
  ClusterCollectionData(ClusterCollectionData&& other) = default;
  ClusterCollectionData& operator=(ClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_hits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CalorimeterHit>> m_rel_hits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<float> m_vec_shapeParameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_shapeParameters{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_subdetectorEnergies{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_subdetectorEnergies{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitDATA_H
#define EDM4HEP_TrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitData
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_H
#define EDM4HEP_TrackerHit_H

#include "edm4hep/TrackerHitObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHit;
class TrackerHitCollection;

/** @class TrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHit {

  friend class MutableTrackerHit;
  friend class TrackerHitCollection;
  friend class TrackerHitCollectionIterator;

public:
  using mutable_type = MutableTrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  TrackerHit();
  TrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  TrackerHit(TrackerHitObj* obj);

  /// copy constructor
  TrackerHit(const TrackerHit& other);

  /// copy-assignment operator
  TrackerHit& operator=(TrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~TrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHit& a, TrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHit_H
#define EDM4HEP_MutableTrackerHit_H

#include "edm4hep/TrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHit.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableTrackerHit {

  friend class TrackerHitCollection;
  friend class TrackerHitMutableCollectionIterator;
  friend class TrackerHit;

public:
  using object_type = TrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  MutableTrackerHit();
  MutableTrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  MutableTrackerHit(TrackerHitObj* obj);

  /// copy constructor
  MutableTrackerHit(const MutableTrackerHit& other);

  /// copy-assignment operator
  MutableTrackerHit& operator=(MutableTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~MutableTrackerHit();

  /// conversion to const object
  operator TrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHit& a, MutableTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitOBJ_H
#define EDM4HEP_TrackerHitOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHit;

class TrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitObj(const TrackerHitObj&);
  /// constructor from ObjectID and TrackerHitData
  /// does not initialize the internal relation containers
  TrackerHitObj(const podio::ObjectID id, TrackerHitData data);
  /// No assignment operator
  TrackerHitObj& operator=(const TrackerHitObj&) = delete;
  virtual ~TrackerHitObj();

public:
  TrackerHitData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_CollectionData_H
#define EDM4HEP_TrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitObjPointerContainer = std::deque<TrackerHitObj*>;
using TrackerHitDataContainer = std::vector<TrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitCollectionData(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData& operator=(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData(TrackerHitCollectionData&& other) = default;
  TrackerHitCollectionData& operator=(TrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneDATA_H
#define EDM4HEP_TrackerHitPlaneDATA_H

#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitPlaneData
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlaneData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector2f u{}; ///< measurement direction vector, u lies in the x-y plane
  ::edm4hep::Vector2f v{}; ///< measurement direction vector, v is along z
  float du{}; ///< measurement error along the direction
  float dv{}; ///< measurement error along the direction
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_H
#define EDM4HEP_TrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHitPlane;
class TrackerHitPlaneCollection;

/** @class TrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlane {

  friend class MutableTrackerHitPlane;
  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneCollectionIterator;

public:
  using mutable_type = MutableTrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  TrackerHitPlane();
  TrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  TrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  TrackerHitPlane(const TrackerHitPlane& other);

  /// copy-assignment operator
  TrackerHitPlane& operator=(TrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~TrackerHitPlane();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHitPlane& a, TrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlane& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHitPlane_H
#define EDM4HEP_MutableTrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHitPlane.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class MutableTrackerHitPlane {

  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneMutableCollectionIterator;
  friend class TrackerHitPlane;

public:
  using object_type = TrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  MutableTrackerHitPlane();
  MutableTrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  MutableTrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  MutableTrackerHitPlane(const MutableTrackerHitPlane& other);

  /// copy-assignment operator
  MutableTrackerHitPlane& operator=(MutableTrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~MutableTrackerHitPlane();

  /// conversion to const object
  operator TrackerHitPlane() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the measurement direction vector, u lies in the x-y plane
  void setU(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, u lies in the x-y plane
  edm4hep::Vector2f& u();

  /// Set the measurement direction vector, v is along z
  void setV(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, v is along z
  edm4hep::Vector2f& v();

  /// Set the measurement error along the direction
  void setDu(float value);

  /// Set the measurement error along the direction
  void setDv(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHitPlane& a, MutableTrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneOBJ_H
#define EDM4HEP_TrackerHitPlaneOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHitPlane;

class TrackerHitPlaneObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitPlaneObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitPlaneObj(const TrackerHitPlaneObj&);
  /// constructor from ObjectID and TrackerHitPlaneData
  /// does not initialize the internal relation containers
  TrackerHitPlaneObj(const podio::ObjectID id, TrackerHitPlaneData data);
  /// No assignment operator
  TrackerHitPlaneObj& operator=(const TrackerHitPlaneObj&) = delete;
  virtual ~TrackerHitPlaneObj();

public:
  TrackerHitPlaneData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_CollectionData_H
#define EDM4HEP_TrackerHitPlane_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlaneObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitPlaneObjPointerContainer = std::deque<TrackerHitPlaneObj*>;
using TrackerHitPlaneDataContainer = std::vector<TrackerHitPlaneData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitPlaneCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitPlaneObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitPlaneCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitPlaneCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitPlaneCollectionData(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData& operator=(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData(TrackerHitPlaneCollectionData&& other) = default;
  TrackerHitPlaneCollectionData& operator=(TrackerHitPlaneCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitPlaneCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitPlaneObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitPlaneDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesDATA_H
#define EDM4HEP_RawTimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawTimeSeriesData
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeriesData {
public:
  std::uint64_t cellID{}; ///< detector specific cell id.
  std::int32_t quality{}; ///< quality flag for the hit.
  float time{}; ///< time of the hit [ns].
  float charge{}; ///< integrated charge of the hit [fC].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int adcCounts_begin{};
  unsigned int adcCounts_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_H
#define EDM4HEP_RawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawTimeSeries;
class RawTimeSeriesCollection;

/** @class RawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeries {

  friend class MutableRawTimeSeries;
  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesCollectionIterator;

public:
  using mutable_type = MutableRawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  RawTimeSeries();
  RawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  RawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  RawTimeSeries(const RawTimeSeries& other);

  /// copy-assignment operator
  RawTimeSeries& operator=(RawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~RawTimeSeries();


public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawTimeSeries& a, RawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawTimeSeries_H
#define EDM4HEP_MutableRawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawTimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class MutableRawTimeSeries {

  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesMutableCollectionIterator;
  friend class RawTimeSeries;

public:
  using object_type = RawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  MutableRawTimeSeries();
  MutableRawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  MutableRawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  MutableRawTimeSeries(const MutableRawTimeSeries& other);

  /// copy-assignment operator
  MutableRawTimeSeries& operator=(MutableRawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~MutableRawTimeSeries();

  /// conversion to const object
  operator RawTimeSeries() const;

public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the detector specific cell id.
  void setCellID(std::uint64_t value);

  /// Set the quality flag for the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the integrated charge of the hit [fC].
  void setCharge(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAdcCounts(std::int32_t);
  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawTimeSeries& a, MutableRawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesOBJ_H
#define EDM4HEP_RawTimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RawTimeSeries;

class RawTimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  RawTimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawTimeSeriesObj(const RawTimeSeriesObj&);
  /// constructor from ObjectID and RawTimeSeriesData
  /// does not initialize the internal relation containers
  RawTimeSeriesObj(const podio::ObjectID id, RawTimeSeriesData data);
  /// No assignment operator
  RawTimeSeriesObj& operator=(const RawTimeSeriesObj&) = delete;
  virtual ~RawTimeSeriesObj();

public:
  RawTimeSeriesData data;
  std::vector<std::int32_t>* m_adcCounts{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_CollectionData_H
#define EDM4HEP_RawTimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawTimeSeriesObjPointerContainer = std::deque<RawTimeSeriesObj*>;
using RawTimeSeriesDataContainer = std::vector<RawTimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawTimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawTimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawTimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawTimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawTimeSeriesCollectionData(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData& operator=(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData(RawTimeSeriesCollectionData&& other) = default;
  RawTimeSeriesCollectionData& operator=(RawTimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawTimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RawTimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_adcCounts{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_adcCounts{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawTimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackDATA_H
#define EDM4HEP_TrackDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TrackData
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class TrackData {
public:
  std::int32_t type{}; ///< flagword that defines the type of track.Bits 16-31 are used internally
  float chi2{}; ///< Chi^2 of the track fit
  std::int32_t ndf{}; ///< number of degrees of freedom of the track fit
  float dEdx{}; ///< dEdx of the track.
  float dEdxError{}; ///< error of dEdx.
  float radiusOfInnermostHit{}; ///< radius of the innermost hit that has been used in the track fit

  unsigned int subdetectorHitNumbers_begin{};
  unsigned int subdetectorHitNumbers_end{};
  unsigned int trackStates_begin{};
  unsigned int trackStates_end{};
  unsigned int dxQuantities_begin{};
  unsigned int dxQuantities_end{};
  unsigned int trackerHits_begin{};
  unsigned int trackerHits_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_H
#define EDM4HEP_Track_H

#include "edm4hep/TrackObj.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrack;
class TrackCollection;

/** @class Track
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class Track {

  friend class MutableTrack;
  friend class TrackCollection;
  friend class TrackCollectionIterator;

public:
  using mutable_type = MutableTrack;
  using collection_type = TrackCollection;

  /// default constructor
  Track();
  Track(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  Track(TrackObj* obj);

  /// copy constructor
  Track(const Track& other);

  /// copy-assignment operator
  Track& operator=(Track other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~Track();


public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Track& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrack& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Track& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Track& a, Track& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Track& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Track& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrack_H
#define EDM4HEP_MutableTrack_H

#include "edm4hep/TrackObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Track.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrack
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class MutableTrack {

  friend class TrackCollection;
  friend class TrackMutableCollectionIterator;
  friend class Track;

public:
  using object_type = Track;
  using collection_type = TrackCollection;

  /// default constructor
  MutableTrack();
  MutableTrack(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  MutableTrack(TrackObj* obj);

  /// copy constructor
  MutableTrack(const MutableTrack& other);

  /// copy-assignment operator
  MutableTrack& operator=(MutableTrack other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~MutableTrack();

  /// conversion to const object
  operator Track() const;

public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  /// Set the flagword that defines the type of track.Bits 16-31 are used internally
  void setType(std::int32_t value);

  /// Set the Chi^2 of the track fit
  void setChi2(float value);

  /// Set the number of degrees of freedom of the track fit
  void setNdf(std::int32_t value);

  /// Set the dEdx of the track.
  void setDEdx(float value);

  /// Set the error of dEdx.
  void setDEdxError(float value);

  /// Set the radius of the innermost hit that has been used in the track fit
  void setRadiusOfInnermostHit(float value);



  void addToTrackerHits(edm4hep::TrackerHit);
  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToSubdetectorHitNumbers(std::int32_t);
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  void addToTrackStates(edm4hep::TrackState);
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  void addToDxQuantities(edm4hep::Quantity);
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrack& other) const { return m_obj == other.m_obj; }
  bool operator==(const Track& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrack& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrack& a, MutableTrack& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrack& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackOBJ_H
#define EDM4HEP_TrackOBJ_H

// data model specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Track;

class TrackObj : public podio::ObjBase {
public:
  /// constructor
  TrackObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackObj(const TrackObj&);
  /// constructor from ObjectID and TrackData
  /// does not initialize the internal relation containers
  TrackObj(const podio::ObjectID id, TrackData data);
  /// No assignment operator
  TrackObj& operator=(const TrackObj&) = delete;
  virtual ~TrackObj();

public:
  TrackData data;
  std::vector<edm4hep::TrackerHit>* m_trackerHits{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<std::int32_t>* m_subdetectorHitNumbers{nullptr};
  std::vector<edm4hep::TrackState>* m_trackStates{nullptr};
  std::vector<edm4hep::Quantity>* m_dxQuantities{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_CollectionData_H
#define EDM4HEP_Track_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackObjPointerContainer = std::deque<TrackObj*>;
using TrackDataContainer = std::vector<TrackData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackCollectionData(const TrackCollectionData&) = delete;
  TrackCollectionData& operator=(const TrackCollectionData&) = delete;
  TrackCollectionData(TrackCollectionData&& other) = default;
  TrackCollectionData& operator=(TrackCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_trackerHits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerHit>> m_rel_trackerHits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_subdetectorHitNumbers{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_subdetectorHitNumbers{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::TrackState> m_vec_trackStates{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::TrackState>> m_vecs_trackStates{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Quantity> m_vec_dxQuantities{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Quantity>> m_vecs_dxQuantities{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexDATA_H
#define EDM4HEP_VertexDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class VertexData
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class VertexData {
public:
  std::int32_t primary{}; ///< boolean flag, if vertex is the primary vertex of the event
  float chi2{}; ///< chi-squared of the vertex fit
  float probability{}; ///< probability of the vertex fit
  ::edm4hep::Vector3f position{}; ///< [mm] position of the vertex.
  std::array<float, 6> covMatrix{}; ///< covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::int32_t algorithmType{}; ///< type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_H
#define EDM4HEP_Vertex_H

#include "edm4hep/VertexObj.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {

class MutableVertex;
class VertexCollection;

/** @class Vertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class Vertex {

  friend class MutableVertex;
  friend class VertexCollection;
  friend class VertexCollectionIterator;

public:
  using mutable_type = MutableVertex;
  using collection_type = VertexCollection;

  /// default constructor
  Vertex();
  Vertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  Vertex(VertexObj* obj);

  /// copy constructor
  Vertex(const Vertex& other);

  /// copy-assignment operator
  Vertex& operator=(Vertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~Vertex();


public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Vertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableVertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Vertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Vertex& a, Vertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Vertex& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableVertex_H
#define EDM4HEP_MutableVertex_H

#include "edm4hep/VertexObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Vertex.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {


/** @class MutableVertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class MutableVertex {

  friend class VertexCollection;
  friend class VertexMutableCollectionIterator;
  friend class Vertex;

public:
  using object_type = Vertex;
  using collection_type = VertexCollection;

  /// default constructor
  MutableVertex();
  MutableVertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  MutableVertex(VertexObj* obj);

  /// copy constructor
  MutableVertex(const MutableVertex& other);

  /// copy-assignment operator
  MutableVertex& operator=(MutableVertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~MutableVertex();

  /// conversion to const object
  operator Vertex() const;

public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  /// Set the boolean flag, if vertex is the primary vertex of the event
  void setPrimary(std::int32_t value);

  /// Set the chi-squared of the vertex fit
  void setChi2(float value);

  /// Set the probability of the vertex fit
  void setProbability(float value);

  /// Set the [mm] position of the vertex.
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to [mm] position of the vertex.
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::array<float, 6>& covMatrix();

  /// Set the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  void setAlgorithmType(std::int32_t value);


  /// Set the reconstructed particle associated to this vertex.
  void setAssociatedParticle(edm4hep::ReconstructedParticle value);

  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableVertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const Vertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableVertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableVertex& a, MutableVertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableVertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexOBJ_H
#define EDM4HEP_VertexOBJ_H

// data model specific includes
#include "edm4hep/VertexData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class ReconstructedParticle;
}


namespace edm4hep {

class Vertex;

class VertexObj : public podio::ObjBase {
public:
  /// constructor
  VertexObj();
  /// copy constructor (does a deep-copy of relation containers)
  VertexObj(const VertexObj&);
  /// constructor from ObjectID and VertexData
  /// does not initialize the internal relation containers
  VertexObj(const podio::ObjectID id, VertexData data);
  /// No assignment operator
  VertexObj& operator=(const VertexObj&) = delete;
  virtual ~VertexObj();

public:
  VertexData data;
  edm4hep::ReconstructedParticle* m_associatedParticle{nullptr};
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_CollectionData_H
#define EDM4HEP_Vertex_CollectionData_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using VertexObjPointerContainer = std::deque<VertexObj*>;
using VertexDataContainer = std::vector<VertexData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class VertexCollectionData {
public:
  /**
   * The Objs of this collection
   */
  VertexObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  VertexCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  VertexCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  VertexCollectionData(const VertexCollectionData&) = delete;
  VertexCollectionData& operator=(const VertexCollectionData&) = delete;
  VertexCollectionData(VertexCollectionData&& other) = default;
  VertexCollectionData& operator=(VertexCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~VertexCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(VertexObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_associatedParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<VertexDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleDATA_H
#define EDM4HEP_ReconstructedParticleDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ReconstructedParticleData
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticleData {
public:
  std::int32_t type{}; ///< type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  float energy{}; ///< [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f momentum{}; ///< [GeV] particle momentum. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f referencePoint{}; ///< [mm] reference, i.e. where the particle has been measured
  float charge{}; ///< charge of the reconstructed particle.
  float mass{}; ///< [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  float goodnessOfPID{}; ///< overall goodness of the PID on a scale of [0;1]
  std::array<float, 10> covMatrix{}; ///< cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##

  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
  unsigned int particles_begin{};
  unsigned int particles_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_H
#define EDM4HEP_ReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {

class MutableReconstructedParticle;
class ReconstructedParticleCollection;

/** @class ReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticle {

  friend class MutableReconstructedParticle;
  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleCollectionIterator;

public:
  using mutable_type = MutableReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  ReconstructedParticle();
  ReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  ReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  ReconstructedParticle(const ReconstructedParticle& other);

  /// copy-assignment operator
  ReconstructedParticle& operator=(ReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~ReconstructedParticle();


public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ReconstructedParticle& a, ReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableReconstructedParticle_H
#define EDM4HEP_MutableReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ReconstructedParticle.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {


/** @class MutableReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class MutableReconstructedParticle {

  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleMutableCollectionIterator;
  friend class ReconstructedParticle;

public:
  using object_type = ReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  MutableReconstructedParticle();
  MutableReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  MutableReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  MutableReconstructedParticle(const MutableReconstructedParticle& other);

  /// copy-assignment operator
  MutableReconstructedParticle& operator=(MutableReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~MutableReconstructedParticle();

  /// conversion to const object
  operator ReconstructedParticle() const;

public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  /// Set the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  void setType(std::int32_t value);

  /// Set the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  void setEnergy(float value);

  /// Set the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to [GeV] particle momentum. Four momentum state is not kept consistent internally.
  edm4hep::Vector3f& momentum();

  /// Set the [mm] reference, i.e. where the particle has been measured
  void setReferencePoint(edm4hep::Vector3f value);
  /// Get reference to [mm] reference, i.e. where the particle has been measured
  edm4hep::Vector3f& referencePoint();

  /// Set the charge of the reconstructed particle.
  void setCharge(float value);

  /// Set the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  void setMass(float value);

  /// Set the overall goodness of the PID on a scale of [0;1]
  void setGoodnessOfPID(float value);

  /// Set the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  void setCovMatrix(std::array<float, 10> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  std::array<float, 10>& covMatrix();


  /// Set the start vertex associated to this particle
  void setStartVertex(edm4hep::Vertex value);
  /// Set the particle Id used for the kinematics of this particle
  void setParticleIDUsed(edm4hep::ParticleID value);

  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToParticles(edm4hep::ReconstructedParticle);
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

 //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.
 //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const ReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableReconstructedParticle& a, MutableReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleOBJ_H
#define EDM4HEP_ReconstructedParticleOBJ_H

// data model specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Vertex;
class ParticleID;
}


namespace edm4hep {

class ReconstructedParticle;

class ReconstructedParticleObj : public podio::ObjBase {
public:
  /// constructor
  ReconstructedParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  ReconstructedParticleObj(const ReconstructedParticleObj&);
  /// constructor from ObjectID and ReconstructedParticleData
  /// does not initialize the internal relation containers
  ReconstructedParticleObj(const podio::ObjectID id, ReconstructedParticleData data);
  /// No assignment operator
  ReconstructedParticleObj& operator=(const ReconstructedParticleObj&) = delete;
  virtual ~ReconstructedParticleObj();

public:
  ReconstructedParticleData data;
  edm4hep::Vertex* m_startVertex{nullptr};
  edm4hep::ParticleID* m_particleIDUsed{nullptr};
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<edm4hep::ReconstructedParticle>* m_particles{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_CollectionData_H
#define EDM4HEP_ReconstructedParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ReconstructedParticleObjPointerContainer = std::deque<ReconstructedParticleObj*>;
using ReconstructedParticleDataContainer = std::vector<ReconstructedParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ReconstructedParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ReconstructedParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ReconstructedParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ReconstructedParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ReconstructedParticleCollectionData(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData& operator=(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData(ReconstructedParticleCollectionData&& other) = default;
  ReconstructedParticleCollectionData& operator=(ReconstructedParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ReconstructedParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ReconstructedParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_particles;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ReconstructedParticle>> m_rel_particles_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Vertex> m_rel_startVertex{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDUsed{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ReconstructedParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationDATA_H
#define EDM4HEP_MCRecoParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoParticleAssociationData
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_H
#define EDM4HEP_MCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoParticleAssociation;
class MCRecoParticleAssociationCollection;

/** @class MCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociation {

  friend class MutableMCRecoParticleAssociation;
  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MCRecoParticleAssociation();
  MCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MCRecoParticleAssociation(const MCRecoParticleAssociation& other);

  /// copy-assignment operator
  MCRecoParticleAssociation& operator=(MCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MCRecoParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoParticleAssociation& a, MCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoParticleAssociation_H
#define EDM4HEP_MutableMCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoParticleAssociation {

  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationMutableCollectionIterator;
  friend class MCRecoParticleAssociation;

public:
  using object_type = MCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MutableMCRecoParticleAssociation();
  MutableMCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MutableMCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoParticleAssociation(const MutableMCRecoParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoParticleAssociation& operator=(MutableMCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoParticleAssociation();

  /// conversion to const object
  operator MCRecoParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoParticleAssociation& a, MutableMCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationOBJ_H
#define EDM4HEP_MCRecoParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MCParticle;
}


namespace edm4hep {

class MCRecoParticleAssociation;

class MCRecoParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoParticleAssociationObj(const MCRecoParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoParticleAssociationObj(const podio::ObjectID id, MCRecoParticleAssociationData data);
  /// No assignment operator
  MCRecoParticleAssociationObj& operator=(const MCRecoParticleAssociationObj&) = delete;
  virtual ~MCRecoParticleAssociationObj();

public:
  MCRecoParticleAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoParticleAssociationObjPointerContainer = std::deque<MCRecoParticleAssociationObj*>;
using MCRecoParticleAssociationDataContainer = std::vector<MCRecoParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoParticleAssociationCollectionData(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData& operator=(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData(MCRecoParticleAssociationCollectionData&& other) = default;
  MCRecoParticleAssociationCollectionData& operator=(MCRecoParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationDATA_H
#define EDM4HEP_MCRecoCaloAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloAssociationData
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_H
#define EDM4HEP_MCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {

class MutableMCRecoCaloAssociation;
class MCRecoCaloAssociationCollection;

/** @class MCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociation {

  friend class MutableMCRecoCaloAssociation;
  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MCRecoCaloAssociation();
  MCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MCRecoCaloAssociation(const MCRecoCaloAssociation& other);

  /// copy-assignment operator
  MCRecoCaloAssociation& operator=(MCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MCRecoCaloAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloAssociation& a, MCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloAssociation_H
#define EDM4HEP_MutableMCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {


/** @class MutableMCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoCaloAssociation {

  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationMutableCollectionIterator;
  friend class MCRecoCaloAssociation;

public:
  using object_type = MCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MutableMCRecoCaloAssociation();
  MutableMCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MutableMCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloAssociation(const MutableMCRecoCaloAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloAssociation& operator=(MutableMCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloAssociation();

  /// conversion to const object
  operator MCRecoCaloAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimCalorimeterHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloAssociation& a, MutableMCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationOBJ_H
#define EDM4HEP_MCRecoCaloAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class SimCalorimeterHit;
}


namespace edm4hep {

class MCRecoCaloAssociation;

class MCRecoCaloAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloAssociationObj(const MCRecoCaloAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloAssociationObj(const podio::ObjectID id, MCRecoCaloAssociationData data);
  /// No assignment operator
  MCRecoCaloAssociationObj& operator=(const MCRecoCaloAssociationObj&) = delete;
  virtual ~MCRecoCaloAssociationObj();

public:
  MCRecoCaloAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::SimCalorimeterHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/SimCalorimeterHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloAssociationObjPointerContainer = std::deque<MCRecoCaloAssociationObj*>;
using MCRecoCaloAssociationDataContainer = std::vector<MCRecoCaloAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloAssociationCollectionData(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData& operator=(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData(MCRecoCaloAssociationCollectionData&& other) = default;
  MCRecoCaloAssociationCollectionData& operator=(MCRecoCaloAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimCalorimeterHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationDATA_H
#define EDM4HEP_MCRecoTrackerAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerAssociationData
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_H
#define EDM4HEP_MCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerAssociation;
class MCRecoTrackerAssociationCollection;

/** @class MCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociation {

  friend class MutableMCRecoTrackerAssociation;
  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MCRecoTrackerAssociation();
  MCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerAssociation(const MCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerAssociation& operator=(MCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MCRecoTrackerAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerAssociation& a, MCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerAssociation_H
#define EDM4HEP_MutableMCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoTrackerAssociation {

  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationMutableCollectionIterator;
  friend class MCRecoTrackerAssociation;

public:
  using object_type = MCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerAssociation();
  MutableMCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MutableMCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerAssociation(const MutableMCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerAssociation& operator=(MutableMCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerAssociation();

  /// conversion to const object
  operator MCRecoTrackerAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerAssociation& a, MutableMCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHit;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerAssociation;

class MCRecoTrackerAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerAssociationObj(const MCRecoTrackerAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerAssociationObj(const podio::ObjectID id, MCRecoTrackerAssociationData data);
  /// No assignment operator
  MCRecoTrackerAssociationObj& operator=(const MCRecoTrackerAssociationObj&) = delete;
  virtual ~MCRecoTrackerAssociationObj();

public:
  MCRecoTrackerAssociationData data;
  edm4hep::TrackerHit* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerAssociationObjPointerContainer = std::deque<MCRecoTrackerAssociationObj*>;
using MCRecoTrackerAssociationDataContainer = std::vector<MCRecoTrackerAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerAssociationCollectionData(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData& operator=(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData(MCRecoTrackerAssociationCollectionData&& other) = default;
  MCRecoTrackerAssociationCollectionData& operator=(MCRecoTrackerAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerHitPlaneAssociationData
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerHitPlaneAssociation;
class MCRecoTrackerHitPlaneAssociationCollection;

/** @class MCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociation {

  friend class MutableMCRecoTrackerHitPlaneAssociation;
  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MCRecoTrackerHitPlaneAssociation();
  MCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerHitPlaneAssociation(const MCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerHitPlaneAssociation& operator=(MCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MCRecoTrackerHitPlaneAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerHitPlaneAssociation& a, MCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackerHitPlaneAssociation {

  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;
  friend class MCRecoTrackerHitPlaneAssociation;

public:
  using object_type = MCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerHitPlaneAssociation();
  MutableMCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MutableMCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerHitPlaneAssociation(const MutableMCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerHitPlaneAssociation& operator=(MutableMCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerHitPlaneAssociation();

  /// conversion to const object
  operator MCRecoTrackerHitPlaneAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHitPlane value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerHitPlaneAssociation& a, MutableMCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerHitPlaneAssociation;

class MCRecoTrackerHitPlaneAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerHitPlaneAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerHitPlaneAssociationObj(const MCRecoTrackerHitPlaneAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerHitPlaneAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerHitPlaneAssociationObj(const podio::ObjectID id, MCRecoTrackerHitPlaneAssociationData data);
  /// No assignment operator
  MCRecoTrackerHitPlaneAssociationObj& operator=(const MCRecoTrackerHitPlaneAssociationObj&) = delete;
  virtual ~MCRecoTrackerHitPlaneAssociationObj();

public:
  MCRecoTrackerHitPlaneAssociationData data;
  edm4hep::TrackerHitPlane* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHitPlane.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerHitPlaneAssociationObjPointerContainer = std::deque<MCRecoTrackerHitPlaneAssociationObj*>;
using MCRecoTrackerHitPlaneAssociationDataContainer = std::vector<MCRecoTrackerHitPlaneAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerHitPlaneAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerHitPlaneAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerHitPlaneAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHitPlane> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerHitPlaneAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationDATA_H
#define EDM4HEP_MCRecoCaloParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloParticleAssociationData
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_H
#define EDM4HEP_MCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoCaloParticleAssociation;
class MCRecoCaloParticleAssociationCollection;

/** @class MCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociation {

  friend class MutableMCRecoCaloParticleAssociation;
  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MCRecoCaloParticleAssociation();
  MCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MCRecoCaloParticleAssociation(const MCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MCRecoCaloParticleAssociation& operator=(MCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MCRecoCaloParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloParticleAssociation& a, MCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloParticleAssociation_H
#define EDM4HEP_MutableMCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoCaloParticleAssociation {

  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationMutableCollectionIterator;
  friend class MCRecoCaloParticleAssociation;

public:
  using object_type = MCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MutableMCRecoCaloParticleAssociation();
  MutableMCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MutableMCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloParticleAssociation(const MutableMCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloParticleAssociation& operator=(MutableMCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloParticleAssociation();

  /// conversion to const object
  operator MCRecoCaloParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloParticleAssociation& a, MutableMCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationOBJ_H
#define EDM4HEP_MCRecoCaloParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MCParticle;
}


namespace edm4hep {

class MCRecoCaloParticleAssociation;

class MCRecoCaloParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloParticleAssociationObj(const MCRecoCaloParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloParticleAssociationObj(const podio::ObjectID id, MCRecoCaloParticleAssociationData data);
  /// No assignment operator
  MCRecoCaloParticleAssociationObj& operator=(const MCRecoCaloParticleAssociationObj&) = delete;
  virtual ~MCRecoCaloParticleAssociationObj();

public:
  MCRecoCaloParticleAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloParticleAssociationObjPointerContainer = std::deque<MCRecoCaloParticleAssociationObj*>;
using MCRecoCaloParticleAssociationDataContainer = std::vector<MCRecoCaloParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloParticleAssociationCollectionData(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData& operator=(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData(MCRecoCaloParticleAssociationCollectionData&& other) = default;
  MCRecoCaloParticleAssociationCollectionData& operator=(MCRecoCaloParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationDATA_H
#define EDM4HEP_MCRecoClusterParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoClusterParticleAssociationData
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_H
#define EDM4HEP_MCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoClusterParticleAssociation;
class MCRecoClusterParticleAssociationCollection;

/** @class MCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociation {

  friend class MutableMCRecoClusterParticleAssociation;
  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MCRecoClusterParticleAssociation();
  MCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MCRecoClusterParticleAssociation(const MCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MCRecoClusterParticleAssociation& operator=(MCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MCRecoClusterParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoClusterParticleAssociation& a, MCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoClusterParticleAssociation_H
#define EDM4HEP_MutableMCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoClusterParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoClusterParticleAssociation {

  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationMutableCollectionIterator;
  friend class MCRecoClusterParticleAssociation;

public:
  using object_type = MCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MutableMCRecoClusterParticleAssociation();
  MutableMCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MutableMCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoClusterParticleAssociation(const MutableMCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoClusterParticleAssociation& operator=(MutableMCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoClusterParticleAssociation();

  /// conversion to const object
  operator MCRecoClusterParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the cluster
  void setRec(edm4hep::Cluster value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoClusterParticleAssociation& a, MutableMCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationOBJ_H
#define EDM4HEP_MCRecoClusterParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Cluster;
class MCParticle;
}


namespace edm4hep {

class MCRecoClusterParticleAssociation;

class MCRecoClusterParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoClusterParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoClusterParticleAssociationObj(const MCRecoClusterParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoClusterParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoClusterParticleAssociationObj(const podio::ObjectID id, MCRecoClusterParticleAssociationData data);
  /// No assignment operator
  MCRecoClusterParticleAssociationObj& operator=(const MCRecoClusterParticleAssociationObj&) = delete;
  virtual ~MCRecoClusterParticleAssociationObj();

public:
  MCRecoClusterParticleAssociationData data;
  edm4hep::Cluster* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoClusterParticleAssociationObjPointerContainer = std::deque<MCRecoClusterParticleAssociationObj*>;
using MCRecoClusterParticleAssociationDataContainer = std::vector<MCRecoClusterParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoClusterParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoClusterParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoClusterParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoClusterParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoClusterParticleAssociationCollectionData(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData& operator=(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData(MCRecoClusterParticleAssociationCollectionData&& other) = default;
  MCRecoClusterParticleAssociationCollectionData& operator=(MCRecoClusterParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoClusterParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoClusterParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationDATA_H
#define EDM4HEP_MCRecoTrackParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackParticleAssociationData
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_H
#define EDM4HEP_MCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoTrackParticleAssociation;
class MCRecoTrackParticleAssociationCollection;

/** @class MCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociation {

  friend class MutableMCRecoTrackParticleAssociation;
  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MCRecoTrackParticleAssociation();
  MCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MCRecoTrackParticleAssociation(const MCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MCRecoTrackParticleAssociation& operator=(MCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MCRecoTrackParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackParticleAssociation& a, MCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackParticleAssociation_H
#define EDM4HEP_MutableMCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackParticleAssociation {

  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationMutableCollectionIterator;
  friend class MCRecoTrackParticleAssociation;

public:
  using object_type = MCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MutableMCRecoTrackParticleAssociation();
  MutableMCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MutableMCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackParticleAssociation(const MutableMCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackParticleAssociation& operator=(MutableMCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackParticleAssociation();

  /// conversion to const object
  operator MCRecoTrackParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the track
  void setRec(edm4hep::Track value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackParticleAssociation& a, MutableMCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationOBJ_H
#define EDM4HEP_MCRecoTrackParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Track;
class MCParticle;
}


namespace edm4hep {

class MCRecoTrackParticleAssociation;

class MCRecoTrackParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackParticleAssociationObj(const MCRecoTrackParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackParticleAssociationObj(const podio::ObjectID id, MCRecoTrackParticleAssociationData data);
  /// No assignment operator
  MCRecoTrackParticleAssociationObj& operator=(const MCRecoTrackParticleAssociationObj&) = delete;
  virtual ~MCRecoTrackParticleAssociationObj();

public:
  MCRecoTrackParticleAssociationData data;
  edm4hep::Track* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackParticleAssociationObjPointerContainer = std::deque<MCRecoTrackParticleAssociationObj*>;
using MCRecoTrackParticleAssociationDataContainer = std::vector<MCRecoTrackParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackParticleAssociationCollectionData(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData& operator=(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData(MCRecoTrackParticleAssociationCollectionData&& other) = default;
  MCRecoTrackParticleAssociationCollectionData& operator=(MCRecoTrackParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationDATA_H
#define EDM4HEP_RecoParticleVertexAssociationDATA_H


namespace edm4hep {


/** @class RecoParticleVertexAssociationData
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_H
#define EDM4HEP_RecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {

class MutableRecoParticleVertexAssociation;
class RecoParticleVertexAssociationCollection;

/** @class RecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociation {

  friend class MutableRecoParticleVertexAssociation;
  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationCollectionIterator;

public:
  using mutable_type = MutableRecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  RecoParticleVertexAssociation();
  RecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  RecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  RecoParticleVertexAssociation(const RecoParticleVertexAssociation& other);

  /// copy-assignment operator
  RecoParticleVertexAssociation& operator=(RecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~RecoParticleVertexAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecoParticleVertexAssociation& a, RecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecoParticleVertexAssociation_H
#define EDM4HEP_MutableRecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecoParticleVertexAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {


/** @class MutableRecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class MutableRecoParticleVertexAssociation {

  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationMutableCollectionIterator;
  friend class RecoParticleVertexAssociation;

public:
  using object_type = RecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  MutableRecoParticleVertexAssociation();
  MutableRecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  MutableRecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  MutableRecoParticleVertexAssociation(const MutableRecoParticleVertexAssociation& other);

  /// copy-assignment operator
  MutableRecoParticleVertexAssociation& operator=(MutableRecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~MutableRecoParticleVertexAssociation();

  /// conversion to const object
  operator RecoParticleVertexAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the vertex
  void setVertex(edm4hep::Vertex value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecoParticleVertexAssociation& a, MutableRecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationOBJ_H
#define EDM4HEP_RecoParticleVertexAssociationOBJ_H

// data model specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class Vertex;
}


namespace edm4hep {

class RecoParticleVertexAssociation;

class RecoParticleVertexAssociationObj : public podio::ObjBase {
public:
  /// constructor
  RecoParticleVertexAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecoParticleVertexAssociationObj(const RecoParticleVertexAssociationObj&);
  /// constructor from ObjectID and RecoParticleVertexAssociationData
  /// does not initialize the internal relation containers
  RecoParticleVertexAssociationObj(const podio::ObjectID id, RecoParticleVertexAssociationData data);
  /// No assignment operator
  RecoParticleVertexAssociationObj& operator=(const RecoParticleVertexAssociationObj&) = delete;
  virtual ~RecoParticleVertexAssociationObj();

public:
  RecoParticleVertexAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::Vertex* m_vertex{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_CollectionData_H
#define EDM4HEP_RecoParticleVertexAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecoParticleVertexAssociationObjPointerContainer = std::deque<RecoParticleVertexAssociationObj*>;
using RecoParticleVertexAssociationDataContainer = std::vector<RecoParticleVertexAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecoParticleVertexAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecoParticleVertexAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecoParticleVertexAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecoParticleVertexAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecoParticleVertexAssociationCollectionData(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData& operator=(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData(RecoParticleVertexAssociationCollectionData&& other) = default;
  RecoParticleVertexAssociationCollectionData& operator=(RecoParticleVertexAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecoParticleVertexAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::Vertex> m_rel_vertex{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecoParticleVertexAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterDATA_H
#define EDM4HEP_SimPrimaryIonizationClusterDATA_H

#include "edm4hep/Vector3d.h"
#include <cstdint>

namespace edm4hep {


/** @class SimPrimaryIonizationClusterData
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< the primary ionization's time in the lab frame [ns].
  ::edm4hep::Vector3d position{}; ///< the primary ionization's position [mm].
  std::int16_t type{}; ///< type.

  unsigned int electronCellID_begin{};
  unsigned int electronCellID_end{};
  unsigned int electronTime_begin{};
  unsigned int electronTime_end{};
  unsigned int electronPosition_begin{};
  unsigned int electronPosition_end{};
  unsigned int pulseTime_begin{};
  unsigned int pulseTime_end{};
  unsigned int pulseAmplitude_begin{};
  unsigned int pulseAmplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_H
#define EDM4HEP_SimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimPrimaryIonizationCluster;
class SimPrimaryIonizationClusterCollection;

/** @class SimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationCluster {

  friend class MutableSimPrimaryIonizationCluster;
  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableSimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  SimPrimaryIonizationCluster();
  SimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  SimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  SimPrimaryIonizationCluster(const SimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  SimPrimaryIonizationCluster& operator=(SimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~SimPrimaryIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimPrimaryIonizationCluster& a, SimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimPrimaryIonizationCluster_H
#define EDM4HEP_MutableSimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimPrimaryIonizationCluster.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class MutableSimPrimaryIonizationCluster {

  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterMutableCollectionIterator;
  friend class SimPrimaryIonizationCluster;

public:
  using object_type = SimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  MutableSimPrimaryIonizationCluster();
  MutableSimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  MutableSimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  MutableSimPrimaryIonizationCluster(const MutableSimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  MutableSimPrimaryIonizationCluster& operator=(MutableSimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~MutableSimPrimaryIonizationCluster();

  /// conversion to const object
  operator SimPrimaryIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the the primary ionization's time in the lab frame [ns].
  void setTime(float value);

  /// Set the the primary ionization's position [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the primary ionization's position [mm].
  edm4hep::Vector3d& position();

  /// Set the type.
  void setType(std::int16_t value);


  /// Set the the particle that caused the ionizing collisions.
  void setMCParticle(edm4hep::MCParticle value);

  void addToElectronCellID(std::uint64_t);
  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  void addToElectronTime(float);
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  void addToElectronPosition(edm4hep::Vector3d);
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  void addToPulseTime(float);
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  void addToPulseAmplitude(float);
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimPrimaryIonizationCluster& a, MutableSimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterOBJ_H
#define EDM4HEP_SimPrimaryIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/Vector3d.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimPrimaryIonizationCluster;

class SimPrimaryIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  SimPrimaryIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimPrimaryIonizationClusterObj(const SimPrimaryIonizationClusterObj&);
  /// constructor from ObjectID and SimPrimaryIonizationClusterData
  /// does not initialize the internal relation containers
  SimPrimaryIonizationClusterObj(const podio::ObjectID id, SimPrimaryIonizationClusterData data);
  /// No assignment operator
  SimPrimaryIonizationClusterObj& operator=(const SimPrimaryIonizationClusterObj&) = delete;
  virtual ~SimPrimaryIonizationClusterObj();

public:
  SimPrimaryIonizationClusterData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
  std::vector<std::uint64_t>* m_electronCellID{nullptr};
  std::vector<float>* m_electronTime{nullptr};
  std::vector<edm4hep::Vector3d>* m_electronPosition{nullptr};
  std::vector<float>* m_pulseTime{nullptr};
  std::vector<float>* m_pulseAmplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H
#define EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimPrimaryIonizationClusterObjPointerContainer = std::deque<SimPrimaryIonizationClusterObj*>;
using SimPrimaryIonizationClusterDataContainer = std::vector<SimPrimaryIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimPrimaryIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimPrimaryIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimPrimaryIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimPrimaryIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimPrimaryIonizationClusterCollectionData(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData& operator=(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData(SimPrimaryIonizationClusterCollectionData&& other) = default;
  SimPrimaryIonizationClusterCollectionData& operator=(SimPrimaryIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimPrimaryIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimPrimaryIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<std::uint64_t> m_vec_electronCellID{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::uint64_t>> m_vecs_electronCellID{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_electronTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_electronTime{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Vector3d> m_vec_electronPosition{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Vector3d>> m_vecs_electronPosition{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseTime{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseAmplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseAmplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimPrimaryIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseDATA_H
#define EDM4HEP_TrackerPulseDATA_H

#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerPulseData
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulseData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< time [ns].
  float charge{}; ///< charge [fC].
  std::int16_t quality{}; ///< quality.
  std::array<float, 3> covMatrix{}; ///< lower triangle covariance matrix of the charge(c) and time(t) measurements.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_H
#define EDM4HEP_TrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {

class MutableTrackerPulse;
class TrackerPulseCollection;

/** @class TrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulse {

  friend class MutableTrackerPulse;
  friend class TrackerPulseCollection;
  friend class TrackerPulseCollectionIterator;

public:
  using mutable_type = MutableTrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  TrackerPulse();
  TrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  TrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  TrackerPulse(const TrackerPulse& other);

  /// copy-assignment operator
  TrackerPulse& operator=(TrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~TrackerPulse();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerPulse& a, TrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerPulse& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerPulse_H
#define EDM4HEP_MutableTrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerPulse.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {


/** @class MutableTrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class MutableTrackerPulse {

  friend class TrackerPulseCollection;
  friend class TrackerPulseMutableCollectionIterator;
  friend class TrackerPulse;

public:
  using object_type = TrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  MutableTrackerPulse();
  MutableTrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  MutableTrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  MutableTrackerPulse(const MutableTrackerPulse& other);

  /// copy-assignment operator
  MutableTrackerPulse& operator=(MutableTrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~MutableTrackerPulse();

  /// conversion to const object
  operator TrackerPulse() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the time [ns].
  void setTime(float value);

  /// Set the charge [fC].
  void setCharge(float value);

  /// Set the quality.
  void setQuality(std::int16_t value);

  /// Set the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  void setCovMatrix(std::array<float, 3> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to lower triangle covariance matrix of the charge(c) and time(t) measurements.
  std::array<float, 3>& covMatrix();


  /// Set the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  void setTimeSeries(edm4hep::TimeSeries value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerPulse& a, MutableTrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseOBJ_H
#define EDM4HEP_TrackerPulseOBJ_H

// data model specific includes
#include "edm4hep/TrackerPulseData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TimeSeries;
}


namespace edm4hep {

class TrackerPulse;

class TrackerPulseObj : public podio::ObjBase {
public:
  /// constructor
  TrackerPulseObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerPulseObj(const TrackerPulseObj&);
  /// constructor from ObjectID and TrackerPulseData
  /// does not initialize the internal relation containers
  TrackerPulseObj(const podio::ObjectID id, TrackerPulseData data);
  /// No assignment operator
  TrackerPulseObj& operator=(const TrackerPulseObj&) = delete;
  virtual ~TrackerPulseObj();

public:
  TrackerPulseData data;
  edm4hep::TimeSeries* m_timeSeries{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_CollectionData_H
#define EDM4HEP_TrackerPulse_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TimeSeries.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerPulseObjPointerContainer = std::deque<TrackerPulseObj*>;
using TrackerPulseDataContainer = std::vector<TrackerPulseData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerPulseCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerPulseObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerPulseCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerPulseCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerPulseCollectionData(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData& operator=(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData(TrackerPulseCollectionData&& other) = default;
  TrackerPulseCollectionData& operator=(TrackerPulseCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerPulseCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TimeSeries> m_rel_timeSeries{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerPulseDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterDATA_H
#define EDM4HEP_RecIonizationClusterDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RecIonizationClusterData
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float significance{}; ///< significance.
  std::int16_t type{}; ///< type.

  unsigned int trackerPulse_begin{};
  unsigned int trackerPulse_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_H
#define EDM4HEP_RecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRecIonizationCluster;
class RecIonizationClusterCollection;

/** @class RecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationCluster {

  friend class MutableRecIonizationCluster;
  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableRecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  RecIonizationCluster();
  RecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  RecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  RecIonizationCluster(const RecIonizationCluster& other);

  /// copy-assignment operator
  RecIonizationCluster& operator=(RecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~RecIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecIonizationCluster& a, RecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecIonizationCluster_H
#define EDM4HEP_MutableRecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecIonizationCluster.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecIonizationCluster {

  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterMutableCollectionIterator;
  friend class RecIonizationCluster;

public:
  using object_type = RecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  MutableRecIonizationCluster();
  MutableRecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  MutableRecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  MutableRecIonizationCluster(const MutableRecIonizationCluster& other);

  /// copy-assignment operator
  MutableRecIonizationCluster& operator=(MutableRecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~MutableRecIonizationCluster();

  /// conversion to const object
  operator RecIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the significance.
  void setSignificance(float value);

  /// Set the type.
  void setType(std::int16_t value);



  void addToTrackerPulse(edm4hep::TrackerPulse);
  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecIonizationCluster& a, MutableRecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterOBJ_H
#define EDM4HEP_RecIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/TrackerPulse.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RecIonizationCluster;

class RecIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  RecIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecIonizationClusterObj(const RecIonizationClusterObj&);
  /// constructor from ObjectID and RecIonizationClusterData
  /// does not initialize the internal relation containers
  RecIonizationClusterObj(const podio::ObjectID id, RecIonizationClusterData data);
  /// No assignment operator
  RecIonizationClusterObj& operator=(const RecIonizationClusterObj&) = delete;
  virtual ~RecIonizationClusterObj();

public:
  RecIonizationClusterData data;
  std::vector<edm4hep::TrackerPulse>* m_trackerPulse{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_CollectionData_H
#define EDM4HEP_RecIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/TrackerPulse.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecIonizationClusterObjPointerContainer = std::deque<RecIonizationClusterObj*>;
using RecIonizationClusterDataContainer = std::vector<RecIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecIonizationClusterCollectionData(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData& operator=(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData(RecIonizationClusterCollectionData&& other) = default;
  RecIonizationClusterCollectionData& operator=(RecIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerPulse> m_rel_trackerPulse;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerPulse>> m_rel_trackerPulse_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesDATA_H
#define EDM4HEP_TimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TimeSeriesData
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeriesData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< begin time [ns].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int amplitude_begin{};
  unsigned int amplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_H
#define EDM4HEP_TimeSeries_H

#include "edm4hep/TimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTimeSeries;
class TimeSeriesCollection;

/** @class TimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeries {

  friend class MutableTimeSeries;
  friend class TimeSeriesCollection;
  friend class TimeSeriesCollectionIterator;

public:
  using mutable_type = MutableTimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  TimeSeries();
  TimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  TimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  TimeSeries(const TimeSeries& other);

  /// copy-assignment operator
  TimeSeries& operator=(TimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~TimeSeries();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TimeSeries& a, TimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTimeSeries_H
#define EDM4HEP_MutableTimeSeries_H

#include "edm4hep/TimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class MutableTimeSeries {

  friend class TimeSeriesCollection;
  friend class TimeSeriesMutableCollectionIterator;
  friend class TimeSeries;

public:
  using object_type = TimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  MutableTimeSeries();
  MutableTimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  MutableTimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  MutableTimeSeries(const MutableTimeSeries& other);

  /// copy-assignment operator
  MutableTimeSeries& operator=(MutableTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~MutableTimeSeries();

  /// conversion to const object
  operator TimeSeries() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the begin time [ns].
  void setTime(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAmplitude(float);
  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const TimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTimeSeries& a, MutableTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesOBJ_H
#define EDM4HEP_TimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/TimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TimeSeries;

class TimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  TimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  TimeSeriesObj(const TimeSeriesObj&);
  /// constructor from ObjectID and TimeSeriesData
  /// does not initialize the internal relation containers
  TimeSeriesObj(const podio::ObjectID id, TimeSeriesData data);
  /// No assignment operator
  TimeSeriesObj& operator=(const TimeSeriesObj&) = delete;
  virtual ~TimeSeriesObj();

public:
  TimeSeriesData data;
  std::vector<float>* m_amplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_CollectionData_H
#define EDM4HEP_TimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TimeSeriesObjPointerContainer = std::deque<TimeSeriesObj*>;
using TimeSeriesDataContainer = std::vector<TimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TimeSeriesCollectionData(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData& operator=(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData(TimeSeriesCollectionData&& other) = default;
  TimeSeriesCollectionData& operator=(TimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_amplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_amplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxDATA_H
#define EDM4HEP_RecDqdxDATA_H

#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class RecDqdxData
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdxData {
public:
  ::edm4hep::Quantity dQdx{}; ///< the reconstructed dEdx or dNdx and its error
  std::int16_t particleType{}; ///< particle type, e(0),mu(1),pi(2),K(3),p(4).
  std::int16_t type{}; ///< type.
  std::array<edm4hep::Hypothesis, 5> hypotheses{}; ///< 5 particle hypothesis

  unsigned int hitData_begin{};
  unsigned int hitData_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_H
#define EDM4HEP_RecDqdx_H

#include "edm4hep/RecDqdxObj.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {

class MutableRecDqdx;
class RecDqdxCollection;

/** @class RecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdx {

  friend class MutableRecDqdx;
  friend class RecDqdxCollection;
  friend class RecDqdxCollectionIterator;

public:
  using mutable_type = MutableRecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  RecDqdx();
  RecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  RecDqdx(RecDqdxObj* obj);

  /// copy constructor
  RecDqdx(const RecDqdx& other);

  /// copy-assignment operator
  RecDqdx& operator=(RecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~RecDqdx();


public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecDqdx& a, RecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecDqdx& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecDqdx_H
#define EDM4HEP_MutableRecDqdx_H

#include "edm4hep/RecDqdxObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecDqdx.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {


/** @class MutableRecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecDqdx {

  friend class RecDqdxCollection;
  friend class RecDqdxMutableCollectionIterator;
  friend class RecDqdx;

public:
  using object_type = RecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  MutableRecDqdx();
  MutableRecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  MutableRecDqdx(RecDqdxObj* obj);

  /// copy constructor
  MutableRecDqdx(const MutableRecDqdx& other);

  /// copy-assignment operator
  MutableRecDqdx& operator=(MutableRecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~MutableRecDqdx();

  /// conversion to const object
  operator RecDqdx() const;

public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  /// Set the the reconstructed dEdx or dNdx and its error
  void setDQdx(edm4hep::Quantity value);
  /// Get reference to the reconstructed dEdx or dNdx and its error
  edm4hep::Quantity& dQdx();

  /// Set the particle type, e(0),mu(1),pi(2),K(3),p(4).
  void setParticleType(std::int16_t value);

  /// Set the type.
  void setType(std::int16_t value);

  /// Set the 5 particle hypothesis
  void setHypotheses(std::array<edm4hep::Hypothesis, 5> value);
  void setHypotheses(size_t i, edm4hep::Hypothesis value);
  /// Get reference to 5 particle hypothesis
  std::array<edm4hep::Hypothesis, 5>& hypotheses();


  /// Set the the corresponding track.
  void setTrack(edm4hep::Track value);

  void addToHitData(edm4hep::HitLevelData);
  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecDqdx& a, MutableRecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxOBJ_H
#define EDM4HEP_RecDqdxOBJ_H

// data model specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/HitLevelData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Track;
}


namespace edm4hep {

class RecDqdx;

class RecDqdxObj : public podio::ObjBase {
public:
  /// constructor
  RecDqdxObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecDqdxObj(const RecDqdxObj&);
  /// constructor from ObjectID and RecDqdxData
  /// does not initialize the internal relation containers
  RecDqdxObj(const podio::ObjectID id, RecDqdxData data);
  /// No assignment operator
  RecDqdxObj& operator=(const RecDqdxObj&) = delete;
  virtual ~RecDqdxObj();

public:
  RecDqdxData data;
  edm4hep::Track* m_track{nullptr};
  std::vector<edm4hep::HitLevelData>* m_hitData{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_CollectionData_H
#define EDM4HEP_RecDqdx_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecDqdxObjPointerContainer = std::deque<RecDqdxObj*>;
using RecDqdxDataContainer = std::vector<RecDqdxData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecDqdxCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecDqdxObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecDqdxCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecDqdxCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecDqdxCollectionData(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData& operator=(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData(RecDqdxCollectionData&& other) = default;
  RecDqdxCollectionData& operator=(RecDqdxCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecDqdxCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecDqdxObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_track{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<edm4hep::HitLevelData> m_vec_hitData{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::HitLevelData>> m_vecs_hitData{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecDqdxDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#include "podio/DatamodelRegistry.h"
#include "podio/SchemaEvolution.h"

namespace edm4hep::meta {
/**
 * The complete definition of the datamodel at generation time in JSON format.
 */
static constexpr auto edm4hep__JSONDefinition = R"DATAMODELDEF({"options": {"getSyntax": true, "exposePODMembers": false, "includeSubfolder": "edm4hep/", "schema_version": 1}, "schema_version": 1, "components": {"edm4hep::Vector3f": {"Members": ["float x", "float y", "float z"], "ExtraCode": {"declaration": " constexpr Vector3f() : x(0),y(0),z(0) {}\n constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr float operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector3d": {"Members": ["double x", "double y", "double z"], "ExtraCode": {"declaration": " constexpr Vector3d() : x(0),y(0),z(0) {}\n constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr double operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector2i": {"Members": ["std::int32_t a", "std::int32_t b"], "ExtraCode": {"declaration": " constexpr Vector2i() : a(0),b(0) {}\n constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}\n constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }\n constexpr int operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::Vector2f": {"Members": ["float a", "float b"], "ExtraCode": {"declaration": " constexpr Vector2f() : a(0),b(0) {}\n constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}\n constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }\n constexpr float operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::TrackState": {"Members": ["std::int32_t location // for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation", "float D0 // transverse impact parameter", "float phi // azimuthal angle", "float omega // is the signed curvature of the track in [1/mm].", "float Z0 // longitudinal impact parameter", "float tanLambda // lambda is the dip angle of the track in r-z", "float time // time of the track at this trackstate", "edm4hep::Vector3f referencePoint // Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]", "std::array<float, 21> covMatrix // lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix."], "ExtraCode": {"declaration": " static const int AtOther = 0 ; // any location other than the ones defined below\n static const int AtIP = 1 ;\n static const int AtFirstHit = 2 ;\n static const int AtLastHit = 3 ;\n static const int AtCalorimeter = 4 ;\n static const int AtVertex = 5 ;\n static const int LastLocation = AtVertex  ;\n "}}, "edm4hep::ObjectID": {"Members": ["std::int32_t index", "std::int32_t collectionID"], "ExtraCode": {"includes": "#include <podio/ObjectID.h>\n", "declaration": " ObjectID() = default;\n ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}\n "}}, "edm4hep::Quantity": {"Members": ["std::int16_t type // flag identifying how to interpret the quantity", "float value // value of the quantity", "float error // error on the value of the quantity"]}, "edm4hep::Hypothesis": {"Members": ["float chi2 // chi2", "float expected // expected value", "float sigma // sigma value"]}, "edm4hep::HitLevelData": {"Members": ["std::uint64_t cellID // cell id", "std::uint32_t N // number of reconstructed ionization cluster.", "float eDep // reconstructed energy deposit [GeV].", "float pathLength // track path length [mm]."]}}, "datatypes": {"edm4hep::EventHeader": {"Description": "Event Header. Additional parameters are assumed to go into the metadata tree.", "Author": "F.Gaede", "Members": ["std::int32_t eventNumber // event number", "std::int32_t runNumber // run number", "std::uint64_t timeStamp // time stamp", "float weight // event weight"], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCParticle": {"Description": "The Monte Carlo particle - based on the lcio::MCParticle.", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the particle", "std::int32_t generatorStatus // status of the particle as defined by the generator", "std::int32_t simulatorStatus // status of the particle from the simulation program - use BIT constants below", "float charge // particle charge", "float time // creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.", "double mass // mass of the particle in [GeV]", "edm4hep::Vector3d vertex // production vertex of the particle in [mm].", "edm4hep::Vector3d endpoint // endpoint of the particle in [mm]", "edm4hep::Vector3f momentum // particle 3-momentum at the production vertex in [GeV]", "edm4hep::Vector3f momentumAtEndpoint // particle 3-momentum at the endpoint in [GeV]", "edm4hep::Vector3f spin // spin (helicity) vector of the particle.", "edm4hep::Vector2i colorFlow // color flow as defined by the generator"], "OneToManyRelations": ["edm4hep::MCParticle parents // The parents of this particle.", "edm4hep::MCParticle daughters // The daughters this particle."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               \n void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  \t\t     \n void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  \t\t\t     \n void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } \n void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  \t\t     \n void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  \t\t     \n void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  \t\t\t     \n void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  \t\t\t\t     \n void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         \n "}, "ExtraCode": {"declaration": " // define the bit positions for the simulation flag\n static const int BITEndpoint = 31;\n static const int BITCreatedInSimulation = 30;\n static const int BITBackscatter = 29 ;\n static const int BITVertexIsNotEndpointOfParent = 28 ;  \n static const int BITDecayedInTracker = 27 ; \n static const int BITDecayedInCalorimeter = 26 ;   \n static const int BITLeftDetector = 25 ;     \n static const int BITStopped = 24 ;    \n static const int BITOverlay = 23 ;    \n /// return energy computed from momentum and mass \n double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+\n getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} \n\n/// True if the particle has been created by the simulation program (rather than the generator).     \n bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    \n /// True if the particle is the result of a backscatter from a calorimeter shower. \n bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   \n /// True if the particle's vertex is not the endpoint of the  parent particle.     \n bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } \n /// True if the particle has interacted in a tracking region.                \n bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     \n /// True if the particle has interacted in a calorimeter region.             \n bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   \n /// True if the particle has left the world volume undecayed.                \n bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }\n /// True if the particle has been stopped by the simulation program.         \n bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     \n /// True if the particle has been overlayed by the simulation (or digitization)  program.\n bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     \n "}, "VectorMembers": [], "OneToOneRelations": []}, "edm4hep::SimTrackerHit": {"Description": "Simulated tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float EDep // energy deposited in the hit [GeV].", "float time // proper time of the hit in the lab frame in [ns].", "float pathLength // path length of the particle in the sensitive material that resulted in this hit.", "std::int32_t quality // quality bit flag.", "edm4hep::Vector3d position // the hit position in [mm].", "edm4hep::Vector3f momentum // the 3-momentum of the particle at the hits position in [GeV]"], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // MCParticle that caused the hit."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }\n void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }\n void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }\n "}, "ExtraCode": {"declaration": " static const int  BITOverlay = 31;\n static const int  BITProducedBySecondary = 30;\n bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }\n bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }\n double x() const {return getPosition()[0];}\n double y() const {return getPosition()[1];}\n double z() const {return getPosition()[2];}\n double rho() const {return sqrt(x()*x() + y()*y());}\n "}, "VectorMembers": [], "OneToManyRelations": []}, "edm4hep::CaloHitContribution": {"Description": "Monte Carlo contribution to SimCalorimeterHit", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the shower particle that caused this contribution.", "float energy // energy in [GeV] of the this contribution", "float time // time in [ns] of this contribution", "edm4hep::Vector3f stepPosition // position of this energy deposition (step) [mm]"], "OneToOneRelations": ["edm4hep::MCParticle particle // primary MCParticle that caused the shower responsible for this contribution to the hit."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimCalorimeterHit": {"Description": "Simulated calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float energy // energy of the hit in [GeV].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm]."], "OneToManyRelations": ["edm4hep::CaloHitContribution contributions // Monte Carlo step contribution - parallel to particle"], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawCalorimeterHit": {"Description": "Raw calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "std::int32_t amplitude // amplitude of the hit in ADC counts.", "std::int32_t timeStamp // time stamp for the hit."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::CalorimeterHit": {"Description": "Calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "float energy // energy of the hit in [GeV].", "float energyError // error of the hit energy in [GeV].", "float time // time of the hit in [ns].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm].", "std::int32_t type // type of hit. Mapping of integer types to names via collection parameters \"CalorimeterHitTypeNames\" and \"CalorimeterHitTypeValues\"."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ParticleID": {"Description": "ParticleID", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // userdefined type", "std::int32_t PDG // PDG code of this id - ( 999999 ) if unknown.", "std::int32_t algorithmType // type of the algorithm/module that created this hypothesis", "float likelihood // likelihood of this hypothesis - in a user defined normalization."], "VectorMembers": ["float parameters // parameters associated with this hypothesis. Check/set collection parameters ParameterNames_PIDAlgorithmTypeName for decoding the indices."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Cluster": {"Description": "Calorimeter Hit Cluster", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of cluster. Bits 16-31 are used internally.", "float energy // energy of the cluster [GeV]", "float energyError // error on the energy", "edm4hep::Vector3f position // position of the cluster [mm]", "std::array<float, 6> positionError // covariance matrix of the position (6 Parameters)", "float iTheta // intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.", "float phi // intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.", "edm4hep::Vector3f directionError // covariance matrix of the direction (3 Parameters) [mm^2]"], "VectorMembers": ["float shapeParameters // shape parameters - check/set collection parameter ClusterShapeParameters for size and names of parameters.", "float subdetectorEnergies // energy observed in a particular subdetector. Check/set collection parameter ClusterSubdetectorNames for decoding the indices of the array."], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been combined to this cluster.", "edm4hep::CalorimeterHit hits // hits that have been combined to this cluster.", "edm4hep::ParticleID particleIDs // particle IDs (sorted by their likelihood)"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHit": {"Description": "Tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHitPlane": {"Description": "Tracker hit plane", "Author": "Placido Fernandez Declara, CERN", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector2f u // measurement direction vector, u lies in the x-y plane", "edm4hep::Vector2f v // measurement direction vector, v is along z", "float du // measurement error along the direction", "float dv // measurement error along the direction", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawTimeSeries": {"Description": "Raw data of a detector readout", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific cell id.", "std::int32_t quality // quality flag for the hit.", "float time // time of the hit [ns].", "float charge // integrated charge of the hit [fC].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["std::int32_t adcCounts // raw data (32-bit) word at i."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Track": {"Description": "Reconstructed track", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of track.Bits 16-31 are used internally", "float chi2 // Chi^2 of the track fit", "std::int32_t ndf // number of degrees of freedom of the track fit", "float dEdx // dEdx of the track.", "float dEdxError // error of dEdx.", "float radiusOfInnermostHit // radius of the innermost hit that has been used in the track fit"], "VectorMembers": ["std::int32_t subdetectorHitNumbers // number of hits in particular subdetectors.Check/set collection variable TrackSubdetectorNames for decoding the indices", "edm4hep::TrackState trackStates // track states", "edm4hep::Quantity dxQuantities // different measurements of dx quantities"], "OneToManyRelations": ["edm4hep::TrackerHit trackerHits // hits that have been used to create this track", "edm4hep::Track tracks // tracks (segments) that have been combined to create this track"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Vertex": {"Description": "Vertex", "Author": "F.Gaede, DESY", "Members": ["std::int32_t primary // boolean flag, if vertex is the primary vertex of the event", "float chi2 // chi-squared of the vertex fit", "float probability // probability of the vertex fit", "edm4hep::Vector3f position // [mm] position of the vertex.", "std::array<float, 6> covMatrix // covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )", "std::int32_t algorithmType // type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType."], "VectorMembers": ["float parameters // additional parameters related to this vertex - check/set the collection parameter \"VertexParameterNames\" for the parameters meaning."], "OneToOneRelations": ["edm4hep::ReconstructedParticle associatedParticle // reconstructed particle associated to this vertex."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ReconstructedParticle": {"Description": "Reconstructed Particle", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.", "float energy // [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f momentum // [GeV] particle momentum. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f referencePoint // [mm] reference, i.e. where the particle has been measured", "float charge // charge of the reconstructed particle.", "float mass // [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.", "float goodnessOfPID // overall goodness of the PID on a scale of [0;1]", "std::array<float, 10> covMatrix // cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##"], "OneToOneRelations": ["edm4hep::Vertex startVertex // start vertex associated to this particle", "edm4hep::ParticleID particleIDUsed // particle Id used for the kinematics of this particle"], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been used for this particle.", "edm4hep::Track tracks // tracks that have been used for this particle.", "edm4hep::ReconstructedParticle particles // reconstructed particles that have been combined to this particle.", "edm4hep::ParticleID particleIDs // particle Ids (not sorted by their likelihood)"], "ExtraCode": {"declaration": " bool isCompound() const { return particles_size() > 0 ;}\n "}, "MutableExtraCode": {"declaration": " //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.\n //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }\n "}, "VectorMembers": []}, "edm4hep::MCRecoParticleAssociation": {"Description": "Used to keep track of the correspondence between MC and reconstructed particles", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloAssociation": {"Description": "Association between a CaloHit and the corresponding simulated CaloHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::SimCalorimeterHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerAssociation": {"Description": "Association between a TrackerHit and the corresponding simulated TrackerHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHit rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerHitPlaneAssociation": {"Description": "Association between a TrackerHitPlane and the corresponding simulated TrackerHit", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHitPlane rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloParticleAssociation": {"Description": "Association between a CalorimeterHit and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoClusterParticleAssociation": {"Description": "Association between a Cluster and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Cluster rec // reference to the cluster", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackParticleAssociation": {"Description": "Association between a Track and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Track rec // reference to the track", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecoParticleVertexAssociation": {"Description": "Association between a Reconstructed Particle and a Vertex", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::Vertex vertex // reference to the vertex"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimPrimaryIonizationCluster": {"Description": "Simulated Primary Ionization", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // the primary ionization's time in the lab frame [ns].", "edm4hep::Vector3d position // the primary ionization's position [mm].", "std::int16_t type // type."], "VectorMembers": ["std::uint64_t electronCellID // cell id.", "float electronTime // the time in the lab frame [ns].", "edm4hep::Vector3d electronPosition // the position in the lab frame [mm].", "float pulseTime // the pulse's time in the lab frame [ns].", "float pulseAmplitude // the pulse's amplitude [fC]."], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // the particle that caused the ionizing collisions."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerPulse": {"Description": "Reconstructed Tracker Pulse", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // time [ns].", "float charge // charge [fC].", "std::int16_t quality // quality.", "std::array<float, 3> covMatrix // lower triangle covariance matrix of the charge(c) and time(t) measurements."], "OneToOneRelations": ["edm4hep::TimeSeries timeSeries // Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecIonizationCluster": {"Description": "Reconstructed Ionization Cluster", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float significance // significance.", "std::int16_t type // type."], "OneToManyRelations": ["edm4hep::TrackerPulse trackerPulse // the TrackerPulse used to create the ionization cluster."], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TimeSeries": {"Description": "Calibrated Detector Data", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // begin time [ns].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["float amplitude // calibrated detector data."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecDqdx": {"Description": "dN/dx or dE/dx info of Track.", "Author": "Wenxing Fang, IHEP", "Members": ["edm4hep::Quantity dQdx // the reconstructed dEdx or dNdx and its error", "std::int16_t particleType // particle type, e(0),mu(1),pi(2),K(3),p(4).", "std::int16_t type // type.", "std::array<edm4hep::Hypothesis, 5> hypotheses // 5 particle hypothesis"], "VectorMembers": ["edm4hep::HitLevelData hitData // hit level data"], "OneToOneRelations": ["edm4hep::Track track // the corresponding track."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}}})DATAMODELDEF";


/**
 * The names of all relations and vector members for all datatypes
 */
inline podio::RelationNameMapping edm4hep__getRelationNames() {
  using namespace std::string_view_literals;
  return {
    {"edm4hep::EventHeader"sv,
      {  },
      {  },
    },
    {"edm4hep::MCParticle"sv,
      { "parents"sv, "daughters"sv },
      {  },
    },
    {"edm4hep::SimTrackerHit"sv,
      { "MCParticle"sv },
      {  },
    },
    {"edm4hep::CaloHitContribution"sv,
      { "particle"sv },
      {  },
    },
    {"edm4hep::SimCalorimeterHit"sv,
      { "contributions"sv },
      {  },
    },
    {"edm4hep::RawCalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::CalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::ParticleID"sv,
      {  },
      { "parameters"sv },
    },
    {"edm4hep::Cluster"sv,
      { "clusters"sv, "hits"sv, "particleIDs"sv },
      { "shapeParameters"sv, "subdetectorEnergies"sv },
    },
    {"edm4hep::TrackerHit"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::TrackerHitPlane"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::RawTimeSeries"sv,
      {  },
      { "adcCounts"sv },
    },
    {"edm4hep::Track"sv,
      { "trackerHits"sv, "tracks"sv },
      { "subdetectorHitNumbers"sv, "trackStates"sv, "dxQuantities"sv },
    },
    {"edm4hep::Vertex"sv,
      { "associatedParticle"sv },
      { "parameters"sv },
    },
    {"edm4hep::ReconstructedParticle"sv,
      { "clusters"sv, "tracks"sv, "particles"sv, "particleIDs"sv, "startVertex"sv, "particleIDUsed"sv },
      {  },
    },
    {"edm4hep::MCRecoParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerHitPlaneAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoClusterParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::RecoParticleVertexAssociation"sv,
      { "rec"sv, "vertex"sv },
      {  },
    },
    {"edm4hep::SimPrimaryIonizationCluster"sv,
      { "MCParticle"sv },
      { "electronCellID"sv, "electronTime"sv, "electronPosition"sv, "pulseTime"sv, "pulseAmplitude"sv },
    },
    {"edm4hep::TrackerPulse"sv,
      { "timeSeries"sv },
      {  },
    },
    {"edm4hep::RecIonizationCluster"sv,
      { "trackerPulse"sv },
      {  },
    },
    {"edm4hep::TimeSeries"sv,
      {  },
      { "amplitude"sv },
    },
    {"edm4hep::RecDqdx"sv,
      { "track"sv },
      { "hitData"sv },
    },
  };
}

/**
 * The schema version at generation time
 */
static constexpr podio::SchemaVersionT schemaVersion = 1;

/**
 * The helper class that takes care of registering the datamodel definition to
 * the DatamodelRegistry and to provide the index in that registry.
 *
 * Implemented as a singleton mainly to ensure only a single registration of
 * each datamodel, during the constructor
 */
class DatamodelRegistryIndex {
public:
  static size_t value() {
    static const auto relationNames = edm4hep__getRelationNames();
    static auto index = DatamodelRegistryIndex(podio::DatamodelRegistry::mutInstance().registerDatamodel("edm4hep", edm4hep__JSONDefinition, relationNames));
    return index.m_value;
  }
private:
  DatamodelRegistryIndex(size_t v) : m_value(v) {}
  size_t m_value{podio::DatamodelRegistry::NoDefinitionAvailable};
};


namespace static_registration {
  // The usual trick via an IIFE and a const variable that we assign to, to
  // ensure that we populate this before everything starts
  inline  bool ensureRegistration() {
    const static auto reg = []() {
      return edm4hep::meta::DatamodelRegistryIndex::value() != podio::DatamodelRegistry::NoDefinitionAvailable;
    }();
    return reg;
  }

  const auto registrationEnsured = ensureRegistration();
}

} // namespace edm4hep::meta

#undef  _BACKWARD_BACKWARD_WARNING_H

TInterpreter::A...  ERROR Error parsing payload code for class edm4hep::SimCalorimeterHitData with content:

#line 1 "libedm4hepDict dictionary payload"

#ifndef PODIO_JSON_OUTPUT
  #define PODIO_JSON_OUTPUT 1
#endif
#ifndef JSON_USE_IMPLICIT_CONVERSIONS
  #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif
#ifndef JSON_DIAGNOSTICS
  #define JSON_DIAGNOSTICS 0
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3f_H
#define EDM4HEP_Vector3f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3f
 *  
 *  @author: 
 */
class Vector3f {
public:
  float x{};
  float y{};
  float z{};

 constexpr Vector3f() : x(0),y(0),z(0) {}
 constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr float operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3d_H
#define EDM4HEP_Vector3d_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3d
 *  
 *  @author: 
 */
class Vector3d {
public:
  double x{};
  double y{};
  double z{};

 constexpr Vector3d() : x(0),y(0),z(0) {}
 constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr double operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3d& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3d& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2i_H
#define EDM4HEP_Vector2i_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2i
 *  
 *  @author: 
 */
class Vector2i {
public:
  std::int32_t a{};
  std::int32_t b{};

 constexpr Vector2i() : a(0),b(0) {}
 constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}
 constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }
 constexpr int operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2i& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2i& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2f_H
#define EDM4HEP_Vector2f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2f
 *  
 *  @author: 
 */
class Vector2f {
public:
  float a{};
  float b{};

 constexpr Vector2f() : a(0),b(0) {}
 constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}
 constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }
 constexpr float operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackState_H
#define EDM4HEP_TrackState_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class TrackState
 *  
 *  @author: 
 */
class TrackState {
public:
  std::int32_t location{}; ///< for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
  float D0{}; ///< transverse impact parameter
  float phi{}; ///< azimuthal angle
  float omega{}; ///< is the signed curvature of the track in [1/mm].
  float Z0{}; ///< longitudinal impact parameter
  float tanLambda{}; ///< lambda is the dip angle of the track in r-z
  float time{}; ///< time of the track at this trackstate
  ::edm4hep::Vector3f referencePoint{}; ///< Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
  std::array<float, 21> covMatrix{}; ///< lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.

 static const int AtOther = 0 ; // any location other than the ones defined below
 static const int AtIP = 1 ;
 static const int AtFirstHit = 2 ;
 static const int AtLastHit = 3 ;
 static const int AtCalorimeter = 4 ;
 static const int AtVertex = 5 ;
 static const int LastLocation = AtVertex  ;
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::TrackState& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackState& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ObjectID_H
#define EDM4HEP_ObjectID_H

#include <podio/ObjectID.h>
#include <cstdint>
#include <podio/ObjectID.h>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class ObjectID
 *  
 *  @author: 
 */
class ObjectID {
public:
  std::int32_t index{};
  std::int32_t collectionID{};

 ObjectID() = default;
 ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::ObjectID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ObjectID& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Quantity_H
#define EDM4HEP_Quantity_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Quantity
 *  
 *  @author: 
 */
class Quantity {
public:
  std::int16_t type{}; ///< flag identifying how to interpret the quantity
  float value{}; ///< value of the quantity
  float error{}; ///< error on the value of the quantity


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Quantity& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Quantity& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Hypothesis_H
#define EDM4HEP_Hypothesis_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Hypothesis
 *  
 *  @author: 
 */
class Hypothesis {
public:
  float chi2{}; ///< chi2
  float expected{}; ///< expected value
  float sigma{}; ///< sigma value


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Hypothesis& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Hypothesis& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_HitLevelData_H
#define EDM4HEP_HitLevelData_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class HitLevelData
 *  
 *  @author: 
 */
class HitLevelData {
public:
  std::uint64_t cellID{}; ///< cell id
  std::uint32_t N{}; ///< number of reconstructed ionization cluster.
  float eDep{}; ///< reconstructed energy deposit [GeV].
  float pathLength{}; ///< track path length [mm].


};

std::ostream& operator<<(std::ostream& o, const edm4hep::HitLevelData& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const HitLevelData& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderDATA_H
#define EDM4HEP_EventHeaderDATA_H

#include <cstdint>

namespace edm4hep {


/** @class EventHeaderData
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeaderData {
public:
  std::int32_t eventNumber{}; ///< event number
  std::int32_t runNumber{}; ///< run number
  std::uint64_t timeStamp{}; ///< time stamp
  float weight{}; ///< event weight

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_H
#define EDM4HEP_EventHeader_H

#include "edm4hep/EventHeaderObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableEventHeader;
class EventHeaderCollection;

/** @class EventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeader {

  friend class MutableEventHeader;
  friend class EventHeaderCollection;
  friend class EventHeaderCollectionIterator;

public:
  using mutable_type = MutableEventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  EventHeader();
  EventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  EventHeader(EventHeaderObj* obj);

  /// copy constructor
  EventHeader(const EventHeader& other);

  /// copy-assignment operator
  EventHeader& operator=(EventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~EventHeader();


public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const EventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableEventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const EventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(EventHeader& a, EventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const EventHeader& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableEventHeader_H
#define EDM4HEP_MutableEventHeader_H

#include "edm4hep/EventHeaderObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/EventHeader.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableEventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class MutableEventHeader {

  friend class EventHeaderCollection;
  friend class EventHeaderMutableCollectionIterator;
  friend class EventHeader;

public:
  using object_type = EventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  MutableEventHeader();
  MutableEventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  MutableEventHeader(EventHeaderObj* obj);

  /// copy constructor
  MutableEventHeader(const MutableEventHeader& other);

  /// copy-assignment operator
  MutableEventHeader& operator=(MutableEventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~MutableEventHeader();

  /// conversion to const object
  operator EventHeader() const;

public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;



  /// Set the event number
  void setEventNumber(std::int32_t value);

  /// Set the run number
  void setRunNumber(std::int32_t value);

  /// Set the time stamp
  void setTimeStamp(std::uint64_t value);

  /// Set the event weight
  void setWeight(float value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableEventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const EventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableEventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableEventHeader& a, MutableEventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableEventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderOBJ_H
#define EDM4HEP_EventHeaderOBJ_H

// data model specific includes
#include "edm4hep/EventHeaderData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class EventHeader;

class EventHeaderObj : public podio::ObjBase {
public:
  /// constructor
  EventHeaderObj();
  /// copy constructor (does a deep-copy of relation containers)
  EventHeaderObj(const EventHeaderObj&);
  /// constructor from ObjectID and EventHeaderData
  /// does not initialize the internal relation containers
  EventHeaderObj(const podio::ObjectID id, EventHeaderData data);
  /// No assignment operator
  EventHeaderObj& operator=(const EventHeaderObj&) = delete;
  virtual ~EventHeaderObj() = default;

public:
  EventHeaderData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_CollectionData_H
#define EDM4HEP_EventHeader_CollectionData_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeaderObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using EventHeaderObjPointerContainer = std::deque<EventHeaderObj*>;
using EventHeaderDataContainer = std::vector<EventHeaderData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class EventHeaderCollectionData {
public:
  /**
   * The Objs of this collection
   */
  EventHeaderObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  EventHeaderCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  EventHeaderCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  EventHeaderCollectionData(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData& operator=(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData(EventHeaderCollectionData&& other) = default;
  EventHeaderCollectionData& operator=(EventHeaderCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~EventHeaderCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<EventHeaderDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleDATA_H
#define EDM4HEP_MCParticleDATA_H

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class MCParticleData
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticleData {
public:
  std::int32_t PDG{}; ///< PDG code of the particle
  std::int32_t generatorStatus{}; ///< status of the particle as defined by the generator
  std::int32_t simulatorStatus{}; ///< status of the particle from the simulation program - use BIT constants below
  float charge{}; ///< particle charge
  float time{}; ///< creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  double mass{}; ///< mass of the particle in [GeV]
  ::edm4hep::Vector3d vertex{}; ///< production vertex of the particle in [mm].
  ::edm4hep::Vector3d endpoint{}; ///< endpoint of the particle in [mm]
  ::edm4hep::Vector3f momentum{}; ///< particle 3-momentum at the production vertex in [GeV]
  ::edm4hep::Vector3f momentumAtEndpoint{}; ///< particle 3-momentum at the endpoint in [GeV]
  ::edm4hep::Vector3f spin{}; ///< spin (helicity) vector of the particle.
  ::edm4hep::Vector2i colorFlow{}; ///< color flow as defined by the generator

  unsigned int parents_begin{};
  unsigned int parents_end{};
  unsigned int daughters_begin{};
  unsigned int daughters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_H
#define EDM4HEP_MCParticle_H

#include "edm4hep/MCParticleObj.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableMCParticle;
class MCParticleCollection;

/** @class MCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticle {

  friend class MutableMCParticle;
  friend class MCParticleCollection;
  friend class MCParticleCollectionIterator;

public:
  using mutable_type = MutableMCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MCParticle();
  MCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MCParticle(MCParticleObj* obj);

  /// copy constructor
  MCParticle(const MCParticle& other);

  /// copy-assignment operator
  MCParticle& operator=(MCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MCParticle();


public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCParticle& a, MCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCParticle_H
#define EDM4HEP_MutableMCParticle_H

#include "edm4hep/MCParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCParticle.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableMCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MutableMCParticle {

  friend class MCParticleCollection;
  friend class MCParticleMutableCollectionIterator;
  friend class MCParticle;

public:
  using object_type = MCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MutableMCParticle();
  MutableMCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MutableMCParticle(MCParticleObj* obj);

  /// copy constructor
  MutableMCParticle(const MutableMCParticle& other);

  /// copy-assignment operator
  MutableMCParticle& operator=(MutableMCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MutableMCParticle();

  /// conversion to const object
  operator MCParticle() const;

public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  /// Set the PDG code of the particle
  void setPDG(std::int32_t value);

  /// Set the status of the particle as defined by the generator
  void setGeneratorStatus(std::int32_t value);

  /// Set the status of the particle from the simulation program - use BIT constants below
  void setSimulatorStatus(std::int32_t value);

  /// Set the particle charge
  void setCharge(float value);

  /// Set the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  void setTime(float value);

  /// Set the mass of the particle in [GeV]
  void setMass(double value);

  /// Set the production vertex of the particle in [mm].
  void setVertex(edm4hep::Vector3d value);
  /// Get reference to production vertex of the particle in [mm].
  edm4hep::Vector3d& vertex();

  /// Set the endpoint of the particle in [mm]
  void setEndpoint(edm4hep::Vector3d value);
  /// Get reference to endpoint of the particle in [mm]
  edm4hep::Vector3d& endpoint();

  /// Set the particle 3-momentum at the production vertex in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the production vertex in [GeV]
  edm4hep::Vector3f& momentum();

  /// Set the particle 3-momentum at the endpoint in [GeV]
  void setMomentumAtEndpoint(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the endpoint in [GeV]
  edm4hep::Vector3f& momentumAtEndpoint();

  /// Set the spin (helicity) vector of the particle.
  void setSpin(edm4hep::Vector3f value);
  /// Get reference to spin (helicity) vector of the particle.
  edm4hep::Vector3f& spin();

  /// Set the color flow as defined by the generator
  void setColorFlow(edm4hep::Vector2i value);
  /// Get reference to color flow as defined by the generator
  edm4hep::Vector2i& colorFlow();



  void addToParents(edm4hep::MCParticle);
  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  void addToDaughters(edm4hep::MCParticle);
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               
 void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  		     
 void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  			     
 void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } 
 void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  		     
 void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  		     
 void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  			     
 void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  				     
 void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCParticle& a, MutableMCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleOBJ_H
#define EDM4HEP_MCParticleOBJ_H

// data model specific includes
#include "edm4hep/MCParticleData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class MCParticle;

class MCParticleObj : public podio::ObjBase {
public:
  /// constructor
  MCParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCParticleObj(const MCParticleObj&);
  /// constructor from ObjectID and MCParticleData
  /// does not initialize the internal relation containers
  MCParticleObj(const podio::ObjectID id, MCParticleData data);
  /// No assignment operator
  MCParticleObj& operator=(const MCParticleObj&) = delete;
  virtual ~MCParticleObj();

public:
  MCParticleData data;
  std::vector<edm4hep::MCParticle>* m_parents{nullptr};
  std::vector<edm4hep::MCParticle>* m_daughters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_CollectionData_H
#define EDM4HEP_MCParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticleObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCParticleObjPointerContainer = std::deque<MCParticleObj*>;
using MCParticleDataContainer = std::vector<MCParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCParticleCollectionData(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData& operator=(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData(MCParticleCollectionData&& other) = default;
  MCParticleCollectionData& operator=(MCParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(MCParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_parents;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_parents_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::MCParticle> m_rel_daughters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_daughters_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitDATA_H
#define EDM4HEP_SimTrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimTrackerHitData
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float EDep{}; ///< energy deposited in the hit [GeV].
  float time{}; ///< proper time of the hit in the lab frame in [ns].
  float pathLength{}; ///< path length of the particle in the sensitive material that resulted in this hit.
  std::int32_t quality{}; ///< quality bit flag.
  ::edm4hep::Vector3d position{}; ///< the hit position in [mm].
  ::edm4hep::Vector3f momentum{}; ///< the 3-momentum of the particle at the hits position in [GeV]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_H
#define EDM4HEP_SimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimTrackerHit;
class SimTrackerHitCollection;

/** @class SimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHit {

  friend class MutableSimTrackerHit;
  friend class SimTrackerHitCollection;
  friend class SimTrackerHitCollectionIterator;

public:
  using mutable_type = MutableSimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  SimTrackerHit();
  SimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  SimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  SimTrackerHit(const SimTrackerHit& other);

  /// copy-assignment operator
  SimTrackerHit& operator=(SimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~SimTrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimTrackerHit& a, SimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimTrackerHit_H
#define EDM4HEP_MutableSimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimTrackerHit.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableSimTrackerHit {

  friend class SimTrackerHitCollection;
  friend class SimTrackerHitMutableCollectionIterator;
  friend class SimTrackerHit;

public:
  using object_type = SimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  MutableSimTrackerHit();
  MutableSimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  MutableSimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  MutableSimTrackerHit(const MutableSimTrackerHit& other);

  /// copy-assignment operator
  MutableSimTrackerHit& operator=(MutableSimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~MutableSimTrackerHit();

  /// conversion to const object
  operator SimTrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy deposited in the hit [GeV].
  void setEDep(float value);

  /// Set the proper time of the hit in the lab frame in [ns].
  void setTime(float value);

  /// Set the path length of the particle in the sensitive material that resulted in this hit.
  void setPathLength(float value);

  /// Set the quality bit flag.
  void setQuality(std::int32_t value);

  /// Set the the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the the 3-momentum of the particle at the hits position in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to the 3-momentum of the particle at the hits position in [GeV]
  edm4hep::Vector3f& momentum();


  /// Set the MCParticle that caused the hit.
  void setMCParticle(edm4hep::MCParticle value);


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }
 void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }
 void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimTrackerHit& a, MutableSimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitOBJ_H
#define EDM4HEP_SimTrackerHitOBJ_H

// data model specific includes
#include "edm4hep/SimTrackerHitData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimTrackerHit;

class SimTrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  SimTrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimTrackerHitObj(const SimTrackerHitObj&);
  /// constructor from ObjectID and SimTrackerHitData
  /// does not initialize the internal relation containers
  SimTrackerHitObj(const podio::ObjectID id, SimTrackerHitData data);
  /// No assignment operator
  SimTrackerHitObj& operator=(const SimTrackerHitObj&) = delete;
  virtual ~SimTrackerHitObj();

public:
  SimTrackerHitData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_CollectionData_H
#define EDM4HEP_SimTrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimTrackerHitObjPointerContainer = std::deque<SimTrackerHitObj*>;
using SimTrackerHitDataContainer = std::vector<SimTrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimTrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimTrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimTrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimTrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimTrackerHitCollectionData(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData& operator=(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData(SimTrackerHitCollectionData&& other) = default;
  SimTrackerHitCollectionData& operator=(SimTrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimTrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimTrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionDATA_H
#define EDM4HEP_CaloHitContributionDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CaloHitContributionData
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContributionData {
public:
  std::int32_t PDG{}; ///< PDG code of the shower particle that caused this contribution.
  float energy{}; ///< energy in [GeV] of the this contribution
  float time{}; ///< time in [ns] of this contribution
  ::edm4hep::Vector3f stepPosition{}; ///< position of this energy deposition (step) [mm]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_H
#define EDM4HEP_CaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableCaloHitContribution;
class CaloHitContributionCollection;

/** @class CaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContribution {

  friend class MutableCaloHitContribution;
  friend class CaloHitContributionCollection;
  friend class CaloHitContributionCollectionIterator;

public:
  using mutable_type = MutableCaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  CaloHitContribution();
  CaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  CaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  CaloHitContribution(const CaloHitContribution& other);

  /// copy-assignment operator
  CaloHitContribution& operator=(CaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~CaloHitContribution();


public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CaloHitContribution& a, CaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CaloHitContribution& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCaloHitContribution_H
#define EDM4HEP_MutableCaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CaloHitContribution.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableCaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class MutableCaloHitContribution {

  friend class CaloHitContributionCollection;
  friend class CaloHitContributionMutableCollectionIterator;
  friend class CaloHitContribution;

public:
  using object_type = CaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  MutableCaloHitContribution();
  MutableCaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  MutableCaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  MutableCaloHitContribution(const MutableCaloHitContribution& other);

  /// copy-assignment operator
  MutableCaloHitContribution& operator=(MutableCaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~MutableCaloHitContribution();

  /// conversion to const object
  operator CaloHitContribution() const;

public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;

  /// Set the PDG code of the shower particle that caused this contribution.
  void setPDG(std::int32_t value);

  /// Set the energy in [GeV] of the this contribution
  void setEnergy(float value);

  /// Set the time in [ns] of this contribution
  void setTime(float value);

  /// Set the position of this energy deposition (step) [mm]
  void setStepPosition(edm4hep::Vector3f value);
  /// Get reference to position of this energy deposition (step) [mm]
  edm4hep::Vector3f& stepPosition();


  /// Set the primary MCParticle that caused the shower responsible for this contribution to the hit.
  void setParticle(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const CaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCaloHitContribution& a, MutableCaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionOBJ_H
#define EDM4HEP_CaloHitContributionOBJ_H

// data model specific includes
#include "edm4hep/CaloHitContributionData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class CaloHitContribution;

class CaloHitContributionObj : public podio::ObjBase {
public:
  /// constructor
  CaloHitContributionObj();
  /// copy constructor (does a deep-copy of relation containers)
  CaloHitContributionObj(const CaloHitContributionObj&);
  /// constructor from ObjectID and CaloHitContributionData
  /// does not initialize the internal relation containers
  CaloHitContributionObj(const podio::ObjectID id, CaloHitContributionData data);
  /// No assignment operator
  CaloHitContributionObj& operator=(const CaloHitContributionObj&) = delete;
  virtual ~CaloHitContributionObj();

public:
  CaloHitContributionData data;
  edm4hep::MCParticle* m_particle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_CollectionData_H
#define EDM4HEP_CaloHitContribution_CollectionData_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CaloHitContributionObjPointerContainer = std::deque<CaloHitContributionObj*>;
using CaloHitContributionDataContainer = std::vector<CaloHitContributionData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CaloHitContributionCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CaloHitContributionObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CaloHitContributionCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CaloHitContributionCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CaloHitContributionCollectionData(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData& operator=(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData(CaloHitContributionCollectionData&& other) = default;
  CaloHitContributionCollectionData& operator=(CaloHitContributionCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CaloHitContributionCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_particle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CaloHitContributionDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitDATA_H
#define EDM4HEP_SimCalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimCalorimeterHitData
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float energy{}; ///< energy of the hit in [GeV].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].

  unsigned int contributions_begin{};
  unsigned int contributions_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_H
#define EDM4HEP_SimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableSimCalorimeterHit;
class SimCalorimeterHitCollection;

/** @class SimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHit {

  friend class MutableSimCalorimeterHit;
  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableSimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  SimCalorimeterHit();
  SimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  SimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  SimCalorimeterHit(const SimCalorimeterHit& other);

  /// copy-assignment operator
  SimCalorimeterHit& operator=(SimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~SimCalorimeterHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimCalorimeterHit& a, SimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimCalorimeterHit_H
#define EDM4HEP_MutableSimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimCalorimeterHit.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableSimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableSimCalorimeterHit {

  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitMutableCollectionIterator;
  friend class SimCalorimeterHit;

public:
  using object_type = SimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  MutableSimCalorimeterHit();
  MutableSimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  MutableSimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  MutableSimCalorimeterHit(const MutableSimCalorimeterHit& other);

  /// copy-assignment operator
  MutableSimCalorimeterHit& operator=(MutableSimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~MutableSimCalorimeterHit();

  /// conversion to const object
  operator SimCalorimeterHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();



  void addToContributions(edm4hep::CaloHitContribution);
  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimCalorimeterHit& a, MutableSimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitOBJ_H
#define EDM4HEP_SimCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/CaloHitContribution.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class SimCalorimeterHit;

class SimCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  SimCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimCalorimeterHitObj(const SimCalorimeterHitObj&);
  /// constructor from ObjectID and SimCalorimeterHitData
  /// does not initialize the internal relation containers
  SimCalorimeterHitObj(const podio::ObjectID id, SimCalorimeterHitData data);
  /// No assignment operator
  SimCalorimeterHitObj& operator=(const SimCalorimeterHitObj&) = delete;
  virtual ~SimCalorimeterHitObj();

public:
  SimCalorimeterHitData data;
  std::vector<edm4hep::CaloHitContribution>* m_contributions{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_CollectionData_H
#define EDM4HEP_SimCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/CaloHitContribution.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimCalorimeterHitObjPointerContainer = std::deque<SimCalorimeterHitObj*>;
using SimCalorimeterHitDataContainer = std::vector<SimCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimCalorimeterHitCollectionData(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData& operator=(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData(SimCalorimeterHitCollectionData&& other) = default;
  SimCalorimeterHitCollectionData& operator=(SimCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimCalorimeterHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CaloHitContribution> m_rel_contributions;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CaloHitContribution>> m_rel_contributions_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitDATA_H
#define EDM4HEP_RawCalorimeterHitDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawCalorimeterHitData
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  std::int32_t amplitude{}; ///< amplitude of the hit in ADC counts.
  std::int32_t timeStamp{}; ///< time stamp for the hit.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_H
#define EDM4HEP_RawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawCalorimeterHit;
class RawCalorimeterHitCollection;

/** @class RawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHit {

  friend class MutableRawCalorimeterHit;
  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableRawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  RawCalorimeterHit();
  RawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  RawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  RawCalorimeterHit(const RawCalorimeterHit& other);

  /// copy-assignment operator
  RawCalorimeterHit& operator=(RawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~RawCalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawCalorimeterHit& a, RawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawCalorimeterHit_H
#define EDM4HEP_MutableRawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawCalorimeterHit.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableRawCalorimeterHit {

  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitMutableCollectionIterator;
  friend class RawCalorimeterHit;

public:
  using object_type = RawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  MutableRawCalorimeterHit();
  MutableRawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  MutableRawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  MutableRawCalorimeterHit(const MutableRawCalorimeterHit& other);

  /// copy-assignment operator
  MutableRawCalorimeterHit& operator=(MutableRawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~MutableRawCalorimeterHit();

  /// conversion to const object
  operator RawCalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the amplitude of the hit in ADC counts.
  void setAmplitude(std::int32_t value);

  /// Set the time stamp for the hit.
  void setTimeStamp(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawCalorimeterHit& a, MutableRawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitOBJ_H
#define EDM4HEP_RawCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/RawCalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class RawCalorimeterHit;

class RawCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  RawCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawCalorimeterHitObj(const RawCalorimeterHitObj&);
  /// constructor from ObjectID and RawCalorimeterHitData
  /// does not initialize the internal relation containers
  RawCalorimeterHitObj(const podio::ObjectID id, RawCalorimeterHitData data);
  /// No assignment operator
  RawCalorimeterHitObj& operator=(const RawCalorimeterHitObj&) = delete;
  virtual ~RawCalorimeterHitObj() = default;

public:
  RawCalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_CollectionData_H
#define EDM4HEP_RawCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawCalorimeterHitObjPointerContainer = std::deque<RawCalorimeterHitObj*>;
using RawCalorimeterHitDataContainer = std::vector<RawCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawCalorimeterHitCollectionData(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData& operator=(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData(RawCalorimeterHitCollectionData&& other) = default;
  RawCalorimeterHitCollectionData& operator=(RawCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitDATA_H
#define EDM4HEP_CalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CalorimeterHitData
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  float energy{}; ///< energy of the hit in [GeV].
  float energyError{}; ///< error of the hit energy in [GeV].
  float time{}; ///< time of the hit in [ns].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].
  std::int32_t type{}; ///< type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_H
#define EDM4HEP_CalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCalorimeterHit;
class CalorimeterHitCollection;

/** @class CalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHit {

  friend class MutableCalorimeterHit;
  friend class CalorimeterHitCollection;
  friend class CalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableCalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  CalorimeterHit();
  CalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  CalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  CalorimeterHit(const CalorimeterHit& other);

  /// copy-assignment operator
  CalorimeterHit& operator=(CalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~CalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CalorimeterHit& a, CalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCalorimeterHit_H
#define EDM4HEP_MutableCalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CalorimeterHit.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableCalorimeterHit {

  friend class CalorimeterHitCollection;
  friend class CalorimeterHitMutableCollectionIterator;
  friend class CalorimeterHit;

public:
  using object_type = CalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  MutableCalorimeterHit();
  MutableCalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  MutableCalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  MutableCalorimeterHit(const MutableCalorimeterHit& other);

  /// copy-assignment operator
  MutableCalorimeterHit& operator=(MutableCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~MutableCalorimeterHit();

  /// conversion to const object
  operator CalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the error of the hit energy in [GeV].
  void setEnergyError(float value);

  /// Set the time of the hit in [ns].
  void setTime(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();

  /// Set the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  void setType(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const CalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCalorimeterHit& a, MutableCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitOBJ_H
#define EDM4HEP_CalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/CalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class CalorimeterHit;

class CalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  CalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  CalorimeterHitObj(const CalorimeterHitObj&);
  /// constructor from ObjectID and CalorimeterHitData
  /// does not initialize the internal relation containers
  CalorimeterHitObj(const podio::ObjectID id, CalorimeterHitData data);
  /// No assignment operator
  CalorimeterHitObj& operator=(const CalorimeterHitObj&) = delete;
  virtual ~CalorimeterHitObj() = default;

public:
  CalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_CollectionData_H
#define EDM4HEP_CalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CalorimeterHitObjPointerContainer = std::deque<CalorimeterHitObj*>;
using CalorimeterHitDataContainer = std::vector<CalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CalorimeterHitCollectionData(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData& operator=(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData(CalorimeterHitCollectionData&& other) = default;
  CalorimeterHitCollectionData& operator=(CalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDDATA_H
#define EDM4HEP_ParticleIDDATA_H

#include <cstdint>

namespace edm4hep {


/** @class ParticleIDData
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleIDData {
public:
  std::int32_t type{}; ///< userdefined type
  std::int32_t PDG{}; ///< PDG code of this id - ( 999999 ) if unknown.
  std::int32_t algorithmType{}; ///< type of the algorithm/module that created this hypothesis
  float likelihood{}; ///< likelihood of this hypothesis - in a user defined normalization.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_H
#define EDM4HEP_ParticleID_H

#include "edm4hep/ParticleIDObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableParticleID;
class ParticleIDCollection;

/** @class ParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleID {

  friend class MutableParticleID;
  friend class ParticleIDCollection;
  friend class ParticleIDCollectionIterator;

public:
  using mutable_type = MutableParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  ParticleID();
  ParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  ParticleID(ParticleIDObj* obj);

  /// copy constructor
  ParticleID(const ParticleID& other);

  /// copy-assignment operator
  ParticleID& operator=(ParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~ParticleID();


public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ParticleID& a, ParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ParticleID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableParticleID_H
#define EDM4HEP_MutableParticleID_H

#include "edm4hep/ParticleIDObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ParticleID.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class MutableParticleID {

  friend class ParticleIDCollection;
  friend class ParticleIDMutableCollectionIterator;
  friend class ParticleID;

public:
  using object_type = ParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  MutableParticleID();
  MutableParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  MutableParticleID(ParticleIDObj* obj);

  /// copy constructor
  MutableParticleID(const MutableParticleID& other);

  /// copy-assignment operator
  MutableParticleID& operator=(MutableParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~MutableParticleID();

  /// conversion to const object
  operator ParticleID() const;

public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  /// Set the userdefined type
  void setType(std::int32_t value);

  /// Set the PDG code of this id - ( 999999 ) if unknown.
  void setPDG(std::int32_t value);

  /// Set the type of the algorithm/module that created this hypothesis
  void setAlgorithmType(std::int32_t value);

  /// Set the likelihood of this hypothesis - in a user defined normalization.
  void setLikelihood(float value);



  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const ParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableParticleID& a, MutableParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDOBJ_H
#define EDM4HEP_ParticleIDOBJ_H

// data model specific includes
#include "edm4hep/ParticleIDData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class ParticleID;

class ParticleIDObj : public podio::ObjBase {
public:
  /// constructor
  ParticleIDObj();
  /// copy constructor (does a deep-copy of relation containers)
  ParticleIDObj(const ParticleIDObj&);
  /// constructor from ObjectID and ParticleIDData
  /// does not initialize the internal relation containers
  ParticleIDObj(const podio::ObjectID id, ParticleIDData data);
  /// No assignment operator
  ParticleIDObj& operator=(const ParticleIDObj&) = delete;
  virtual ~ParticleIDObj();

public:
  ParticleIDData data;
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_CollectionData_H
#define EDM4HEP_ParticleID_CollectionData_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleIDObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ParticleIDObjPointerContainer = std::deque<ParticleIDObj*>;
using ParticleIDDataContainer = std::vector<ParticleIDData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ParticleIDCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ParticleIDObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ParticleIDCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ParticleIDCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ParticleIDCollectionData(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData& operator=(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData(ParticleIDCollectionData&& other) = default;
  ParticleIDCollectionData& operator=(ParticleIDCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ParticleIDCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ParticleIDObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ParticleIDDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterDATA_H
#define EDM4HEP_ClusterDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ClusterData
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class ClusterData {
public:
  std::int32_t type{}; ///< flagword that defines the type of cluster. Bits 16-31 are used internally.
  float energy{}; ///< energy of the cluster [GeV]
  float energyError{}; ///< error on the energy
  ::edm4hep::Vector3f position{}; ///< position of the cluster [mm]
  std::array<float, 6> positionError{}; ///< covariance matrix of the position (6 Parameters)
  float iTheta{}; ///< intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  float phi{}; ///< intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  ::edm4hep::Vector3f directionError{}; ///< covariance matrix of the direction (3 Parameters) [mm^2]

  unsigned int shapeParameters_begin{};
  unsigned int shapeParameters_end{};
  unsigned int subdetectorEnergies_begin{};
  unsigned int subdetectorEnergies_end{};
  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int hits_begin{};
  unsigned int hits_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_H
#define EDM4HEP_Cluster_H

#include "edm4hep/ClusterObj.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCluster;
class ClusterCollection;

/** @class Cluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class Cluster {

  friend class MutableCluster;
  friend class ClusterCollection;
  friend class ClusterCollectionIterator;

public:
  using mutable_type = MutableCluster;
  using collection_type = ClusterCollection;

  /// default constructor
  Cluster();
  Cluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  Cluster(ClusterObj* obj);

  /// copy constructor
  Cluster(const Cluster& other);

  /// copy-assignment operator
  Cluster& operator=(Cluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~Cluster();


public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Cluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Cluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Cluster& a, Cluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Cluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Cluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCluster_H
#define EDM4HEP_MutableCluster_H

#include "edm4hep/ClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Cluster.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class MutableCluster {

  friend class ClusterCollection;
  friend class ClusterMutableCollectionIterator;
  friend class Cluster;

public:
  using object_type = Cluster;
  using collection_type = ClusterCollection;

  /// default constructor
  MutableCluster();
  MutableCluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  MutableCluster(ClusterObj* obj);

  /// copy constructor
  MutableCluster(const MutableCluster& other);

  /// copy-assignment operator
  MutableCluster& operator=(MutableCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~MutableCluster();

  /// conversion to const object
  operator Cluster() const;

public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  /// Set the flagword that defines the type of cluster. Bits 16-31 are used internally.
  void setType(std::int32_t value);

  /// Set the energy of the cluster [GeV]
  void setEnergy(float value);

  /// Set the error on the energy
  void setEnergyError(float value);

  /// Set the position of the cluster [mm]
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the cluster [mm]
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (6 Parameters)
  void setPositionError(std::array<float, 6> value);
  void setPositionError(size_t i, float value);
  /// Get reference to covariance matrix of the position (6 Parameters)
  std::array<float, 6>& positionError();

  /// Set the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  void setITheta(float value);

  /// Set the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  void setPhi(float value);

  /// Set the covariance matrix of the direction (3 Parameters) [mm^2]
  void setDirectionError(edm4hep::Vector3f value);
  /// Get reference to covariance matrix of the direction (3 Parameters) [mm^2]
  edm4hep::Vector3f& directionError();



  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToHits(edm4hep::CalorimeterHit);
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  void addToShapeParameters(float);
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  void addToSubdetectorEnergies(float);
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const Cluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCluster& a, MutableCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterOBJ_H
#define EDM4HEP_ClusterOBJ_H

// data model specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Cluster;

class ClusterObj : public podio::ObjBase {
public:
  /// constructor
  ClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  ClusterObj(const ClusterObj&);
  /// constructor from ObjectID and ClusterData
  /// does not initialize the internal relation containers
  ClusterObj(const podio::ObjectID id, ClusterData data);
  /// No assignment operator
  ClusterObj& operator=(const ClusterObj&) = delete;
  virtual ~ClusterObj();

public:
  ClusterData data;
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::CalorimeterHit>* m_hits{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
  std::vector<float>* m_shapeParameters{nullptr};
  std::vector<float>* m_subdetectorEnergies{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_CollectionData_H
#define EDM4HEP_Cluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ClusterObjPointerContainer = std::deque<ClusterObj*>;
using ClusterDataContainer = std::vector<ClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ClusterCollectionData(const ClusterCollectionData&) = delete;
  ClusterCollectionData& operator=(const ClusterCollectionData&) = delete;
  ClusterCollectionData(ClusterCollectionData&& other) = default;
  ClusterCollectionData& operator=(ClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_hits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CalorimeterHit>> m_rel_hits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<float> m_vec_shapeParameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_shapeParameters{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_subdetectorEnergies{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_subdetectorEnergies{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitDATA_H
#define EDM4HEP_TrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitData
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_H
#define EDM4HEP_TrackerHit_H

#include "edm4hep/TrackerHitObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHit;
class TrackerHitCollection;

/** @class TrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHit {

  friend class MutableTrackerHit;
  friend class TrackerHitCollection;
  friend class TrackerHitCollectionIterator;

public:
  using mutable_type = MutableTrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  TrackerHit();
  TrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  TrackerHit(TrackerHitObj* obj);

  /// copy constructor
  TrackerHit(const TrackerHit& other);

  /// copy-assignment operator
  TrackerHit& operator=(TrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~TrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHit& a, TrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHit_H
#define EDM4HEP_MutableTrackerHit_H

#include "edm4hep/TrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHit.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableTrackerHit {

  friend class TrackerHitCollection;
  friend class TrackerHitMutableCollectionIterator;
  friend class TrackerHit;

public:
  using object_type = TrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  MutableTrackerHit();
  MutableTrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  MutableTrackerHit(TrackerHitObj* obj);

  /// copy constructor
  MutableTrackerHit(const MutableTrackerHit& other);

  /// copy-assignment operator
  MutableTrackerHit& operator=(MutableTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~MutableTrackerHit();

  /// conversion to const object
  operator TrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHit& a, MutableTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitOBJ_H
#define EDM4HEP_TrackerHitOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHit;

class TrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitObj(const TrackerHitObj&);
  /// constructor from ObjectID and TrackerHitData
  /// does not initialize the internal relation containers
  TrackerHitObj(const podio::ObjectID id, TrackerHitData data);
  /// No assignment operator
  TrackerHitObj& operator=(const TrackerHitObj&) = delete;
  virtual ~TrackerHitObj();

public:
  TrackerHitData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_CollectionData_H
#define EDM4HEP_TrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitObjPointerContainer = std::deque<TrackerHitObj*>;
using TrackerHitDataContainer = std::vector<TrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitCollectionData(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData& operator=(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData(TrackerHitCollectionData&& other) = default;
  TrackerHitCollectionData& operator=(TrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneDATA_H
#define EDM4HEP_TrackerHitPlaneDATA_H

#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitPlaneData
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlaneData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector2f u{}; ///< measurement direction vector, u lies in the x-y plane
  ::edm4hep::Vector2f v{}; ///< measurement direction vector, v is along z
  float du{}; ///< measurement error along the direction
  float dv{}; ///< measurement error along the direction
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_H
#define EDM4HEP_TrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHitPlane;
class TrackerHitPlaneCollection;

/** @class TrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlane {

  friend class MutableTrackerHitPlane;
  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneCollectionIterator;

public:
  using mutable_type = MutableTrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  TrackerHitPlane();
  TrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  TrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  TrackerHitPlane(const TrackerHitPlane& other);

  /// copy-assignment operator
  TrackerHitPlane& operator=(TrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~TrackerHitPlane();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHitPlane& a, TrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlane& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHitPlane_H
#define EDM4HEP_MutableTrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHitPlane.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class MutableTrackerHitPlane {

  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneMutableCollectionIterator;
  friend class TrackerHitPlane;

public:
  using object_type = TrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  MutableTrackerHitPlane();
  MutableTrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  MutableTrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  MutableTrackerHitPlane(const MutableTrackerHitPlane& other);

  /// copy-assignment operator
  MutableTrackerHitPlane& operator=(MutableTrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~MutableTrackerHitPlane();

  /// conversion to const object
  operator TrackerHitPlane() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the measurement direction vector, u lies in the x-y plane
  void setU(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, u lies in the x-y plane
  edm4hep::Vector2f& u();

  /// Set the measurement direction vector, v is along z
  void setV(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, v is along z
  edm4hep::Vector2f& v();

  /// Set the measurement error along the direction
  void setDu(float value);

  /// Set the measurement error along the direction
  void setDv(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHitPlane& a, MutableTrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneOBJ_H
#define EDM4HEP_TrackerHitPlaneOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHitPlane;

class TrackerHitPlaneObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitPlaneObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitPlaneObj(const TrackerHitPlaneObj&);
  /// constructor from ObjectID and TrackerHitPlaneData
  /// does not initialize the internal relation containers
  TrackerHitPlaneObj(const podio::ObjectID id, TrackerHitPlaneData data);
  /// No assignment operator
  TrackerHitPlaneObj& operator=(const TrackerHitPlaneObj&) = delete;
  virtual ~TrackerHitPlaneObj();

public:
  TrackerHitPlaneData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_CollectionData_H
#define EDM4HEP_TrackerHitPlane_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlaneObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitPlaneObjPointerContainer = std::deque<TrackerHitPlaneObj*>;
using TrackerHitPlaneDataContainer = std::vector<TrackerHitPlaneData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitPlaneCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitPlaneObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitPlaneCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitPlaneCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitPlaneCollectionData(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData& operator=(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData(TrackerHitPlaneCollectionData&& other) = default;
  TrackerHitPlaneCollectionData& operator=(TrackerHitPlaneCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitPlaneCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitPlaneObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitPlaneDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesDATA_H
#define EDM4HEP_RawTimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawTimeSeriesData
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeriesData {
public:
  std::uint64_t cellID{}; ///< detector specific cell id.
  std::int32_t quality{}; ///< quality flag for the hit.
  float time{}; ///< time of the hit [ns].
  float charge{}; ///< integrated charge of the hit [fC].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int adcCounts_begin{};
  unsigned int adcCounts_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_H
#define EDM4HEP_RawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawTimeSeries;
class RawTimeSeriesCollection;

/** @class RawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeries {

  friend class MutableRawTimeSeries;
  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesCollectionIterator;

public:
  using mutable_type = MutableRawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  RawTimeSeries();
  RawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  RawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  RawTimeSeries(const RawTimeSeries& other);

  /// copy-assignment operator
  RawTimeSeries& operator=(RawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~RawTimeSeries();


public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawTimeSeries& a, RawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawTimeSeries_H
#define EDM4HEP_MutableRawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawTimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class MutableRawTimeSeries {

  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesMutableCollectionIterator;
  friend class RawTimeSeries;

public:
  using object_type = RawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  MutableRawTimeSeries();
  MutableRawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  MutableRawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  MutableRawTimeSeries(const MutableRawTimeSeries& other);

  /// copy-assignment operator
  MutableRawTimeSeries& operator=(MutableRawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~MutableRawTimeSeries();

  /// conversion to const object
  operator RawTimeSeries() const;

public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the detector specific cell id.
  void setCellID(std::uint64_t value);

  /// Set the quality flag for the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the integrated charge of the hit [fC].
  void setCharge(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAdcCounts(std::int32_t);
  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawTimeSeries& a, MutableRawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesOBJ_H
#define EDM4HEP_RawTimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RawTimeSeries;

class RawTimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  RawTimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawTimeSeriesObj(const RawTimeSeriesObj&);
  /// constructor from ObjectID and RawTimeSeriesData
  /// does not initialize the internal relation containers
  RawTimeSeriesObj(const podio::ObjectID id, RawTimeSeriesData data);
  /// No assignment operator
  RawTimeSeriesObj& operator=(const RawTimeSeriesObj&) = delete;
  virtual ~RawTimeSeriesObj();

public:
  RawTimeSeriesData data;
  std::vector<std::int32_t>* m_adcCounts{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_CollectionData_H
#define EDM4HEP_RawTimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawTimeSeriesObjPointerContainer = std::deque<RawTimeSeriesObj*>;
using RawTimeSeriesDataContainer = std::vector<RawTimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawTimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawTimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawTimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawTimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawTimeSeriesCollectionData(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData& operator=(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData(RawTimeSeriesCollectionData&& other) = default;
  RawTimeSeriesCollectionData& operator=(RawTimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawTimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RawTimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_adcCounts{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_adcCounts{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawTimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackDATA_H
#define EDM4HEP_TrackDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TrackData
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class TrackData {
public:
  std::int32_t type{}; ///< flagword that defines the type of track.Bits 16-31 are used internally
  float chi2{}; ///< Chi^2 of the track fit
  std::int32_t ndf{}; ///< number of degrees of freedom of the track fit
  float dEdx{}; ///< dEdx of the track.
  float dEdxError{}; ///< error of dEdx.
  float radiusOfInnermostHit{}; ///< radius of the innermost hit that has been used in the track fit

  unsigned int subdetectorHitNumbers_begin{};
  unsigned int subdetectorHitNumbers_end{};
  unsigned int trackStates_begin{};
  unsigned int trackStates_end{};
  unsigned int dxQuantities_begin{};
  unsigned int dxQuantities_end{};
  unsigned int trackerHits_begin{};
  unsigned int trackerHits_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_H
#define EDM4HEP_Track_H

#include "edm4hep/TrackObj.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrack;
class TrackCollection;

/** @class Track
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class Track {

  friend class MutableTrack;
  friend class TrackCollection;
  friend class TrackCollectionIterator;

public:
  using mutable_type = MutableTrack;
  using collection_type = TrackCollection;

  /// default constructor
  Track();
  Track(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  Track(TrackObj* obj);

  /// copy constructor
  Track(const Track& other);

  /// copy-assignment operator
  Track& operator=(Track other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~Track();


public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Track& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrack& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Track& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Track& a, Track& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Track& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Track& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrack_H
#define EDM4HEP_MutableTrack_H

#include "edm4hep/TrackObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Track.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrack
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class MutableTrack {

  friend class TrackCollection;
  friend class TrackMutableCollectionIterator;
  friend class Track;

public:
  using object_type = Track;
  using collection_type = TrackCollection;

  /// default constructor
  MutableTrack();
  MutableTrack(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  MutableTrack(TrackObj* obj);

  /// copy constructor
  MutableTrack(const MutableTrack& other);

  /// copy-assignment operator
  MutableTrack& operator=(MutableTrack other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~MutableTrack();

  /// conversion to const object
  operator Track() const;

public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  /// Set the flagword that defines the type of track.Bits 16-31 are used internally
  void setType(std::int32_t value);

  /// Set the Chi^2 of the track fit
  void setChi2(float value);

  /// Set the number of degrees of freedom of the track fit
  void setNdf(std::int32_t value);

  /// Set the dEdx of the track.
  void setDEdx(float value);

  /// Set the error of dEdx.
  void setDEdxError(float value);

  /// Set the radius of the innermost hit that has been used in the track fit
  void setRadiusOfInnermostHit(float value);



  void addToTrackerHits(edm4hep::TrackerHit);
  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToSubdetectorHitNumbers(std::int32_t);
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  void addToTrackStates(edm4hep::TrackState);
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  void addToDxQuantities(edm4hep::Quantity);
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrack& other) const { return m_obj == other.m_obj; }
  bool operator==(const Track& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrack& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrack& a, MutableTrack& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrack& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackOBJ_H
#define EDM4HEP_TrackOBJ_H

// data model specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Track;

class TrackObj : public podio::ObjBase {
public:
  /// constructor
  TrackObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackObj(const TrackObj&);
  /// constructor from ObjectID and TrackData
  /// does not initialize the internal relation containers
  TrackObj(const podio::ObjectID id, TrackData data);
  /// No assignment operator
  TrackObj& operator=(const TrackObj&) = delete;
  virtual ~TrackObj();

public:
  TrackData data;
  std::vector<edm4hep::TrackerHit>* m_trackerHits{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<std::int32_t>* m_subdetectorHitNumbers{nullptr};
  std::vector<edm4hep::TrackState>* m_trackStates{nullptr};
  std::vector<edm4hep::Quantity>* m_dxQuantities{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_CollectionData_H
#define EDM4HEP_Track_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackObjPointerContainer = std::deque<TrackObj*>;
using TrackDataContainer = std::vector<TrackData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackCollectionData(const TrackCollectionData&) = delete;
  TrackCollectionData& operator=(const TrackCollectionData&) = delete;
  TrackCollectionData(TrackCollectionData&& other) = default;
  TrackCollectionData& operator=(TrackCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_trackerHits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerHit>> m_rel_trackerHits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_subdetectorHitNumbers{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_subdetectorHitNumbers{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::TrackState> m_vec_trackStates{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::TrackState>> m_vecs_trackStates{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Quantity> m_vec_dxQuantities{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Quantity>> m_vecs_dxQuantities{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexDATA_H
#define EDM4HEP_VertexDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class VertexData
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class VertexData {
public:
  std::int32_t primary{}; ///< boolean flag, if vertex is the primary vertex of the event
  float chi2{}; ///< chi-squared of the vertex fit
  float probability{}; ///< probability of the vertex fit
  ::edm4hep::Vector3f position{}; ///< [mm] position of the vertex.
  std::array<float, 6> covMatrix{}; ///< covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::int32_t algorithmType{}; ///< type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_H
#define EDM4HEP_Vertex_H

#include "edm4hep/VertexObj.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {

class MutableVertex;
class VertexCollection;

/** @class Vertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class Vertex {

  friend class MutableVertex;
  friend class VertexCollection;
  friend class VertexCollectionIterator;

public:
  using mutable_type = MutableVertex;
  using collection_type = VertexCollection;

  /// default constructor
  Vertex();
  Vertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  Vertex(VertexObj* obj);

  /// copy constructor
  Vertex(const Vertex& other);

  /// copy-assignment operator
  Vertex& operator=(Vertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~Vertex();


public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Vertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableVertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Vertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Vertex& a, Vertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Vertex& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableVertex_H
#define EDM4HEP_MutableVertex_H

#include "edm4hep/VertexObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Vertex.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {


/** @class MutableVertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class MutableVertex {

  friend class VertexCollection;
  friend class VertexMutableCollectionIterator;
  friend class Vertex;

public:
  using object_type = Vertex;
  using collection_type = VertexCollection;

  /// default constructor
  MutableVertex();
  MutableVertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  MutableVertex(VertexObj* obj);

  /// copy constructor
  MutableVertex(const MutableVertex& other);

  /// copy-assignment operator
  MutableVertex& operator=(MutableVertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~MutableVertex();

  /// conversion to const object
  operator Vertex() const;

public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  /// Set the boolean flag, if vertex is the primary vertex of the event
  void setPrimary(std::int32_t value);

  /// Set the chi-squared of the vertex fit
  void setChi2(float value);

  /// Set the probability of the vertex fit
  void setProbability(float value);

  /// Set the [mm] position of the vertex.
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to [mm] position of the vertex.
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::array<float, 6>& covMatrix();

  /// Set the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  void setAlgorithmType(std::int32_t value);


  /// Set the reconstructed particle associated to this vertex.
  void setAssociatedParticle(edm4hep::ReconstructedParticle value);

  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableVertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const Vertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableVertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableVertex& a, MutableVertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableVertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexOBJ_H
#define EDM4HEP_VertexOBJ_H

// data model specific includes
#include "edm4hep/VertexData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class ReconstructedParticle;
}


namespace edm4hep {

class Vertex;

class VertexObj : public podio::ObjBase {
public:
  /// constructor
  VertexObj();
  /// copy constructor (does a deep-copy of relation containers)
  VertexObj(const VertexObj&);
  /// constructor from ObjectID and VertexData
  /// does not initialize the internal relation containers
  VertexObj(const podio::ObjectID id, VertexData data);
  /// No assignment operator
  VertexObj& operator=(const VertexObj&) = delete;
  virtual ~VertexObj();

public:
  VertexData data;
  edm4hep::ReconstructedParticle* m_associatedParticle{nullptr};
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_CollectionData_H
#define EDM4HEP_Vertex_CollectionData_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using VertexObjPointerContainer = std::deque<VertexObj*>;
using VertexDataContainer = std::vector<VertexData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class VertexCollectionData {
public:
  /**
   * The Objs of this collection
   */
  VertexObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  VertexCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  VertexCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  VertexCollectionData(const VertexCollectionData&) = delete;
  VertexCollectionData& operator=(const VertexCollectionData&) = delete;
  VertexCollectionData(VertexCollectionData&& other) = default;
  VertexCollectionData& operator=(VertexCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~VertexCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(VertexObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_associatedParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<VertexDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleDATA_H
#define EDM4HEP_ReconstructedParticleDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ReconstructedParticleData
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticleData {
public:
  std::int32_t type{}; ///< type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  float energy{}; ///< [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f momentum{}; ///< [GeV] particle momentum. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f referencePoint{}; ///< [mm] reference, i.e. where the particle has been measured
  float charge{}; ///< charge of the reconstructed particle.
  float mass{}; ///< [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  float goodnessOfPID{}; ///< overall goodness of the PID on a scale of [0;1]
  std::array<float, 10> covMatrix{}; ///< cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##

  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
  unsigned int particles_begin{};
  unsigned int particles_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_H
#define EDM4HEP_ReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {

class MutableReconstructedParticle;
class ReconstructedParticleCollection;

/** @class ReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticle {

  friend class MutableReconstructedParticle;
  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleCollectionIterator;

public:
  using mutable_type = MutableReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  ReconstructedParticle();
  ReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  ReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  ReconstructedParticle(const ReconstructedParticle& other);

  /// copy-assignment operator
  ReconstructedParticle& operator=(ReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~ReconstructedParticle();


public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ReconstructedParticle& a, ReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableReconstructedParticle_H
#define EDM4HEP_MutableReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ReconstructedParticle.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {


/** @class MutableReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class MutableReconstructedParticle {

  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleMutableCollectionIterator;
  friend class ReconstructedParticle;

public:
  using object_type = ReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  MutableReconstructedParticle();
  MutableReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  MutableReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  MutableReconstructedParticle(const MutableReconstructedParticle& other);

  /// copy-assignment operator
  MutableReconstructedParticle& operator=(MutableReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~MutableReconstructedParticle();

  /// conversion to const object
  operator ReconstructedParticle() const;

public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  /// Set the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  void setType(std::int32_t value);

  /// Set the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  void setEnergy(float value);

  /// Set the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to [GeV] particle momentum. Four momentum state is not kept consistent internally.
  edm4hep::Vector3f& momentum();

  /// Set the [mm] reference, i.e. where the particle has been measured
  void setReferencePoint(edm4hep::Vector3f value);
  /// Get reference to [mm] reference, i.e. where the particle has been measured
  edm4hep::Vector3f& referencePoint();

  /// Set the charge of the reconstructed particle.
  void setCharge(float value);

  /// Set the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  void setMass(float value);

  /// Set the overall goodness of the PID on a scale of [0;1]
  void setGoodnessOfPID(float value);

  /// Set the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  void setCovMatrix(std::array<float, 10> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  std::array<float, 10>& covMatrix();


  /// Set the start vertex associated to this particle
  void setStartVertex(edm4hep::Vertex value);
  /// Set the particle Id used for the kinematics of this particle
  void setParticleIDUsed(edm4hep::ParticleID value);

  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToParticles(edm4hep::ReconstructedParticle);
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

 //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.
 //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const ReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableReconstructedParticle& a, MutableReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleOBJ_H
#define EDM4HEP_ReconstructedParticleOBJ_H

// data model specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Vertex;
class ParticleID;
}


namespace edm4hep {

class ReconstructedParticle;

class ReconstructedParticleObj : public podio::ObjBase {
public:
  /// constructor
  ReconstructedParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  ReconstructedParticleObj(const ReconstructedParticleObj&);
  /// constructor from ObjectID and ReconstructedParticleData
  /// does not initialize the internal relation containers
  ReconstructedParticleObj(const podio::ObjectID id, ReconstructedParticleData data);
  /// No assignment operator
  ReconstructedParticleObj& operator=(const ReconstructedParticleObj&) = delete;
  virtual ~ReconstructedParticleObj();

public:
  ReconstructedParticleData data;
  edm4hep::Vertex* m_startVertex{nullptr};
  edm4hep::ParticleID* m_particleIDUsed{nullptr};
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<edm4hep::ReconstructedParticle>* m_particles{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_CollectionData_H
#define EDM4HEP_ReconstructedParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ReconstructedParticleObjPointerContainer = std::deque<ReconstructedParticleObj*>;
using ReconstructedParticleDataContainer = std::vector<ReconstructedParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ReconstructedParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ReconstructedParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ReconstructedParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ReconstructedParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ReconstructedParticleCollectionData(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData& operator=(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData(ReconstructedParticleCollectionData&& other) = default;
  ReconstructedParticleCollectionData& operator=(ReconstructedParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ReconstructedParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ReconstructedParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_particles;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ReconstructedParticle>> m_rel_particles_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Vertex> m_rel_startVertex{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDUsed{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ReconstructedParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationDATA_H
#define EDM4HEP_MCRecoParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoParticleAssociationData
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_H
#define EDM4HEP_MCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoParticleAssociation;
class MCRecoParticleAssociationCollection;

/** @class MCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociation {

  friend class MutableMCRecoParticleAssociation;
  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MCRecoParticleAssociation();
  MCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MCRecoParticleAssociation(const MCRecoParticleAssociation& other);

  /// copy-assignment operator
  MCRecoParticleAssociation& operator=(MCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MCRecoParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoParticleAssociation& a, MCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoParticleAssociation_H
#define EDM4HEP_MutableMCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoParticleAssociation {

  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationMutableCollectionIterator;
  friend class MCRecoParticleAssociation;

public:
  using object_type = MCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MutableMCRecoParticleAssociation();
  MutableMCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MutableMCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoParticleAssociation(const MutableMCRecoParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoParticleAssociation& operator=(MutableMCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoParticleAssociation();

  /// conversion to const object
  operator MCRecoParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoParticleAssociation& a, MutableMCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationOBJ_H
#define EDM4HEP_MCRecoParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MCParticle;
}


namespace edm4hep {

class MCRecoParticleAssociation;

class MCRecoParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoParticleAssociationObj(const MCRecoParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoParticleAssociationObj(const podio::ObjectID id, MCRecoParticleAssociationData data);
  /// No assignment operator
  MCRecoParticleAssociationObj& operator=(const MCRecoParticleAssociationObj&) = delete;
  virtual ~MCRecoParticleAssociationObj();

public:
  MCRecoParticleAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoParticleAssociationObjPointerContainer = std::deque<MCRecoParticleAssociationObj*>;
using MCRecoParticleAssociationDataContainer = std::vector<MCRecoParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoParticleAssociationCollectionData(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData& operator=(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData(MCRecoParticleAssociationCollectionData&& other) = default;
  MCRecoParticleAssociationCollectionData& operator=(MCRecoParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationDATA_H
#define EDM4HEP_MCRecoCaloAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloAssociationData
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_H
#define EDM4HEP_MCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {

class MutableMCRecoCaloAssociation;
class MCRecoCaloAssociationCollection;

/** @class MCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociation {

  friend class MutableMCRecoCaloAssociation;
  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MCRecoCaloAssociation();
  MCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MCRecoCaloAssociation(const MCRecoCaloAssociation& other);

  /// copy-assignment operator
  MCRecoCaloAssociation& operator=(MCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MCRecoCaloAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloAssociation& a, MCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloAssociation_H
#define EDM4HEP_MutableMCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {


/** @class MutableMCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoCaloAssociation {

  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationMutableCollectionIterator;
  friend class MCRecoCaloAssociation;

public:
  using object_type = MCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MutableMCRecoCaloAssociation();
  MutableMCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MutableMCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloAssociation(const MutableMCRecoCaloAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloAssociation& operator=(MutableMCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloAssociation();

  /// conversion to const object
  operator MCRecoCaloAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimCalorimeterHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloAssociation& a, MutableMCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationOBJ_H
#define EDM4HEP_MCRecoCaloAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class SimCalorimeterHit;
}


namespace edm4hep {

class MCRecoCaloAssociation;

class MCRecoCaloAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloAssociationObj(const MCRecoCaloAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloAssociationObj(const podio::ObjectID id, MCRecoCaloAssociationData data);
  /// No assignment operator
  MCRecoCaloAssociationObj& operator=(const MCRecoCaloAssociationObj&) = delete;
  virtual ~MCRecoCaloAssociationObj();

public:
  MCRecoCaloAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::SimCalorimeterHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/SimCalorimeterHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloAssociationObjPointerContainer = std::deque<MCRecoCaloAssociationObj*>;
using MCRecoCaloAssociationDataContainer = std::vector<MCRecoCaloAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloAssociationCollectionData(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData& operator=(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData(MCRecoCaloAssociationCollectionData&& other) = default;
  MCRecoCaloAssociationCollectionData& operator=(MCRecoCaloAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimCalorimeterHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationDATA_H
#define EDM4HEP_MCRecoTrackerAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerAssociationData
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_H
#define EDM4HEP_MCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerAssociation;
class MCRecoTrackerAssociationCollection;

/** @class MCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociation {

  friend class MutableMCRecoTrackerAssociation;
  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MCRecoTrackerAssociation();
  MCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerAssociation(const MCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerAssociation& operator=(MCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MCRecoTrackerAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerAssociation& a, MCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerAssociation_H
#define EDM4HEP_MutableMCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoTrackerAssociation {

  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationMutableCollectionIterator;
  friend class MCRecoTrackerAssociation;

public:
  using object_type = MCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerAssociation();
  MutableMCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MutableMCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerAssociation(const MutableMCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerAssociation& operator=(MutableMCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerAssociation();

  /// conversion to const object
  operator MCRecoTrackerAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerAssociation& a, MutableMCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHit;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerAssociation;

class MCRecoTrackerAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerAssociationObj(const MCRecoTrackerAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerAssociationObj(const podio::ObjectID id, MCRecoTrackerAssociationData data);
  /// No assignment operator
  MCRecoTrackerAssociationObj& operator=(const MCRecoTrackerAssociationObj&) = delete;
  virtual ~MCRecoTrackerAssociationObj();

public:
  MCRecoTrackerAssociationData data;
  edm4hep::TrackerHit* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerAssociationObjPointerContainer = std::deque<MCRecoTrackerAssociationObj*>;
using MCRecoTrackerAssociationDataContainer = std::vector<MCRecoTrackerAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerAssociationCollectionData(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData& operator=(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData(MCRecoTrackerAssociationCollectionData&& other) = default;
  MCRecoTrackerAssociationCollectionData& operator=(MCRecoTrackerAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerHitPlaneAssociationData
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerHitPlaneAssociation;
class MCRecoTrackerHitPlaneAssociationCollection;

/** @class MCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociation {

  friend class MutableMCRecoTrackerHitPlaneAssociation;
  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MCRecoTrackerHitPlaneAssociation();
  MCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerHitPlaneAssociation(const MCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerHitPlaneAssociation& operator=(MCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MCRecoTrackerHitPlaneAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerHitPlaneAssociation& a, MCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackerHitPlaneAssociation {

  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;
  friend class MCRecoTrackerHitPlaneAssociation;

public:
  using object_type = MCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerHitPlaneAssociation();
  MutableMCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MutableMCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerHitPlaneAssociation(const MutableMCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerHitPlaneAssociation& operator=(MutableMCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerHitPlaneAssociation();

  /// conversion to const object
  operator MCRecoTrackerHitPlaneAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHitPlane value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerHitPlaneAssociation& a, MutableMCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerHitPlaneAssociation;

class MCRecoTrackerHitPlaneAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerHitPlaneAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerHitPlaneAssociationObj(const MCRecoTrackerHitPlaneAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerHitPlaneAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerHitPlaneAssociationObj(const podio::ObjectID id, MCRecoTrackerHitPlaneAssociationData data);
  /// No assignment operator
  MCRecoTrackerHitPlaneAssociationObj& operator=(const MCRecoTrackerHitPlaneAssociationObj&) = delete;
  virtual ~MCRecoTrackerHitPlaneAssociationObj();

public:
  MCRecoTrackerHitPlaneAssociationData data;
  edm4hep::TrackerHitPlane* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHitPlane.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerHitPlaneAssociationObjPointerContainer = std::deque<MCRecoTrackerHitPlaneAssociationObj*>;
using MCRecoTrackerHitPlaneAssociationDataContainer = std::vector<MCRecoTrackerHitPlaneAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerHitPlaneAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerHitPlaneAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerHitPlaneAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHitPlane> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerHitPlaneAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationDATA_H
#define EDM4HEP_MCRecoCaloParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloParticleAssociationData
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_H
#define EDM4HEP_MCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoCaloParticleAssociation;
class MCRecoCaloParticleAssociationCollection;

/** @class MCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociation {

  friend class MutableMCRecoCaloParticleAssociation;
  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MCRecoCaloParticleAssociation();
  MCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MCRecoCaloParticleAssociation(const MCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MCRecoCaloParticleAssociation& operator=(MCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MCRecoCaloParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloParticleAssociation& a, MCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloParticleAssociation_H
#define EDM4HEP_MutableMCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoCaloParticleAssociation {

  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationMutableCollectionIterator;
  friend class MCRecoCaloParticleAssociation;

public:
  using object_type = MCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MutableMCRecoCaloParticleAssociation();
  MutableMCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MutableMCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloParticleAssociation(const MutableMCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloParticleAssociation& operator=(MutableMCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloParticleAssociation();

  /// conversion to const object
  operator MCRecoCaloParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloParticleAssociation& a, MutableMCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationOBJ_H
#define EDM4HEP_MCRecoCaloParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MCParticle;
}


namespace edm4hep {

class MCRecoCaloParticleAssociation;

class MCRecoCaloParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloParticleAssociationObj(const MCRecoCaloParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloParticleAssociationObj(const podio::ObjectID id, MCRecoCaloParticleAssociationData data);
  /// No assignment operator
  MCRecoCaloParticleAssociationObj& operator=(const MCRecoCaloParticleAssociationObj&) = delete;
  virtual ~MCRecoCaloParticleAssociationObj();

public:
  MCRecoCaloParticleAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloParticleAssociationObjPointerContainer = std::deque<MCRecoCaloParticleAssociationObj*>;
using MCRecoCaloParticleAssociationDataContainer = std::vector<MCRecoCaloParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloParticleAssociationCollectionData(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData& operator=(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData(MCRecoCaloParticleAssociationCollectionData&& other) = default;
  MCRecoCaloParticleAssociationCollectionData& operator=(MCRecoCaloParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationDATA_H
#define EDM4HEP_MCRecoClusterParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoClusterParticleAssociationData
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_H
#define EDM4HEP_MCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoClusterParticleAssociation;
class MCRecoClusterParticleAssociationCollection;

/** @class MCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociation {

  friend class MutableMCRecoClusterParticleAssociation;
  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MCRecoClusterParticleAssociation();
  MCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MCRecoClusterParticleAssociation(const MCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MCRecoClusterParticleAssociation& operator=(MCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MCRecoClusterParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoClusterParticleAssociation& a, MCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoClusterParticleAssociation_H
#define EDM4HEP_MutableMCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoClusterParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoClusterParticleAssociation {

  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationMutableCollectionIterator;
  friend class MCRecoClusterParticleAssociation;

public:
  using object_type = MCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MutableMCRecoClusterParticleAssociation();
  MutableMCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MutableMCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoClusterParticleAssociation(const MutableMCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoClusterParticleAssociation& operator=(MutableMCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoClusterParticleAssociation();

  /// conversion to const object
  operator MCRecoClusterParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the cluster
  void setRec(edm4hep::Cluster value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoClusterParticleAssociation& a, MutableMCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationOBJ_H
#define EDM4HEP_MCRecoClusterParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Cluster;
class MCParticle;
}


namespace edm4hep {

class MCRecoClusterParticleAssociation;

class MCRecoClusterParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoClusterParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoClusterParticleAssociationObj(const MCRecoClusterParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoClusterParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoClusterParticleAssociationObj(const podio::ObjectID id, MCRecoClusterParticleAssociationData data);
  /// No assignment operator
  MCRecoClusterParticleAssociationObj& operator=(const MCRecoClusterParticleAssociationObj&) = delete;
  virtual ~MCRecoClusterParticleAssociationObj();

public:
  MCRecoClusterParticleAssociationData data;
  edm4hep::Cluster* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoClusterParticleAssociationObjPointerContainer = std::deque<MCRecoClusterParticleAssociationObj*>;
using MCRecoClusterParticleAssociationDataContainer = std::vector<MCRecoClusterParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoClusterParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoClusterParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoClusterParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoClusterParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoClusterParticleAssociationCollectionData(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData& operator=(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData(MCRecoClusterParticleAssociationCollectionData&& other) = default;
  MCRecoClusterParticleAssociationCollectionData& operator=(MCRecoClusterParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoClusterParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoClusterParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationDATA_H
#define EDM4HEP_MCRecoTrackParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackParticleAssociationData
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_H
#define EDM4HEP_MCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoTrackParticleAssociation;
class MCRecoTrackParticleAssociationCollection;

/** @class MCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociation {

  friend class MutableMCRecoTrackParticleAssociation;
  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MCRecoTrackParticleAssociation();
  MCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MCRecoTrackParticleAssociation(const MCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MCRecoTrackParticleAssociation& operator=(MCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MCRecoTrackParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackParticleAssociation& a, MCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackParticleAssociation_H
#define EDM4HEP_MutableMCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackParticleAssociation {

  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationMutableCollectionIterator;
  friend class MCRecoTrackParticleAssociation;

public:
  using object_type = MCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MutableMCRecoTrackParticleAssociation();
  MutableMCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MutableMCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackParticleAssociation(const MutableMCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackParticleAssociation& operator=(MutableMCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackParticleAssociation();

  /// conversion to const object
  operator MCRecoTrackParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the track
  void setRec(edm4hep::Track value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackParticleAssociation& a, MutableMCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationOBJ_H
#define EDM4HEP_MCRecoTrackParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Track;
class MCParticle;
}


namespace edm4hep {

class MCRecoTrackParticleAssociation;

class MCRecoTrackParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackParticleAssociationObj(const MCRecoTrackParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackParticleAssociationObj(const podio::ObjectID id, MCRecoTrackParticleAssociationData data);
  /// No assignment operator
  MCRecoTrackParticleAssociationObj& operator=(const MCRecoTrackParticleAssociationObj&) = delete;
  virtual ~MCRecoTrackParticleAssociationObj();

public:
  MCRecoTrackParticleAssociationData data;
  edm4hep::Track* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackParticleAssociationObjPointerContainer = std::deque<MCRecoTrackParticleAssociationObj*>;
using MCRecoTrackParticleAssociationDataContainer = std::vector<MCRecoTrackParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackParticleAssociationCollectionData(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData& operator=(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData(MCRecoTrackParticleAssociationCollectionData&& other) = default;
  MCRecoTrackParticleAssociationCollectionData& operator=(MCRecoTrackParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationDATA_H
#define EDM4HEP_RecoParticleVertexAssociationDATA_H


namespace edm4hep {


/** @class RecoParticleVertexAssociationData
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_H
#define EDM4HEP_RecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {

class MutableRecoParticleVertexAssociation;
class RecoParticleVertexAssociationCollection;

/** @class RecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociation {

  friend class MutableRecoParticleVertexAssociation;
  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationCollectionIterator;

public:
  using mutable_type = MutableRecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  RecoParticleVertexAssociation();
  RecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  RecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  RecoParticleVertexAssociation(const RecoParticleVertexAssociation& other);

  /// copy-assignment operator
  RecoParticleVertexAssociation& operator=(RecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~RecoParticleVertexAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecoParticleVertexAssociation& a, RecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecoParticleVertexAssociation_H
#define EDM4HEP_MutableRecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecoParticleVertexAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {


/** @class MutableRecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class MutableRecoParticleVertexAssociation {

  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationMutableCollectionIterator;
  friend class RecoParticleVertexAssociation;

public:
  using object_type = RecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  MutableRecoParticleVertexAssociation();
  MutableRecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  MutableRecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  MutableRecoParticleVertexAssociation(const MutableRecoParticleVertexAssociation& other);

  /// copy-assignment operator
  MutableRecoParticleVertexAssociation& operator=(MutableRecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~MutableRecoParticleVertexAssociation();

  /// conversion to const object
  operator RecoParticleVertexAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the vertex
  void setVertex(edm4hep::Vertex value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecoParticleVertexAssociation& a, MutableRecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationOBJ_H
#define EDM4HEP_RecoParticleVertexAssociationOBJ_H

// data model specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class Vertex;
}


namespace edm4hep {

class RecoParticleVertexAssociation;

class RecoParticleVertexAssociationObj : public podio::ObjBase {
public:
  /// constructor
  RecoParticleVertexAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecoParticleVertexAssociationObj(const RecoParticleVertexAssociationObj&);
  /// constructor from ObjectID and RecoParticleVertexAssociationData
  /// does not initialize the internal relation containers
  RecoParticleVertexAssociationObj(const podio::ObjectID id, RecoParticleVertexAssociationData data);
  /// No assignment operator
  RecoParticleVertexAssociationObj& operator=(const RecoParticleVertexAssociationObj&) = delete;
  virtual ~RecoParticleVertexAssociationObj();

public:
  RecoParticleVertexAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::Vertex* m_vertex{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_CollectionData_H
#define EDM4HEP_RecoParticleVertexAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecoParticleVertexAssociationObjPointerContainer = std::deque<RecoParticleVertexAssociationObj*>;
using RecoParticleVertexAssociationDataContainer = std::vector<RecoParticleVertexAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecoParticleVertexAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecoParticleVertexAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecoParticleVertexAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecoParticleVertexAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecoParticleVertexAssociationCollectionData(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData& operator=(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData(RecoParticleVertexAssociationCollectionData&& other) = default;
  RecoParticleVertexAssociationCollectionData& operator=(RecoParticleVertexAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecoParticleVertexAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::Vertex> m_rel_vertex{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecoParticleVertexAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterDATA_H
#define EDM4HEP_SimPrimaryIonizationClusterDATA_H

#include "edm4hep/Vector3d.h"
#include <cstdint>

namespace edm4hep {


/** @class SimPrimaryIonizationClusterData
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< the primary ionization's time in the lab frame [ns].
  ::edm4hep::Vector3d position{}; ///< the primary ionization's position [mm].
  std::int16_t type{}; ///< type.

  unsigned int electronCellID_begin{};
  unsigned int electronCellID_end{};
  unsigned int electronTime_begin{};
  unsigned int electronTime_end{};
  unsigned int electronPosition_begin{};
  unsigned int electronPosition_end{};
  unsigned int pulseTime_begin{};
  unsigned int pulseTime_end{};
  unsigned int pulseAmplitude_begin{};
  unsigned int pulseAmplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_H
#define EDM4HEP_SimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimPrimaryIonizationCluster;
class SimPrimaryIonizationClusterCollection;

/** @class SimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationCluster {

  friend class MutableSimPrimaryIonizationCluster;
  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableSimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  SimPrimaryIonizationCluster();
  SimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  SimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  SimPrimaryIonizationCluster(const SimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  SimPrimaryIonizationCluster& operator=(SimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~SimPrimaryIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimPrimaryIonizationCluster& a, SimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimPrimaryIonizationCluster_H
#define EDM4HEP_MutableSimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimPrimaryIonizationCluster.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class MutableSimPrimaryIonizationCluster {

  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterMutableCollectionIterator;
  friend class SimPrimaryIonizationCluster;

public:
  using object_type = SimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  MutableSimPrimaryIonizationCluster();
  MutableSimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  MutableSimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  MutableSimPrimaryIonizationCluster(const MutableSimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  MutableSimPrimaryIonizationCluster& operator=(MutableSimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~MutableSimPrimaryIonizationCluster();

  /// conversion to const object
  operator SimPrimaryIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the the primary ionization's time in the lab frame [ns].
  void setTime(float value);

  /// Set the the primary ionization's position [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the primary ionization's position [mm].
  edm4hep::Vector3d& position();

  /// Set the type.
  void setType(std::int16_t value);


  /// Set the the particle that caused the ionizing collisions.
  void setMCParticle(edm4hep::MCParticle value);

  void addToElectronCellID(std::uint64_t);
  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  void addToElectronTime(float);
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  void addToElectronPosition(edm4hep::Vector3d);
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  void addToPulseTime(float);
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  void addToPulseAmplitude(float);
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimPrimaryIonizationCluster& a, MutableSimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterOBJ_H
#define EDM4HEP_SimPrimaryIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/Vector3d.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimPrimaryIonizationCluster;

class SimPrimaryIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  SimPrimaryIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimPrimaryIonizationClusterObj(const SimPrimaryIonizationClusterObj&);
  /// constructor from ObjectID and SimPrimaryIonizationClusterData
  /// does not initialize the internal relation containers
  SimPrimaryIonizationClusterObj(const podio::ObjectID id, SimPrimaryIonizationClusterData data);
  /// No assignment operator
  SimPrimaryIonizationClusterObj& operator=(const SimPrimaryIonizationClusterObj&) = delete;
  virtual ~SimPrimaryIonizationClusterObj();

public:
  SimPrimaryIonizationClusterData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
  std::vector<std::uint64_t>* m_electronCellID{nullptr};
  std::vector<float>* m_electronTime{nullptr};
  std::vector<edm4hep::Vector3d>* m_electronPosition{nullptr};
  std::vector<float>* m_pulseTime{nullptr};
  std::vector<float>* m_pulseAmplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H
#define EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimPrimaryIonizationClusterObjPointerContainer = std::deque<SimPrimaryIonizationClusterObj*>;
using SimPrimaryIonizationClusterDataContainer = std::vector<SimPrimaryIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimPrimaryIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimPrimaryIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimPrimaryIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimPrimaryIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimPrimaryIonizationClusterCollectionData(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData& operator=(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData(SimPrimaryIonizationClusterCollectionData&& other) = default;
  SimPrimaryIonizationClusterCollectionData& operator=(SimPrimaryIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimPrimaryIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimPrimaryIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<std::uint64_t> m_vec_electronCellID{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::uint64_t>> m_vecs_electronCellID{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_electronTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_electronTime{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Vector3d> m_vec_electronPosition{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Vector3d>> m_vecs_electronPosition{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseTime{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseAmplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseAmplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimPrimaryIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseDATA_H
#define EDM4HEP_TrackerPulseDATA_H

#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerPulseData
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulseData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< time [ns].
  float charge{}; ///< charge [fC].
  std::int16_t quality{}; ///< quality.
  std::array<float, 3> covMatrix{}; ///< lower triangle covariance matrix of the charge(c) and time(t) measurements.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_H
#define EDM4HEP_TrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {

class MutableTrackerPulse;
class TrackerPulseCollection;

/** @class TrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulse {

  friend class MutableTrackerPulse;
  friend class TrackerPulseCollection;
  friend class TrackerPulseCollectionIterator;

public:
  using mutable_type = MutableTrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  TrackerPulse();
  TrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  TrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  TrackerPulse(const TrackerPulse& other);

  /// copy-assignment operator
  TrackerPulse& operator=(TrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~TrackerPulse();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerPulse& a, TrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerPulse& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerPulse_H
#define EDM4HEP_MutableTrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerPulse.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {


/** @class MutableTrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class MutableTrackerPulse {

  friend class TrackerPulseCollection;
  friend class TrackerPulseMutableCollectionIterator;
  friend class TrackerPulse;

public:
  using object_type = TrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  MutableTrackerPulse();
  MutableTrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  MutableTrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  MutableTrackerPulse(const MutableTrackerPulse& other);

  /// copy-assignment operator
  MutableTrackerPulse& operator=(MutableTrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~MutableTrackerPulse();

  /// conversion to const object
  operator TrackerPulse() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the time [ns].
  void setTime(float value);

  /// Set the charge [fC].
  void setCharge(float value);

  /// Set the quality.
  void setQuality(std::int16_t value);

  /// Set the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  void setCovMatrix(std::array<float, 3> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to lower triangle covariance matrix of the charge(c) and time(t) measurements.
  std::array<float, 3>& covMatrix();


  /// Set the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  void setTimeSeries(edm4hep::TimeSeries value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerPulse& a, MutableTrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseOBJ_H
#define EDM4HEP_TrackerPulseOBJ_H

// data model specific includes
#include "edm4hep/TrackerPulseData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TimeSeries;
}


namespace edm4hep {

class TrackerPulse;

class TrackerPulseObj : public podio::ObjBase {
public:
  /// constructor
  TrackerPulseObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerPulseObj(const TrackerPulseObj&);
  /// constructor from ObjectID and TrackerPulseData
  /// does not initialize the internal relation containers
  TrackerPulseObj(const podio::ObjectID id, TrackerPulseData data);
  /// No assignment operator
  TrackerPulseObj& operator=(const TrackerPulseObj&) = delete;
  virtual ~TrackerPulseObj();

public:
  TrackerPulseData data;
  edm4hep::TimeSeries* m_timeSeries{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_CollectionData_H
#define EDM4HEP_TrackerPulse_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TimeSeries.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerPulseObjPointerContainer = std::deque<TrackerPulseObj*>;
using TrackerPulseDataContainer = std::vector<TrackerPulseData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerPulseCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerPulseObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerPulseCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerPulseCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerPulseCollectionData(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData& operator=(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData(TrackerPulseCollectionData&& other) = default;
  TrackerPulseCollectionData& operator=(TrackerPulseCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerPulseCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TimeSeries> m_rel_timeSeries{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerPulseDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterDATA_H
#define EDM4HEP_RecIonizationClusterDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RecIonizationClusterData
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float significance{}; ///< significance.
  std::int16_t type{}; ///< type.

  unsigned int trackerPulse_begin{};
  unsigned int trackerPulse_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_H
#define EDM4HEP_RecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRecIonizationCluster;
class RecIonizationClusterCollection;

/** @class RecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationCluster {

  friend class MutableRecIonizationCluster;
  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableRecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  RecIonizationCluster();
  RecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  RecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  RecIonizationCluster(const RecIonizationCluster& other);

  /// copy-assignment operator
  RecIonizationCluster& operator=(RecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~RecIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecIonizationCluster& a, RecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecIonizationCluster_H
#define EDM4HEP_MutableRecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecIonizationCluster.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecIonizationCluster {

  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterMutableCollectionIterator;
  friend class RecIonizationCluster;

public:
  using object_type = RecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  MutableRecIonizationCluster();
  MutableRecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  MutableRecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  MutableRecIonizationCluster(const MutableRecIonizationCluster& other);

  /// copy-assignment operator
  MutableRecIonizationCluster& operator=(MutableRecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~MutableRecIonizationCluster();

  /// conversion to const object
  operator RecIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the significance.
  void setSignificance(float value);

  /// Set the type.
  void setType(std::int16_t value);



  void addToTrackerPulse(edm4hep::TrackerPulse);
  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecIonizationCluster& a, MutableRecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterOBJ_H
#define EDM4HEP_RecIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/TrackerPulse.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RecIonizationCluster;

class RecIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  RecIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecIonizationClusterObj(const RecIonizationClusterObj&);
  /// constructor from ObjectID and RecIonizationClusterData
  /// does not initialize the internal relation containers
  RecIonizationClusterObj(const podio::ObjectID id, RecIonizationClusterData data);
  /// No assignment operator
  RecIonizationClusterObj& operator=(const RecIonizationClusterObj&) = delete;
  virtual ~RecIonizationClusterObj();

public:
  RecIonizationClusterData data;
  std::vector<edm4hep::TrackerPulse>* m_trackerPulse{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_CollectionData_H
#define EDM4HEP_RecIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/TrackerPulse.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecIonizationClusterObjPointerContainer = std::deque<RecIonizationClusterObj*>;
using RecIonizationClusterDataContainer = std::vector<RecIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecIonizationClusterCollectionData(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData& operator=(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData(RecIonizationClusterCollectionData&& other) = default;
  RecIonizationClusterCollectionData& operator=(RecIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerPulse> m_rel_trackerPulse;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerPulse>> m_rel_trackerPulse_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesDATA_H
#define EDM4HEP_TimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TimeSeriesData
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeriesData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< begin time [ns].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int amplitude_begin{};
  unsigned int amplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_H
#define EDM4HEP_TimeSeries_H

#include "edm4hep/TimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTimeSeries;
class TimeSeriesCollection;

/** @class TimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeries {

  friend class MutableTimeSeries;
  friend class TimeSeriesCollection;
  friend class TimeSeriesCollectionIterator;

public:
  using mutable_type = MutableTimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  TimeSeries();
  TimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  TimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  TimeSeries(const TimeSeries& other);

  /// copy-assignment operator
  TimeSeries& operator=(TimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~TimeSeries();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TimeSeries& a, TimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTimeSeries_H
#define EDM4HEP_MutableTimeSeries_H

#include "edm4hep/TimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class MutableTimeSeries {

  friend class TimeSeriesCollection;
  friend class TimeSeriesMutableCollectionIterator;
  friend class TimeSeries;

public:
  using object_type = TimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  MutableTimeSeries();
  MutableTimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  MutableTimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  MutableTimeSeries(const MutableTimeSeries& other);

  /// copy-assignment operator
  MutableTimeSeries& operator=(MutableTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~MutableTimeSeries();

  /// conversion to const object
  operator TimeSeries() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the begin time [ns].
  void setTime(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAmplitude(float);
  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const TimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTimeSeries& a, MutableTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesOBJ_H
#define EDM4HEP_TimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/TimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TimeSeries;

class TimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  TimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  TimeSeriesObj(const TimeSeriesObj&);
  /// constructor from ObjectID and TimeSeriesData
  /// does not initialize the internal relation containers
  TimeSeriesObj(const podio::ObjectID id, TimeSeriesData data);
  /// No assignment operator
  TimeSeriesObj& operator=(const TimeSeriesObj&) = delete;
  virtual ~TimeSeriesObj();

public:
  TimeSeriesData data;
  std::vector<float>* m_amplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_CollectionData_H
#define EDM4HEP_TimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TimeSeriesObjPointerContainer = std::deque<TimeSeriesObj*>;
using TimeSeriesDataContainer = std::vector<TimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TimeSeriesCollectionData(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData& operator=(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData(TimeSeriesCollectionData&& other) = default;
  TimeSeriesCollectionData& operator=(TimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_amplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_amplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxDATA_H
#define EDM4HEP_RecDqdxDATA_H

#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class RecDqdxData
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdxData {
public:
  ::edm4hep::Quantity dQdx{}; ///< the reconstructed dEdx or dNdx and its error
  std::int16_t particleType{}; ///< particle type, e(0),mu(1),pi(2),K(3),p(4).
  std::int16_t type{}; ///< type.
  std::array<edm4hep::Hypothesis, 5> hypotheses{}; ///< 5 particle hypothesis

  unsigned int hitData_begin{};
  unsigned int hitData_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_H
#define EDM4HEP_RecDqdx_H

#include "edm4hep/RecDqdxObj.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {

class MutableRecDqdx;
class RecDqdxCollection;

/** @class RecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdx {

  friend class MutableRecDqdx;
  friend class RecDqdxCollection;
  friend class RecDqdxCollectionIterator;

public:
  using mutable_type = MutableRecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  RecDqdx();
  RecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  RecDqdx(RecDqdxObj* obj);

  /// copy constructor
  RecDqdx(const RecDqdx& other);

  /// copy-assignment operator
  RecDqdx& operator=(RecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~RecDqdx();


public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecDqdx& a, RecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecDqdx& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecDqdx_H
#define EDM4HEP_MutableRecDqdx_H

#include "edm4hep/RecDqdxObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecDqdx.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {


/** @class MutableRecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecDqdx {

  friend class RecDqdxCollection;
  friend class RecDqdxMutableCollectionIterator;
  friend class RecDqdx;

public:
  using object_type = RecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  MutableRecDqdx();
  MutableRecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  MutableRecDqdx(RecDqdxObj* obj);

  /// copy constructor
  MutableRecDqdx(const MutableRecDqdx& other);

  /// copy-assignment operator
  MutableRecDqdx& operator=(MutableRecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~MutableRecDqdx();

  /// conversion to const object
  operator RecDqdx() const;

public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  /// Set the the reconstructed dEdx or dNdx and its error
  void setDQdx(edm4hep::Quantity value);
  /// Get reference to the reconstructed dEdx or dNdx and its error
  edm4hep::Quantity& dQdx();

  /// Set the particle type, e(0),mu(1),pi(2),K(3),p(4).
  void setParticleType(std::int16_t value);

  /// Set the type.
  void setType(std::int16_t value);

  /// Set the 5 particle hypothesis
  void setHypotheses(std::array<edm4hep::Hypothesis, 5> value);
  void setHypotheses(size_t i, edm4hep::Hypothesis value);
  /// Get reference to 5 particle hypothesis
  std::array<edm4hep::Hypothesis, 5>& hypotheses();


  /// Set the the corresponding track.
  void setTrack(edm4hep::Track value);

  void addToHitData(edm4hep::HitLevelData);
  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecDqdx& a, MutableRecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxOBJ_H
#define EDM4HEP_RecDqdxOBJ_H

// data model specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/HitLevelData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Track;
}


namespace edm4hep {

class RecDqdx;

class RecDqdxObj : public podio::ObjBase {
public:
  /// constructor
  RecDqdxObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecDqdxObj(const RecDqdxObj&);
  /// constructor from ObjectID and RecDqdxData
  /// does not initialize the internal relation containers
  RecDqdxObj(const podio::ObjectID id, RecDqdxData data);
  /// No assignment operator
  RecDqdxObj& operator=(const RecDqdxObj&) = delete;
  virtual ~RecDqdxObj();

public:
  RecDqdxData data;
  edm4hep::Track* m_track{nullptr};
  std::vector<edm4hep::HitLevelData>* m_hitData{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_CollectionData_H
#define EDM4HEP_RecDqdx_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecDqdxObjPointerContainer = std::deque<RecDqdxObj*>;
using RecDqdxDataContainer = std::vector<RecDqdxData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecDqdxCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecDqdxObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecDqdxCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecDqdxCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecDqdxCollectionData(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData& operator=(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData(RecDqdxCollectionData&& other) = default;
  RecDqdxCollectionData& operator=(RecDqdxCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecDqdxCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecDqdxObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_track{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<edm4hep::HitLevelData> m_vec_hitData{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::HitLevelData>> m_vecs_hitData{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecDqdxDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#include "podio/DatamodelRegistry.h"
#include "podio/SchemaEvolution.h"

namespace edm4hep::meta {
/**
 * The complete definition of the datamodel at generation time in JSON format.
 */
static constexpr auto edm4hep__JSONDefinition = R"DATAMODELDEF({"options": {"getSyntax": true, "exposePODMembers": false, "includeSubfolder": "edm4hep/", "schema_version": 1}, "schema_version": 1, "components": {"edm4hep::Vector3f": {"Members": ["float x", "float y", "float z"], "ExtraCode": {"declaration": " constexpr Vector3f() : x(0),y(0),z(0) {}\n constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr float operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector3d": {"Members": ["double x", "double y", "double z"], "ExtraCode": {"declaration": " constexpr Vector3d() : x(0),y(0),z(0) {}\n constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr double operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector2i": {"Members": ["std::int32_t a", "std::int32_t b"], "ExtraCode": {"declaration": " constexpr Vector2i() : a(0),b(0) {}\n constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}\n constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }\n constexpr int operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::Vector2f": {"Members": ["float a", "float b"], "ExtraCode": {"declaration": " constexpr Vector2f() : a(0),b(0) {}\n constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}\n constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }\n constexpr float operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::TrackState": {"Members": ["std::int32_t location // for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation", "float D0 // transverse impact parameter", "float phi // azimuthal angle", "float omega // is the signed curvature of the track in [1/mm].", "float Z0 // longitudinal impact parameter", "float tanLambda // lambda is the dip angle of the track in r-z", "float time // time of the track at this trackstate", "edm4hep::Vector3f referencePoint // Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]", "std::array<float, 21> covMatrix // lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix."], "ExtraCode": {"declaration": " static const int AtOther = 0 ; // any location other than the ones defined below\n static const int AtIP = 1 ;\n static const int AtFirstHit = 2 ;\n static const int AtLastHit = 3 ;\n static const int AtCalorimeter = 4 ;\n static const int AtVertex = 5 ;\n static const int LastLocation = AtVertex  ;\n "}}, "edm4hep::ObjectID": {"Members": ["std::int32_t index", "std::int32_t collectionID"], "ExtraCode": {"includes": "#include <podio/ObjectID.h>\n", "declaration": " ObjectID() = default;\n ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}\n "}}, "edm4hep::Quantity": {"Members": ["std::int16_t type // flag identifying how to interpret the quantity", "float value // value of the quantity", "float error // error on the value of the quantity"]}, "edm4hep::Hypothesis": {"Members": ["float chi2 // chi2", "float expected // expected value", "float sigma // sigma value"]}, "edm4hep::HitLevelData": {"Members": ["std::uint64_t cellID // cell id", "std::uint32_t N // number of reconstructed ionization cluster.", "float eDep // reconstructed energy deposit [GeV].", "float pathLength // track path length [mm]."]}}, "datatypes": {"edm4hep::EventHeader": {"Description": "Event Header. Additional parameters are assumed to go into the metadata tree.", "Author": "F.Gaede", "Members": ["std::int32_t eventNumber // event number", "std::int32_t runNumber // run number", "std::uint64_t timeStamp // time stamp", "float weight // event weight"], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCParticle": {"Description": "The Monte Carlo particle - based on the lcio::MCParticle.", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the particle", "std::int32_t generatorStatus // status of the particle as defined by the generator", "std::int32_t simulatorStatus // status of the particle from the simulation program - use BIT constants below", "float charge // particle charge", "float time // creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.", "double mass // mass of the particle in [GeV]", "edm4hep::Vector3d vertex // production vertex of the particle in [mm].", "edm4hep::Vector3d endpoint // endpoint of the particle in [mm]", "edm4hep::Vector3f momentum // particle 3-momentum at the production vertex in [GeV]", "edm4hep::Vector3f momentumAtEndpoint // particle 3-momentum at the endpoint in [GeV]", "edm4hep::Vector3f spin // spin (helicity) vector of the particle.", "edm4hep::Vector2i colorFlow // color flow as defined by the generator"], "OneToManyRelations": ["edm4hep::MCParticle parents // The parents of this particle.", "edm4hep::MCParticle daughters // The daughters this particle."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               \n void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  \t\t     \n void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  \t\t\t     \n void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } \n void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  \t\t     \n void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  \t\t     \n void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  \t\t\t     \n void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  \t\t\t\t     \n void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         \n "}, "ExtraCode": {"declaration": " // define the bit positions for the simulation flag\n static const int BITEndpoint = 31;\n static const int BITCreatedInSimulation = 30;\n static const int BITBackscatter = 29 ;\n static const int BITVertexIsNotEndpointOfParent = 28 ;  \n static const int BITDecayedInTracker = 27 ; \n static const int BITDecayedInCalorimeter = 26 ;   \n static const int BITLeftDetector = 25 ;     \n static const int BITStopped = 24 ;    \n static const int BITOverlay = 23 ;    \n /// return energy computed from momentum and mass \n double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+\n getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} \n\n/// True if the particle has been created by the simulation program (rather than the generator).     \n bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    \n /// True if the particle is the result of a backscatter from a calorimeter shower. \n bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   \n /// True if the particle's vertex is not the endpoint of the  parent particle.     \n bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } \n /// True if the particle has interacted in a tracking region.                \n bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     \n /// True if the particle has interacted in a calorimeter region.             \n bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   \n /// True if the particle has left the world volume undecayed.                \n bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }\n /// True if the particle has been stopped by the simulation program.         \n bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     \n /// True if the particle has been overlayed by the simulation (or digitization)  program.\n bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     \n "}, "VectorMembers": [], "OneToOneRelations": []}, "edm4hep::SimTrackerHit": {"Description": "Simulated tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float EDep // energy deposited in the hit [GeV].", "float time // proper time of the hit in the lab frame in [ns].", "float pathLength // path length of the particle in the sensitive material that resulted in this hit.", "std::int32_t quality // quality bit flag.", "edm4hep::Vector3d position // the hit position in [mm].", "edm4hep::Vector3f momentum // the 3-momentum of the particle at the hits position in [GeV]"], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // MCParticle that caused the hit."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }\n void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }\n void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }\n "}, "ExtraCode": {"declaration": " static const int  BITOverlay = 31;\n static const int  BITProducedBySecondary = 30;\n bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }\n bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }\n double x() const {return getPosition()[0];}\n double y() const {return getPosition()[1];}\n double z() const {return getPosition()[2];}\n double rho() const {return sqrt(x()*x() + y()*y());}\n "}, "VectorMembers": [], "OneToManyRelations": []}, "edm4hep::CaloHitContribution": {"Description": "Monte Carlo contribution to SimCalorimeterHit", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the shower particle that caused this contribution.", "float energy // energy in [GeV] of the this contribution", "float time // time in [ns] of this contribution", "edm4hep::Vector3f stepPosition // position of this energy deposition (step) [mm]"], "OneToOneRelations": ["edm4hep::MCParticle particle // primary MCParticle that caused the shower responsible for this contribution to the hit."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimCalorimeterHit": {"Description": "Simulated calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float energy // energy of the hit in [GeV].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm]."], "OneToManyRelations": ["edm4hep::CaloHitContribution contributions // Monte Carlo step contribution - parallel to particle"], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawCalorimeterHit": {"Description": "Raw calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "std::int32_t amplitude // amplitude of the hit in ADC counts.", "std::int32_t timeStamp // time stamp for the hit."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::CalorimeterHit": {"Description": "Calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "float energy // energy of the hit in [GeV].", "float energyError // error of the hit energy in [GeV].", "float time // time of the hit in [ns].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm].", "std::int32_t type // type of hit. Mapping of integer types to names via collection parameters \"CalorimeterHitTypeNames\" and \"CalorimeterHitTypeValues\"."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ParticleID": {"Description": "ParticleID", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // userdefined type", "std::int32_t PDG // PDG code of this id - ( 999999 ) if unknown.", "std::int32_t algorithmType // type of the algorithm/module that created this hypothesis", "float likelihood // likelihood of this hypothesis - in a user defined normalization."], "VectorMembers": ["float parameters // parameters associated with this hypothesis. Check/set collection parameters ParameterNames_PIDAlgorithmTypeName for decoding the indices."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Cluster": {"Description": "Calorimeter Hit Cluster", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of cluster. Bits 16-31 are used internally.", "float energy // energy of the cluster [GeV]", "float energyError // error on the energy", "edm4hep::Vector3f position // position of the cluster [mm]", "std::array<float, 6> positionError // covariance matrix of the position (6 Parameters)", "float iTheta // intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.", "float phi // intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.", "edm4hep::Vector3f directionError // covariance matrix of the direction (3 Parameters) [mm^2]"], "VectorMembers": ["float shapeParameters // shape parameters - check/set collection parameter ClusterShapeParameters for size and names of parameters.", "float subdetectorEnergies // energy observed in a particular subdetector. Check/set collection parameter ClusterSubdetectorNames for decoding the indices of the array."], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been combined to this cluster.", "edm4hep::CalorimeterHit hits // hits that have been combined to this cluster.", "edm4hep::ParticleID particleIDs // particle IDs (sorted by their likelihood)"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHit": {"Description": "Tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHitPlane": {"Description": "Tracker hit plane", "Author": "Placido Fernandez Declara, CERN", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector2f u // measurement direction vector, u lies in the x-y plane", "edm4hep::Vector2f v // measurement direction vector, v is along z", "float du // measurement error along the direction", "float dv // measurement error along the direction", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawTimeSeries": {"Description": "Raw data of a detector readout", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific cell id.", "std::int32_t quality // quality flag for the hit.", "float time // time of the hit [ns].", "float charge // integrated charge of the hit [fC].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["std::int32_t adcCounts // raw data (32-bit) word at i."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Track": {"Description": "Reconstructed track", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of track.Bits 16-31 are used internally", "float chi2 // Chi^2 of the track fit", "std::int32_t ndf // number of degrees of freedom of the track fit", "float dEdx // dEdx of the track.", "float dEdxError // error of dEdx.", "float radiusOfInnermostHit // radius of the innermost hit that has been used in the track fit"], "VectorMembers": ["std::int32_t subdetectorHitNumbers // number of hits in particular subdetectors.Check/set collection variable TrackSubdetectorNames for decoding the indices", "edm4hep::TrackState trackStates // track states", "edm4hep::Quantity dxQuantities // different measurements of dx quantities"], "OneToManyRelations": ["edm4hep::TrackerHit trackerHits // hits that have been used to create this track", "edm4hep::Track tracks // tracks (segments) that have been combined to create this track"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Vertex": {"Description": "Vertex", "Author": "F.Gaede, DESY", "Members": ["std::int32_t primary // boolean flag, if vertex is the primary vertex of the event", "float chi2 // chi-squared of the vertex fit", "float probability // probability of the vertex fit", "edm4hep::Vector3f position // [mm] position of the vertex.", "std::array<float, 6> covMatrix // covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )", "std::int32_t algorithmType // type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType."], "VectorMembers": ["float parameters // additional parameters related to this vertex - check/set the collection parameter \"VertexParameterNames\" for the parameters meaning."], "OneToOneRelations": ["edm4hep::ReconstructedParticle associatedParticle // reconstructed particle associated to this vertex."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ReconstructedParticle": {"Description": "Reconstructed Particle", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.", "float energy // [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f momentum // [GeV] particle momentum. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f referencePoint // [mm] reference, i.e. where the particle has been measured", "float charge // charge of the reconstructed particle.", "float mass // [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.", "float goodnessOfPID // overall goodness of the PID on a scale of [0;1]", "std::array<float, 10> covMatrix // cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##"], "OneToOneRelations": ["edm4hep::Vertex startVertex // start vertex associated to this particle", "edm4hep::ParticleID particleIDUsed // particle Id used for the kinematics of this particle"], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been used for this particle.", "edm4hep::Track tracks // tracks that have been used for this particle.", "edm4hep::ReconstructedParticle particles // reconstructed particles that have been combined to this particle.", "edm4hep::ParticleID particleIDs // particle Ids (not sorted by their likelihood)"], "ExtraCode": {"declaration": " bool isCompound() const { return particles_size() > 0 ;}\n "}, "MutableExtraCode": {"declaration": " //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.\n //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }\n "}, "VectorMembers": []}, "edm4hep::MCRecoParticleAssociation": {"Description": "Used to keep track of the correspondence between MC and reconstructed particles", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloAssociation": {"Description": "Association between a CaloHit and the corresponding simulated CaloHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::SimCalorimeterHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerAssociation": {"Description": "Association between a TrackerHit and the corresponding simulated TrackerHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHit rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerHitPlaneAssociation": {"Description": "Association between a TrackerHitPlane and the corresponding simulated TrackerHit", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHitPlane rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloParticleAssociation": {"Description": "Association between a CalorimeterHit and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoClusterParticleAssociation": {"Description": "Association between a Cluster and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Cluster rec // reference to the cluster", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackParticleAssociation": {"Description": "Association between a Track and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Track rec // reference to the track", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecoParticleVertexAssociation": {"Description": "Association between a Reconstructed Particle and a Vertex", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::Vertex vertex // reference to the vertex"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimPrimaryIonizationCluster": {"Description": "Simulated Primary Ionization", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // the primary ionization's time in the lab frame [ns].", "edm4hep::Vector3d position // the primary ionization's position [mm].", "std::int16_t type // type."], "VectorMembers": ["std::uint64_t electronCellID // cell id.", "float electronTime // the time in the lab frame [ns].", "edm4hep::Vector3d electronPosition // the position in the lab frame [mm].", "float pulseTime // the pulse's time in the lab frame [ns].", "float pulseAmplitude // the pulse's amplitude [fC]."], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // the particle that caused the ionizing collisions."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerPulse": {"Description": "Reconstructed Tracker Pulse", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // time [ns].", "float charge // charge [fC].", "std::int16_t quality // quality.", "std::array<float, 3> covMatrix // lower triangle covariance matrix of the charge(c) and time(t) measurements."], "OneToOneRelations": ["edm4hep::TimeSeries timeSeries // Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecIonizationCluster": {"Description": "Reconstructed Ionization Cluster", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float significance // significance.", "std::int16_t type // type."], "OneToManyRelations": ["edm4hep::TrackerPulse trackerPulse // the TrackerPulse used to create the ionization cluster."], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TimeSeries": {"Description": "Calibrated Detector Data", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // begin time [ns].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["float amplitude // calibrated detector data."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecDqdx": {"Description": "dN/dx or dE/dx info of Track.", "Author": "Wenxing Fang, IHEP", "Members": ["edm4hep::Quantity dQdx // the reconstructed dEdx or dNdx and its error", "std::int16_t particleType // particle type, e(0),mu(1),pi(2),K(3),p(4).", "std::int16_t type // type.", "std::array<edm4hep::Hypothesis, 5> hypotheses // 5 particle hypothesis"], "VectorMembers": ["edm4hep::HitLevelData hitData // hit level data"], "OneToOneRelations": ["edm4hep::Track track // the corresponding track."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}}})DATAMODELDEF";


/**
 * The names of all relations and vector members for all datatypes
 */
inline podio::RelationNameMapping edm4hep__getRelationNames() {
  using namespace std::string_view_literals;
  return {
    {"edm4hep::EventHeader"sv,
      {  },
      {  },
    },
    {"edm4hep::MCParticle"sv,
      { "parents"sv, "daughters"sv },
      {  },
    },
    {"edm4hep::SimTrackerHit"sv,
      { "MCParticle"sv },
      {  },
    },
    {"edm4hep::CaloHitContribution"sv,
      { "particle"sv },
      {  },
    },
    {"edm4hep::SimCalorimeterHit"sv,
      { "contributions"sv },
      {  },
    },
    {"edm4hep::RawCalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::CalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::ParticleID"sv,
      {  },
      { "parameters"sv },
    },
    {"edm4hep::Cluster"sv,
      { "clusters"sv, "hits"sv, "particleIDs"sv },
      { "shapeParameters"sv, "subdetectorEnergies"sv },
    },
    {"edm4hep::TrackerHit"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::TrackerHitPlane"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::RawTimeSeries"sv,
      {  },
      { "adcCounts"sv },
    },
    {"edm4hep::Track"sv,
      { "trackerHits"sv, "tracks"sv },
      { "subdetectorHitNumbers"sv, "trackStates"sv, "dxQuantities"sv },
    },
    {"edm4hep::Vertex"sv,
      { "associatedParticle"sv },
      { "parameters"sv },
    },
    {"edm4hep::ReconstructedParticle"sv,
      { "clusters"sv, "tracks"sv, "particles"sv, "particleIDs"sv, "startVertex"sv, "particleIDUsed"sv },
      {  },
    },
    {"edm4hep::MCRecoParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerHitPlaneAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoClusterParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::RecoParticleVertexAssociation"sv,
      { "rec"sv, "vertex"sv },
      {  },
    },
    {"edm4hep::SimPrimaryIonizationCluster"sv,
      { "MCParticle"sv },
      { "electronCellID"sv, "electronTime"sv, "electronPosition"sv, "pulseTime"sv, "pulseAmplitude"sv },
    },
    {"edm4hep::TrackerPulse"sv,
      { "timeSeries"sv },
      {  },
    },
    {"edm4hep::RecIonizationCluster"sv,
      { "trackerPulse"sv },
      {  },
    },
    {"edm4hep::TimeSeries"sv,
      {  },
      { "amplitude"sv },
    },
    {"edm4hep::RecDqdx"sv,
      { "track"sv },
      { "hitData"sv },
    },
  };
}

/**
 * The schema version at generation time
 */
static constexpr podio::SchemaVersionT schemaVersion = 1;

/**
 * The helper class that takes care of registering the datamodel definition to
 * the DatamodelRegistry and to provide the index in that registry.
 *
 * Implemented as a singleton mainly to ensure only a single registration of
 * each datamodel, during the constructor
 */
class DatamodelRegistryIndex {
public:
  static size_t value() {
    static const auto relationNames = edm4hep__getRelationNames();
    static auto index = DatamodelRegistryIndex(podio::DatamodelRegistry::mutInstance().registerDatamodel("edm4hep", edm4hep__JSONDefinition, relationNames));
    return index.m_value;
  }
private:
  DatamodelRegistryIndex(size_t v) : m_value(v) {}
  size_t m_value{podio::DatamodelRegistry::NoDefinitionAvailable};
};


namespace static_registration {
  // The usual trick via an IIFE and a const variable that we assign to, to
  // ensure that we populate this before everything starts
  inline  bool ensureRegistration() {
    const static auto reg = []() {
      return edm4hep::meta::DatamodelRegistryIndex::value() != podio::DatamodelRegistry::NoDefinitionAvailable;
    }();
    return reg;
  }

  const auto registrationEnsured = ensureRegistration();
}

} // namespace edm4hep::meta

#undef  _BACKWARD_BACKWARD_WARNING_H

TInterpreter::A...  ERROR Error parsing payload code for class edm4hep::CaloHitContributionData with content:

#line 1 "libedm4hepDict dictionary payload"

#ifndef PODIO_JSON_OUTPUT
  #define PODIO_JSON_OUTPUT 1
#endif
#ifndef JSON_USE_IMPLICIT_CONVERSIONS
  #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif
#ifndef JSON_DIAGNOSTICS
  #define JSON_DIAGNOSTICS 0
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3f_H
#define EDM4HEP_Vector3f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3f
 *  
 *  @author: 
 */
class Vector3f {
public:
  float x{};
  float y{};
  float z{};

 constexpr Vector3f() : x(0),y(0),z(0) {}
 constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr float operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3d_H
#define EDM4HEP_Vector3d_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3d
 *  
 *  @author: 
 */
class Vector3d {
public:
  double x{};
  double y{};
  double z{};

 constexpr Vector3d() : x(0),y(0),z(0) {}
 constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr double operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3d& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3d& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2i_H
#define EDM4HEP_Vector2i_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2i
 *  
 *  @author: 
 */
class Vector2i {
public:
  std::int32_t a{};
  std::int32_t b{};

 constexpr Vector2i() : a(0),b(0) {}
 constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}
 constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }
 constexpr int operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2i& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2i& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2f_H
#define EDM4HEP_Vector2f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2f
 *  
 *  @author: 
 */
class Vector2f {
public:
  float a{};
  float b{};

 constexpr Vector2f() : a(0),b(0) {}
 constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}
 constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }
 constexpr float operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackState_H
#define EDM4HEP_TrackState_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class TrackState
 *  
 *  @author: 
 */
class TrackState {
public:
  std::int32_t location{}; ///< for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
  float D0{}; ///< transverse impact parameter
  float phi{}; ///< azimuthal angle
  float omega{}; ///< is the signed curvature of the track in [1/mm].
  float Z0{}; ///< longitudinal impact parameter
  float tanLambda{}; ///< lambda is the dip angle of the track in r-z
  float time{}; ///< time of the track at this trackstate
  ::edm4hep::Vector3f referencePoint{}; ///< Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
  std::array<float, 21> covMatrix{}; ///< lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.

 static const int AtOther = 0 ; // any location other than the ones defined below
 static const int AtIP = 1 ;
 static const int AtFirstHit = 2 ;
 static const int AtLastHit = 3 ;
 static const int AtCalorimeter = 4 ;
 static const int AtVertex = 5 ;
 static const int LastLocation = AtVertex  ;
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::TrackState& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackState& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ObjectID_H
#define EDM4HEP_ObjectID_H

#include <podio/ObjectID.h>
#include <cstdint>
#include <podio/ObjectID.h>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class ObjectID
 *  
 *  @author: 
 */
class ObjectID {
public:
  std::int32_t index{};
  std::int32_t collectionID{};

 ObjectID() = default;
 ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::ObjectID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ObjectID& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Quantity_H
#define EDM4HEP_Quantity_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Quantity
 *  
 *  @author: 
 */
class Quantity {
public:
  std::int16_t type{}; ///< flag identifying how to interpret the quantity
  float value{}; ///< value of the quantity
  float error{}; ///< error on the value of the quantity


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Quantity& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Quantity& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Hypothesis_H
#define EDM4HEP_Hypothesis_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Hypothesis
 *  
 *  @author: 
 */
class Hypothesis {
public:
  float chi2{}; ///< chi2
  float expected{}; ///< expected value
  float sigma{}; ///< sigma value


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Hypothesis& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Hypothesis& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_HitLevelData_H
#define EDM4HEP_HitLevelData_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class HitLevelData
 *  
 *  @author: 
 */
class HitLevelData {
public:
  std::uint64_t cellID{}; ///< cell id
  std::uint32_t N{}; ///< number of reconstructed ionization cluster.
  float eDep{}; ///< reconstructed energy deposit [GeV].
  float pathLength{}; ///< track path length [mm].


};

std::ostream& operator<<(std::ostream& o, const edm4hep::HitLevelData& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const HitLevelData& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderDATA_H
#define EDM4HEP_EventHeaderDATA_H

#include <cstdint>

namespace edm4hep {


/** @class EventHeaderData
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeaderData {
public:
  std::int32_t eventNumber{}; ///< event number
  std::int32_t runNumber{}; ///< run number
  std::uint64_t timeStamp{}; ///< time stamp
  float weight{}; ///< event weight

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_H
#define EDM4HEP_EventHeader_H

#include "edm4hep/EventHeaderObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableEventHeader;
class EventHeaderCollection;

/** @class EventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeader {

  friend class MutableEventHeader;
  friend class EventHeaderCollection;
  friend class EventHeaderCollectionIterator;

public:
  using mutable_type = MutableEventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  EventHeader();
  EventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  EventHeader(EventHeaderObj* obj);

  /// copy constructor
  EventHeader(const EventHeader& other);

  /// copy-assignment operator
  EventHeader& operator=(EventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~EventHeader();


public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const EventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableEventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const EventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(EventHeader& a, EventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const EventHeader& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableEventHeader_H
#define EDM4HEP_MutableEventHeader_H

#include "edm4hep/EventHeaderObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/EventHeader.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableEventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class MutableEventHeader {

  friend class EventHeaderCollection;
  friend class EventHeaderMutableCollectionIterator;
  friend class EventHeader;

public:
  using object_type = EventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  MutableEventHeader();
  MutableEventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  MutableEventHeader(EventHeaderObj* obj);

  /// copy constructor
  MutableEventHeader(const MutableEventHeader& other);

  /// copy-assignment operator
  MutableEventHeader& operator=(MutableEventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~MutableEventHeader();

  /// conversion to const object
  operator EventHeader() const;

public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;



  /// Set the event number
  void setEventNumber(std::int32_t value);

  /// Set the run number
  void setRunNumber(std::int32_t value);

  /// Set the time stamp
  void setTimeStamp(std::uint64_t value);

  /// Set the event weight
  void setWeight(float value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableEventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const EventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableEventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableEventHeader& a, MutableEventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableEventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderOBJ_H
#define EDM4HEP_EventHeaderOBJ_H

// data model specific includes
#include "edm4hep/EventHeaderData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class EventHeader;

class EventHeaderObj : public podio::ObjBase {
public:
  /// constructor
  EventHeaderObj();
  /// copy constructor (does a deep-copy of relation containers)
  EventHeaderObj(const EventHeaderObj&);
  /// constructor from ObjectID and EventHeaderData
  /// does not initialize the internal relation containers
  EventHeaderObj(const podio::ObjectID id, EventHeaderData data);
  /// No assignment operator
  EventHeaderObj& operator=(const EventHeaderObj&) = delete;
  virtual ~EventHeaderObj() = default;

public:
  EventHeaderData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_CollectionData_H
#define EDM4HEP_EventHeader_CollectionData_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeaderObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using EventHeaderObjPointerContainer = std::deque<EventHeaderObj*>;
using EventHeaderDataContainer = std::vector<EventHeaderData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class EventHeaderCollectionData {
public:
  /**
   * The Objs of this collection
   */
  EventHeaderObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  EventHeaderCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  EventHeaderCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  EventHeaderCollectionData(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData& operator=(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData(EventHeaderCollectionData&& other) = default;
  EventHeaderCollectionData& operator=(EventHeaderCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~EventHeaderCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<EventHeaderDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleDATA_H
#define EDM4HEP_MCParticleDATA_H

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class MCParticleData
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticleData {
public:
  std::int32_t PDG{}; ///< PDG code of the particle
  std::int32_t generatorStatus{}; ///< status of the particle as defined by the generator
  std::int32_t simulatorStatus{}; ///< status of the particle from the simulation program - use BIT constants below
  float charge{}; ///< particle charge
  float time{}; ///< creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  double mass{}; ///< mass of the particle in [GeV]
  ::edm4hep::Vector3d vertex{}; ///< production vertex of the particle in [mm].
  ::edm4hep::Vector3d endpoint{}; ///< endpoint of the particle in [mm]
  ::edm4hep::Vector3f momentum{}; ///< particle 3-momentum at the production vertex in [GeV]
  ::edm4hep::Vector3f momentumAtEndpoint{}; ///< particle 3-momentum at the endpoint in [GeV]
  ::edm4hep::Vector3f spin{}; ///< spin (helicity) vector of the particle.
  ::edm4hep::Vector2i colorFlow{}; ///< color flow as defined by the generator

  unsigned int parents_begin{};
  unsigned int parents_end{};
  unsigned int daughters_begin{};
  unsigned int daughters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_H
#define EDM4HEP_MCParticle_H

#include "edm4hep/MCParticleObj.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableMCParticle;
class MCParticleCollection;

/** @class MCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticle {

  friend class MutableMCParticle;
  friend class MCParticleCollection;
  friend class MCParticleCollectionIterator;

public:
  using mutable_type = MutableMCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MCParticle();
  MCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MCParticle(MCParticleObj* obj);

  /// copy constructor
  MCParticle(const MCParticle& other);

  /// copy-assignment operator
  MCParticle& operator=(MCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MCParticle();


public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCParticle& a, MCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCParticle_H
#define EDM4HEP_MutableMCParticle_H

#include "edm4hep/MCParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCParticle.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableMCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MutableMCParticle {

  friend class MCParticleCollection;
  friend class MCParticleMutableCollectionIterator;
  friend class MCParticle;

public:
  using object_type = MCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MutableMCParticle();
  MutableMCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MutableMCParticle(MCParticleObj* obj);

  /// copy constructor
  MutableMCParticle(const MutableMCParticle& other);

  /// copy-assignment operator
  MutableMCParticle& operator=(MutableMCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MutableMCParticle();

  /// conversion to const object
  operator MCParticle() const;

public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  /// Set the PDG code of the particle
  void setPDG(std::int32_t value);

  /// Set the status of the particle as defined by the generator
  void setGeneratorStatus(std::int32_t value);

  /// Set the status of the particle from the simulation program - use BIT constants below
  void setSimulatorStatus(std::int32_t value);

  /// Set the particle charge
  void setCharge(float value);

  /// Set the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  void setTime(float value);

  /// Set the mass of the particle in [GeV]
  void setMass(double value);

  /// Set the production vertex of the particle in [mm].
  void setVertex(edm4hep::Vector3d value);
  /// Get reference to production vertex of the particle in [mm].
  edm4hep::Vector3d& vertex();

  /// Set the endpoint of the particle in [mm]
  void setEndpoint(edm4hep::Vector3d value);
  /// Get reference to endpoint of the particle in [mm]
  edm4hep::Vector3d& endpoint();

  /// Set the particle 3-momentum at the production vertex in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the production vertex in [GeV]
  edm4hep::Vector3f& momentum();

  /// Set the particle 3-momentum at the endpoint in [GeV]
  void setMomentumAtEndpoint(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the endpoint in [GeV]
  edm4hep::Vector3f& momentumAtEndpoint();

  /// Set the spin (helicity) vector of the particle.
  void setSpin(edm4hep::Vector3f value);
  /// Get reference to spin (helicity) vector of the particle.
  edm4hep::Vector3f& spin();

  /// Set the color flow as defined by the generator
  void setColorFlow(edm4hep::Vector2i value);
  /// Get reference to color flow as defined by the generator
  edm4hep::Vector2i& colorFlow();



  void addToParents(edm4hep::MCParticle);
  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  void addToDaughters(edm4hep::MCParticle);
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               
 void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  		     
 void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  			     
 void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } 
 void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  		     
 void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  		     
 void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  			     
 void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  				     
 void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCParticle& a, MutableMCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleOBJ_H
#define EDM4HEP_MCParticleOBJ_H

// data model specific includes
#include "edm4hep/MCParticleData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class MCParticle;

class MCParticleObj : public podio::ObjBase {
public:
  /// constructor
  MCParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCParticleObj(const MCParticleObj&);
  /// constructor from ObjectID and MCParticleData
  /// does not initialize the internal relation containers
  MCParticleObj(const podio::ObjectID id, MCParticleData data);
  /// No assignment operator
  MCParticleObj& operator=(const MCParticleObj&) = delete;
  virtual ~MCParticleObj();

public:
  MCParticleData data;
  std::vector<edm4hep::MCParticle>* m_parents{nullptr};
  std::vector<edm4hep::MCParticle>* m_daughters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_CollectionData_H
#define EDM4HEP_MCParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticleObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCParticleObjPointerContainer = std::deque<MCParticleObj*>;
using MCParticleDataContainer = std::vector<MCParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCParticleCollectionData(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData& operator=(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData(MCParticleCollectionData&& other) = default;
  MCParticleCollectionData& operator=(MCParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(MCParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_parents;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_parents_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::MCParticle> m_rel_daughters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_daughters_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitDATA_H
#define EDM4HEP_SimTrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimTrackerHitData
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float EDep{}; ///< energy deposited in the hit [GeV].
  float time{}; ///< proper time of the hit in the lab frame in [ns].
  float pathLength{}; ///< path length of the particle in the sensitive material that resulted in this hit.
  std::int32_t quality{}; ///< quality bit flag.
  ::edm4hep::Vector3d position{}; ///< the hit position in [mm].
  ::edm4hep::Vector3f momentum{}; ///< the 3-momentum of the particle at the hits position in [GeV]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_H
#define EDM4HEP_SimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimTrackerHit;
class SimTrackerHitCollection;

/** @class SimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHit {

  friend class MutableSimTrackerHit;
  friend class SimTrackerHitCollection;
  friend class SimTrackerHitCollectionIterator;

public:
  using mutable_type = MutableSimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  SimTrackerHit();
  SimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  SimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  SimTrackerHit(const SimTrackerHit& other);

  /// copy-assignment operator
  SimTrackerHit& operator=(SimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~SimTrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimTrackerHit& a, SimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimTrackerHit_H
#define EDM4HEP_MutableSimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimTrackerHit.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableSimTrackerHit {

  friend class SimTrackerHitCollection;
  friend class SimTrackerHitMutableCollectionIterator;
  friend class SimTrackerHit;

public:
  using object_type = SimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  MutableSimTrackerHit();
  MutableSimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  MutableSimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  MutableSimTrackerHit(const MutableSimTrackerHit& other);

  /// copy-assignment operator
  MutableSimTrackerHit& operator=(MutableSimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~MutableSimTrackerHit();

  /// conversion to const object
  operator SimTrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy deposited in the hit [GeV].
  void setEDep(float value);

  /// Set the proper time of the hit in the lab frame in [ns].
  void setTime(float value);

  /// Set the path length of the particle in the sensitive material that resulted in this hit.
  void setPathLength(float value);

  /// Set the quality bit flag.
  void setQuality(std::int32_t value);

  /// Set the the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the the 3-momentum of the particle at the hits position in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to the 3-momentum of the particle at the hits position in [GeV]
  edm4hep::Vector3f& momentum();


  /// Set the MCParticle that caused the hit.
  void setMCParticle(edm4hep::MCParticle value);


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }
 void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }
 void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimTrackerHit& a, MutableSimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitOBJ_H
#define EDM4HEP_SimTrackerHitOBJ_H

// data model specific includes
#include "edm4hep/SimTrackerHitData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimTrackerHit;

class SimTrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  SimTrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimTrackerHitObj(const SimTrackerHitObj&);
  /// constructor from ObjectID and SimTrackerHitData
  /// does not initialize the internal relation containers
  SimTrackerHitObj(const podio::ObjectID id, SimTrackerHitData data);
  /// No assignment operator
  SimTrackerHitObj& operator=(const SimTrackerHitObj&) = delete;
  virtual ~SimTrackerHitObj();

public:
  SimTrackerHitData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_CollectionData_H
#define EDM4HEP_SimTrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimTrackerHitObjPointerContainer = std::deque<SimTrackerHitObj*>;
using SimTrackerHitDataContainer = std::vector<SimTrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimTrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimTrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimTrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimTrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimTrackerHitCollectionData(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData& operator=(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData(SimTrackerHitCollectionData&& other) = default;
  SimTrackerHitCollectionData& operator=(SimTrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimTrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimTrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionDATA_H
#define EDM4HEP_CaloHitContributionDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CaloHitContributionData
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContributionData {
public:
  std::int32_t PDG{}; ///< PDG code of the shower particle that caused this contribution.
  float energy{}; ///< energy in [GeV] of the this contribution
  float time{}; ///< time in [ns] of this contribution
  ::edm4hep::Vector3f stepPosition{}; ///< position of this energy deposition (step) [mm]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_H
#define EDM4HEP_CaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableCaloHitContribution;
class CaloHitContributionCollection;

/** @class CaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContribution {

  friend class MutableCaloHitContribution;
  friend class CaloHitContributionCollection;
  friend class CaloHitContributionCollectionIterator;

public:
  using mutable_type = MutableCaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  CaloHitContribution();
  CaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  CaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  CaloHitContribution(const CaloHitContribution& other);

  /// copy-assignment operator
  CaloHitContribution& operator=(CaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~CaloHitContribution();


public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CaloHitContribution& a, CaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CaloHitContribution& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCaloHitContribution_H
#define EDM4HEP_MutableCaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CaloHitContribution.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableCaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class MutableCaloHitContribution {

  friend class CaloHitContributionCollection;
  friend class CaloHitContributionMutableCollectionIterator;
  friend class CaloHitContribution;

public:
  using object_type = CaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  MutableCaloHitContribution();
  MutableCaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  MutableCaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  MutableCaloHitContribution(const MutableCaloHitContribution& other);

  /// copy-assignment operator
  MutableCaloHitContribution& operator=(MutableCaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~MutableCaloHitContribution();

  /// conversion to const object
  operator CaloHitContribution() const;

public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;

  /// Set the PDG code of the shower particle that caused this contribution.
  void setPDG(std::int32_t value);

  /// Set the energy in [GeV] of the this contribution
  void setEnergy(float value);

  /// Set the time in [ns] of this contribution
  void setTime(float value);

  /// Set the position of this energy deposition (step) [mm]
  void setStepPosition(edm4hep::Vector3f value);
  /// Get reference to position of this energy deposition (step) [mm]
  edm4hep::Vector3f& stepPosition();


  /// Set the primary MCParticle that caused the shower responsible for this contribution to the hit.
  void setParticle(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const CaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCaloHitContribution& a, MutableCaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionOBJ_H
#define EDM4HEP_CaloHitContributionOBJ_H

// data model specific includes
#include "edm4hep/CaloHitContributionData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class CaloHitContribution;

class CaloHitContributionObj : public podio::ObjBase {
public:
  /// constructor
  CaloHitContributionObj();
  /// copy constructor (does a deep-copy of relation containers)
  CaloHitContributionObj(const CaloHitContributionObj&);
  /// constructor from ObjectID and CaloHitContributionData
  /// does not initialize the internal relation containers
  CaloHitContributionObj(const podio::ObjectID id, CaloHitContributionData data);
  /// No assignment operator
  CaloHitContributionObj& operator=(const CaloHitContributionObj&) = delete;
  virtual ~CaloHitContributionObj();

public:
  CaloHitContributionData data;
  edm4hep::MCParticle* m_particle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_CollectionData_H
#define EDM4HEP_CaloHitContribution_CollectionData_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CaloHitContributionObjPointerContainer = std::deque<CaloHitContributionObj*>;
using CaloHitContributionDataContainer = std::vector<CaloHitContributionData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CaloHitContributionCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CaloHitContributionObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CaloHitContributionCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CaloHitContributionCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CaloHitContributionCollectionData(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData& operator=(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData(CaloHitContributionCollectionData&& other) = default;
  CaloHitContributionCollectionData& operator=(CaloHitContributionCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CaloHitContributionCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_particle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CaloHitContributionDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitDATA_H
#define EDM4HEP_SimCalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimCalorimeterHitData
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float energy{}; ///< energy of the hit in [GeV].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].

  unsigned int contributions_begin{};
  unsigned int contributions_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_H
#define EDM4HEP_SimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableSimCalorimeterHit;
class SimCalorimeterHitCollection;

/** @class SimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHit {

  friend class MutableSimCalorimeterHit;
  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableSimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  SimCalorimeterHit();
  SimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  SimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  SimCalorimeterHit(const SimCalorimeterHit& other);

  /// copy-assignment operator
  SimCalorimeterHit& operator=(SimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~SimCalorimeterHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimCalorimeterHit& a, SimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimCalorimeterHit_H
#define EDM4HEP_MutableSimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimCalorimeterHit.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableSimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableSimCalorimeterHit {

  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitMutableCollectionIterator;
  friend class SimCalorimeterHit;

public:
  using object_type = SimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  MutableSimCalorimeterHit();
  MutableSimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  MutableSimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  MutableSimCalorimeterHit(const MutableSimCalorimeterHit& other);

  /// copy-assignment operator
  MutableSimCalorimeterHit& operator=(MutableSimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~MutableSimCalorimeterHit();

  /// conversion to const object
  operator SimCalorimeterHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();



  void addToContributions(edm4hep::CaloHitContribution);
  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimCalorimeterHit& a, MutableSimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitOBJ_H
#define EDM4HEP_SimCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/CaloHitContribution.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class SimCalorimeterHit;

class SimCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  SimCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimCalorimeterHitObj(const SimCalorimeterHitObj&);
  /// constructor from ObjectID and SimCalorimeterHitData
  /// does not initialize the internal relation containers
  SimCalorimeterHitObj(const podio::ObjectID id, SimCalorimeterHitData data);
  /// No assignment operator
  SimCalorimeterHitObj& operator=(const SimCalorimeterHitObj&) = delete;
  virtual ~SimCalorimeterHitObj();

public:
  SimCalorimeterHitData data;
  std::vector<edm4hep::CaloHitContribution>* m_contributions{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_CollectionData_H
#define EDM4HEP_SimCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/CaloHitContribution.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimCalorimeterHitObjPointerContainer = std::deque<SimCalorimeterHitObj*>;
using SimCalorimeterHitDataContainer = std::vector<SimCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimCalorimeterHitCollectionData(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData& operator=(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData(SimCalorimeterHitCollectionData&& other) = default;
  SimCalorimeterHitCollectionData& operator=(SimCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimCalorimeterHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CaloHitContribution> m_rel_contributions;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CaloHitContribution>> m_rel_contributions_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitDATA_H
#define EDM4HEP_RawCalorimeterHitDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawCalorimeterHitData
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  std::int32_t amplitude{}; ///< amplitude of the hit in ADC counts.
  std::int32_t timeStamp{}; ///< time stamp for the hit.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_H
#define EDM4HEP_RawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawCalorimeterHit;
class RawCalorimeterHitCollection;

/** @class RawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHit {

  friend class MutableRawCalorimeterHit;
  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableRawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  RawCalorimeterHit();
  RawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  RawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  RawCalorimeterHit(const RawCalorimeterHit& other);

  /// copy-assignment operator
  RawCalorimeterHit& operator=(RawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~RawCalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawCalorimeterHit& a, RawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawCalorimeterHit_H
#define EDM4HEP_MutableRawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawCalorimeterHit.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableRawCalorimeterHit {

  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitMutableCollectionIterator;
  friend class RawCalorimeterHit;

public:
  using object_type = RawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  MutableRawCalorimeterHit();
  MutableRawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  MutableRawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  MutableRawCalorimeterHit(const MutableRawCalorimeterHit& other);

  /// copy-assignment operator
  MutableRawCalorimeterHit& operator=(MutableRawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~MutableRawCalorimeterHit();

  /// conversion to const object
  operator RawCalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the amplitude of the hit in ADC counts.
  void setAmplitude(std::int32_t value);

  /// Set the time stamp for the hit.
  void setTimeStamp(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawCalorimeterHit& a, MutableRawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitOBJ_H
#define EDM4HEP_RawCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/RawCalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class RawCalorimeterHit;

class RawCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  RawCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawCalorimeterHitObj(const RawCalorimeterHitObj&);
  /// constructor from ObjectID and RawCalorimeterHitData
  /// does not initialize the internal relation containers
  RawCalorimeterHitObj(const podio::ObjectID id, RawCalorimeterHitData data);
  /// No assignment operator
  RawCalorimeterHitObj& operator=(const RawCalorimeterHitObj&) = delete;
  virtual ~RawCalorimeterHitObj() = default;

public:
  RawCalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_CollectionData_H
#define EDM4HEP_RawCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawCalorimeterHitObjPointerContainer = std::deque<RawCalorimeterHitObj*>;
using RawCalorimeterHitDataContainer = std::vector<RawCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawCalorimeterHitCollectionData(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData& operator=(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData(RawCalorimeterHitCollectionData&& other) = default;
  RawCalorimeterHitCollectionData& operator=(RawCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitDATA_H
#define EDM4HEP_CalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CalorimeterHitData
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  float energy{}; ///< energy of the hit in [GeV].
  float energyError{}; ///< error of the hit energy in [GeV].
  float time{}; ///< time of the hit in [ns].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].
  std::int32_t type{}; ///< type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_H
#define EDM4HEP_CalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCalorimeterHit;
class CalorimeterHitCollection;

/** @class CalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHit {

  friend class MutableCalorimeterHit;
  friend class CalorimeterHitCollection;
  friend class CalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableCalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  CalorimeterHit();
  CalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  CalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  CalorimeterHit(const CalorimeterHit& other);

  /// copy-assignment operator
  CalorimeterHit& operator=(CalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~CalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CalorimeterHit& a, CalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCalorimeterHit_H
#define EDM4HEP_MutableCalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CalorimeterHit.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableCalorimeterHit {

  friend class CalorimeterHitCollection;
  friend class CalorimeterHitMutableCollectionIterator;
  friend class CalorimeterHit;

public:
  using object_type = CalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  MutableCalorimeterHit();
  MutableCalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  MutableCalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  MutableCalorimeterHit(const MutableCalorimeterHit& other);

  /// copy-assignment operator
  MutableCalorimeterHit& operator=(MutableCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~MutableCalorimeterHit();

  /// conversion to const object
  operator CalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the error of the hit energy in [GeV].
  void setEnergyError(float value);

  /// Set the time of the hit in [ns].
  void setTime(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();

  /// Set the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  void setType(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const CalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCalorimeterHit& a, MutableCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitOBJ_H
#define EDM4HEP_CalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/CalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class CalorimeterHit;

class CalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  CalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  CalorimeterHitObj(const CalorimeterHitObj&);
  /// constructor from ObjectID and CalorimeterHitData
  /// does not initialize the internal relation containers
  CalorimeterHitObj(const podio::ObjectID id, CalorimeterHitData data);
  /// No assignment operator
  CalorimeterHitObj& operator=(const CalorimeterHitObj&) = delete;
  virtual ~CalorimeterHitObj() = default;

public:
  CalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_CollectionData_H
#define EDM4HEP_CalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CalorimeterHitObjPointerContainer = std::deque<CalorimeterHitObj*>;
using CalorimeterHitDataContainer = std::vector<CalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CalorimeterHitCollectionData(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData& operator=(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData(CalorimeterHitCollectionData&& other) = default;
  CalorimeterHitCollectionData& operator=(CalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDDATA_H
#define EDM4HEP_ParticleIDDATA_H

#include <cstdint>

namespace edm4hep {


/** @class ParticleIDData
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleIDData {
public:
  std::int32_t type{}; ///< userdefined type
  std::int32_t PDG{}; ///< PDG code of this id - ( 999999 ) if unknown.
  std::int32_t algorithmType{}; ///< type of the algorithm/module that created this hypothesis
  float likelihood{}; ///< likelihood of this hypothesis - in a user defined normalization.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_H
#define EDM4HEP_ParticleID_H

#include "edm4hep/ParticleIDObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableParticleID;
class ParticleIDCollection;

/** @class ParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleID {

  friend class MutableParticleID;
  friend class ParticleIDCollection;
  friend class ParticleIDCollectionIterator;

public:
  using mutable_type = MutableParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  ParticleID();
  ParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  ParticleID(ParticleIDObj* obj);

  /// copy constructor
  ParticleID(const ParticleID& other);

  /// copy-assignment operator
  ParticleID& operator=(ParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~ParticleID();


public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ParticleID& a, ParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ParticleID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableParticleID_H
#define EDM4HEP_MutableParticleID_H

#include "edm4hep/ParticleIDObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ParticleID.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class MutableParticleID {

  friend class ParticleIDCollection;
  friend class ParticleIDMutableCollectionIterator;
  friend class ParticleID;

public:
  using object_type = ParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  MutableParticleID();
  MutableParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  MutableParticleID(ParticleIDObj* obj);

  /// copy constructor
  MutableParticleID(const MutableParticleID& other);

  /// copy-assignment operator
  MutableParticleID& operator=(MutableParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~MutableParticleID();

  /// conversion to const object
  operator ParticleID() const;

public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  /// Set the userdefined type
  void setType(std::int32_t value);

  /// Set the PDG code of this id - ( 999999 ) if unknown.
  void setPDG(std::int32_t value);

  /// Set the type of the algorithm/module that created this hypothesis
  void setAlgorithmType(std::int32_t value);

  /// Set the likelihood of this hypothesis - in a user defined normalization.
  void setLikelihood(float value);



  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const ParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableParticleID& a, MutableParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDOBJ_H
#define EDM4HEP_ParticleIDOBJ_H

// data model specific includes
#include "edm4hep/ParticleIDData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class ParticleID;

class ParticleIDObj : public podio::ObjBase {
public:
  /// constructor
  ParticleIDObj();
  /// copy constructor (does a deep-copy of relation containers)
  ParticleIDObj(const ParticleIDObj&);
  /// constructor from ObjectID and ParticleIDData
  /// does not initialize the internal relation containers
  ParticleIDObj(const podio::ObjectID id, ParticleIDData data);
  /// No assignment operator
  ParticleIDObj& operator=(const ParticleIDObj&) = delete;
  virtual ~ParticleIDObj();

public:
  ParticleIDData data;
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_CollectionData_H
#define EDM4HEP_ParticleID_CollectionData_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleIDObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ParticleIDObjPointerContainer = std::deque<ParticleIDObj*>;
using ParticleIDDataContainer = std::vector<ParticleIDData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ParticleIDCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ParticleIDObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ParticleIDCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ParticleIDCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ParticleIDCollectionData(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData& operator=(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData(ParticleIDCollectionData&& other) = default;
  ParticleIDCollectionData& operator=(ParticleIDCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ParticleIDCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ParticleIDObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ParticleIDDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterDATA_H
#define EDM4HEP_ClusterDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ClusterData
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class ClusterData {
public:
  std::int32_t type{}; ///< flagword that defines the type of cluster. Bits 16-31 are used internally.
  float energy{}; ///< energy of the cluster [GeV]
  float energyError{}; ///< error on the energy
  ::edm4hep::Vector3f position{}; ///< position of the cluster [mm]
  std::array<float, 6> positionError{}; ///< covariance matrix of the position (6 Parameters)
  float iTheta{}; ///< intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  float phi{}; ///< intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  ::edm4hep::Vector3f directionError{}; ///< covariance matrix of the direction (3 Parameters) [mm^2]

  unsigned int shapeParameters_begin{};
  unsigned int shapeParameters_end{};
  unsigned int subdetectorEnergies_begin{};
  unsigned int subdetectorEnergies_end{};
  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int hits_begin{};
  unsigned int hits_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_H
#define EDM4HEP_Cluster_H

#include "edm4hep/ClusterObj.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCluster;
class ClusterCollection;

/** @class Cluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class Cluster {

  friend class MutableCluster;
  friend class ClusterCollection;
  friend class ClusterCollectionIterator;

public:
  using mutable_type = MutableCluster;
  using collection_type = ClusterCollection;

  /// default constructor
  Cluster();
  Cluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  Cluster(ClusterObj* obj);

  /// copy constructor
  Cluster(const Cluster& other);

  /// copy-assignment operator
  Cluster& operator=(Cluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~Cluster();


public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Cluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Cluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Cluster& a, Cluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Cluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Cluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCluster_H
#define EDM4HEP_MutableCluster_H

#include "edm4hep/ClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Cluster.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class MutableCluster {

  friend class ClusterCollection;
  friend class ClusterMutableCollectionIterator;
  friend class Cluster;

public:
  using object_type = Cluster;
  using collection_type = ClusterCollection;

  /// default constructor
  MutableCluster();
  MutableCluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  MutableCluster(ClusterObj* obj);

  /// copy constructor
  MutableCluster(const MutableCluster& other);

  /// copy-assignment operator
  MutableCluster& operator=(MutableCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~MutableCluster();

  /// conversion to const object
  operator Cluster() const;

public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  /// Set the flagword that defines the type of cluster. Bits 16-31 are used internally.
  void setType(std::int32_t value);

  /// Set the energy of the cluster [GeV]
  void setEnergy(float value);

  /// Set the error on the energy
  void setEnergyError(float value);

  /// Set the position of the cluster [mm]
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the cluster [mm]
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (6 Parameters)
  void setPositionError(std::array<float, 6> value);
  void setPositionError(size_t i, float value);
  /// Get reference to covariance matrix of the position (6 Parameters)
  std::array<float, 6>& positionError();

  /// Set the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  void setITheta(float value);

  /// Set the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  void setPhi(float value);

  /// Set the covariance matrix of the direction (3 Parameters) [mm^2]
  void setDirectionError(edm4hep::Vector3f value);
  /// Get reference to covariance matrix of the direction (3 Parameters) [mm^2]
  edm4hep::Vector3f& directionError();



  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToHits(edm4hep::CalorimeterHit);
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  void addToShapeParameters(float);
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  void addToSubdetectorEnergies(float);
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const Cluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCluster& a, MutableCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterOBJ_H
#define EDM4HEP_ClusterOBJ_H

// data model specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Cluster;

class ClusterObj : public podio::ObjBase {
public:
  /// constructor
  ClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  ClusterObj(const ClusterObj&);
  /// constructor from ObjectID and ClusterData
  /// does not initialize the internal relation containers
  ClusterObj(const podio::ObjectID id, ClusterData data);
  /// No assignment operator
  ClusterObj& operator=(const ClusterObj&) = delete;
  virtual ~ClusterObj();

public:
  ClusterData data;
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::CalorimeterHit>* m_hits{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
  std::vector<float>* m_shapeParameters{nullptr};
  std::vector<float>* m_subdetectorEnergies{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_CollectionData_H
#define EDM4HEP_Cluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ClusterObjPointerContainer = std::deque<ClusterObj*>;
using ClusterDataContainer = std::vector<ClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ClusterCollectionData(const ClusterCollectionData&) = delete;
  ClusterCollectionData& operator=(const ClusterCollectionData&) = delete;
  ClusterCollectionData(ClusterCollectionData&& other) = default;
  ClusterCollectionData& operator=(ClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_hits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CalorimeterHit>> m_rel_hits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<float> m_vec_shapeParameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_shapeParameters{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_subdetectorEnergies{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_subdetectorEnergies{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitDATA_H
#define EDM4HEP_TrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitData
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_H
#define EDM4HEP_TrackerHit_H

#include "edm4hep/TrackerHitObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHit;
class TrackerHitCollection;

/** @class TrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHit {

  friend class MutableTrackerHit;
  friend class TrackerHitCollection;
  friend class TrackerHitCollectionIterator;

public:
  using mutable_type = MutableTrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  TrackerHit();
  TrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  TrackerHit(TrackerHitObj* obj);

  /// copy constructor
  TrackerHit(const TrackerHit& other);

  /// copy-assignment operator
  TrackerHit& operator=(TrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~TrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHit& a, TrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHit_H
#define EDM4HEP_MutableTrackerHit_H

#include "edm4hep/TrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHit.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableTrackerHit {

  friend class TrackerHitCollection;
  friend class TrackerHitMutableCollectionIterator;
  friend class TrackerHit;

public:
  using object_type = TrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  MutableTrackerHit();
  MutableTrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  MutableTrackerHit(TrackerHitObj* obj);

  /// copy constructor
  MutableTrackerHit(const MutableTrackerHit& other);

  /// copy-assignment operator
  MutableTrackerHit& operator=(MutableTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~MutableTrackerHit();

  /// conversion to const object
  operator TrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHit& a, MutableTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitOBJ_H
#define EDM4HEP_TrackerHitOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHit;

class TrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitObj(const TrackerHitObj&);
  /// constructor from ObjectID and TrackerHitData
  /// does not initialize the internal relation containers
  TrackerHitObj(const podio::ObjectID id, TrackerHitData data);
  /// No assignment operator
  TrackerHitObj& operator=(const TrackerHitObj&) = delete;
  virtual ~TrackerHitObj();

public:
  TrackerHitData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_CollectionData_H
#define EDM4HEP_TrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitObjPointerContainer = std::deque<TrackerHitObj*>;
using TrackerHitDataContainer = std::vector<TrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitCollectionData(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData& operator=(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData(TrackerHitCollectionData&& other) = default;
  TrackerHitCollectionData& operator=(TrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneDATA_H
#define EDM4HEP_TrackerHitPlaneDATA_H

#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitPlaneData
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlaneData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector2f u{}; ///< measurement direction vector, u lies in the x-y plane
  ::edm4hep::Vector2f v{}; ///< measurement direction vector, v is along z
  float du{}; ///< measurement error along the direction
  float dv{}; ///< measurement error along the direction
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_H
#define EDM4HEP_TrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHitPlane;
class TrackerHitPlaneCollection;

/** @class TrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlane {

  friend class MutableTrackerHitPlane;
  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneCollectionIterator;

public:
  using mutable_type = MutableTrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  TrackerHitPlane();
  TrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  TrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  TrackerHitPlane(const TrackerHitPlane& other);

  /// copy-assignment operator
  TrackerHitPlane& operator=(TrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~TrackerHitPlane();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHitPlane& a, TrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlane& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHitPlane_H
#define EDM4HEP_MutableTrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHitPlane.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class MutableTrackerHitPlane {

  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneMutableCollectionIterator;
  friend class TrackerHitPlane;

public:
  using object_type = TrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  MutableTrackerHitPlane();
  MutableTrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  MutableTrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  MutableTrackerHitPlane(const MutableTrackerHitPlane& other);

  /// copy-assignment operator
  MutableTrackerHitPlane& operator=(MutableTrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~MutableTrackerHitPlane();

  /// conversion to const object
  operator TrackerHitPlane() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the measurement direction vector, u lies in the x-y plane
  void setU(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, u lies in the x-y plane
  edm4hep::Vector2f& u();

  /// Set the measurement direction vector, v is along z
  void setV(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, v is along z
  edm4hep::Vector2f& v();

  /// Set the measurement error along the direction
  void setDu(float value);

  /// Set the measurement error along the direction
  void setDv(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHitPlane& a, MutableTrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneOBJ_H
#define EDM4HEP_TrackerHitPlaneOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHitPlane;

class TrackerHitPlaneObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitPlaneObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitPlaneObj(const TrackerHitPlaneObj&);
  /// constructor from ObjectID and TrackerHitPlaneData
  /// does not initialize the internal relation containers
  TrackerHitPlaneObj(const podio::ObjectID id, TrackerHitPlaneData data);
  /// No assignment operator
  TrackerHitPlaneObj& operator=(const TrackerHitPlaneObj&) = delete;
  virtual ~TrackerHitPlaneObj();

public:
  TrackerHitPlaneData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_CollectionData_H
#define EDM4HEP_TrackerHitPlane_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlaneObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitPlaneObjPointerContainer = std::deque<TrackerHitPlaneObj*>;
using TrackerHitPlaneDataContainer = std::vector<TrackerHitPlaneData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitPlaneCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitPlaneObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitPlaneCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitPlaneCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitPlaneCollectionData(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData& operator=(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData(TrackerHitPlaneCollectionData&& other) = default;
  TrackerHitPlaneCollectionData& operator=(TrackerHitPlaneCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitPlaneCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitPlaneObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitPlaneDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesDATA_H
#define EDM4HEP_RawTimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawTimeSeriesData
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeriesData {
public:
  std::uint64_t cellID{}; ///< detector specific cell id.
  std::int32_t quality{}; ///< quality flag for the hit.
  float time{}; ///< time of the hit [ns].
  float charge{}; ///< integrated charge of the hit [fC].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int adcCounts_begin{};
  unsigned int adcCounts_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_H
#define EDM4HEP_RawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawTimeSeries;
class RawTimeSeriesCollection;

/** @class RawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeries {

  friend class MutableRawTimeSeries;
  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesCollectionIterator;

public:
  using mutable_type = MutableRawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  RawTimeSeries();
  RawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  RawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  RawTimeSeries(const RawTimeSeries& other);

  /// copy-assignment operator
  RawTimeSeries& operator=(RawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~RawTimeSeries();


public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawTimeSeries& a, RawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawTimeSeries_H
#define EDM4HEP_MutableRawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawTimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class MutableRawTimeSeries {

  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesMutableCollectionIterator;
  friend class RawTimeSeries;

public:
  using object_type = RawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  MutableRawTimeSeries();
  MutableRawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  MutableRawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  MutableRawTimeSeries(const MutableRawTimeSeries& other);

  /// copy-assignment operator
  MutableRawTimeSeries& operator=(MutableRawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~MutableRawTimeSeries();

  /// conversion to const object
  operator RawTimeSeries() const;

public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the detector specific cell id.
  void setCellID(std::uint64_t value);

  /// Set the quality flag for the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the integrated charge of the hit [fC].
  void setCharge(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAdcCounts(std::int32_t);
  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawTimeSeries& a, MutableRawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesOBJ_H
#define EDM4HEP_RawTimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RawTimeSeries;

class RawTimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  RawTimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawTimeSeriesObj(const RawTimeSeriesObj&);
  /// constructor from ObjectID and RawTimeSeriesData
  /// does not initialize the internal relation containers
  RawTimeSeriesObj(const podio::ObjectID id, RawTimeSeriesData data);
  /// No assignment operator
  RawTimeSeriesObj& operator=(const RawTimeSeriesObj&) = delete;
  virtual ~RawTimeSeriesObj();

public:
  RawTimeSeriesData data;
  std::vector<std::int32_t>* m_adcCounts{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_CollectionData_H
#define EDM4HEP_RawTimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawTimeSeriesObjPointerContainer = std::deque<RawTimeSeriesObj*>;
using RawTimeSeriesDataContainer = std::vector<RawTimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawTimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawTimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawTimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawTimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawTimeSeriesCollectionData(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData& operator=(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData(RawTimeSeriesCollectionData&& other) = default;
  RawTimeSeriesCollectionData& operator=(RawTimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawTimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RawTimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_adcCounts{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_adcCounts{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawTimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackDATA_H
#define EDM4HEP_TrackDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TrackData
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class TrackData {
public:
  std::int32_t type{}; ///< flagword that defines the type of track.Bits 16-31 are used internally
  float chi2{}; ///< Chi^2 of the track fit
  std::int32_t ndf{}; ///< number of degrees of freedom of the track fit
  float dEdx{}; ///< dEdx of the track.
  float dEdxError{}; ///< error of dEdx.
  float radiusOfInnermostHit{}; ///< radius of the innermost hit that has been used in the track fit

  unsigned int subdetectorHitNumbers_begin{};
  unsigned int subdetectorHitNumbers_end{};
  unsigned int trackStates_begin{};
  unsigned int trackStates_end{};
  unsigned int dxQuantities_begin{};
  unsigned int dxQuantities_end{};
  unsigned int trackerHits_begin{};
  unsigned int trackerHits_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_H
#define EDM4HEP_Track_H

#include "edm4hep/TrackObj.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrack;
class TrackCollection;

/** @class Track
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class Track {

  friend class MutableTrack;
  friend class TrackCollection;
  friend class TrackCollectionIterator;

public:
  using mutable_type = MutableTrack;
  using collection_type = TrackCollection;

  /// default constructor
  Track();
  Track(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  Track(TrackObj* obj);

  /// copy constructor
  Track(const Track& other);

  /// copy-assignment operator
  Track& operator=(Track other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~Track();


public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Track& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrack& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Track& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Track& a, Track& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Track& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Track& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrack_H
#define EDM4HEP_MutableTrack_H

#include "edm4hep/TrackObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Track.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrack
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class MutableTrack {

  friend class TrackCollection;
  friend class TrackMutableCollectionIterator;
  friend class Track;

public:
  using object_type = Track;
  using collection_type = TrackCollection;

  /// default constructor
  MutableTrack();
  MutableTrack(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  MutableTrack(TrackObj* obj);

  /// copy constructor
  MutableTrack(const MutableTrack& other);

  /// copy-assignment operator
  MutableTrack& operator=(MutableTrack other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~MutableTrack();

  /// conversion to const object
  operator Track() const;

public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  /// Set the flagword that defines the type of track.Bits 16-31 are used internally
  void setType(std::int32_t value);

  /// Set the Chi^2 of the track fit
  void setChi2(float value);

  /// Set the number of degrees of freedom of the track fit
  void setNdf(std::int32_t value);

  /// Set the dEdx of the track.
  void setDEdx(float value);

  /// Set the error of dEdx.
  void setDEdxError(float value);

  /// Set the radius of the innermost hit that has been used in the track fit
  void setRadiusOfInnermostHit(float value);



  void addToTrackerHits(edm4hep::TrackerHit);
  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToSubdetectorHitNumbers(std::int32_t);
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  void addToTrackStates(edm4hep::TrackState);
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  void addToDxQuantities(edm4hep::Quantity);
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrack& other) const { return m_obj == other.m_obj; }
  bool operator==(const Track& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrack& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrack& a, MutableTrack& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrack& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackOBJ_H
#define EDM4HEP_TrackOBJ_H

// data model specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Track;

class TrackObj : public podio::ObjBase {
public:
  /// constructor
  TrackObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackObj(const TrackObj&);
  /// constructor from ObjectID and TrackData
  /// does not initialize the internal relation containers
  TrackObj(const podio::ObjectID id, TrackData data);
  /// No assignment operator
  TrackObj& operator=(const TrackObj&) = delete;
  virtual ~TrackObj();

public:
  TrackData data;
  std::vector<edm4hep::TrackerHit>* m_trackerHits{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<std::int32_t>* m_subdetectorHitNumbers{nullptr};
  std::vector<edm4hep::TrackState>* m_trackStates{nullptr};
  std::vector<edm4hep::Quantity>* m_dxQuantities{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_CollectionData_H
#define EDM4HEP_Track_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackObjPointerContainer = std::deque<TrackObj*>;
using TrackDataContainer = std::vector<TrackData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackCollectionData(const TrackCollectionData&) = delete;
  TrackCollectionData& operator=(const TrackCollectionData&) = delete;
  TrackCollectionData(TrackCollectionData&& other) = default;
  TrackCollectionData& operator=(TrackCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_trackerHits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerHit>> m_rel_trackerHits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_subdetectorHitNumbers{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_subdetectorHitNumbers{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::TrackState> m_vec_trackStates{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::TrackState>> m_vecs_trackStates{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Quantity> m_vec_dxQuantities{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Quantity>> m_vecs_dxQuantities{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexDATA_H
#define EDM4HEP_VertexDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class VertexData
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class VertexData {
public:
  std::int32_t primary{}; ///< boolean flag, if vertex is the primary vertex of the event
  float chi2{}; ///< chi-squared of the vertex fit
  float probability{}; ///< probability of the vertex fit
  ::edm4hep::Vector3f position{}; ///< [mm] position of the vertex.
  std::array<float, 6> covMatrix{}; ///< covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::int32_t algorithmType{}; ///< type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_H
#define EDM4HEP_Vertex_H

#include "edm4hep/VertexObj.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {

class MutableVertex;
class VertexCollection;

/** @class Vertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class Vertex {

  friend class MutableVertex;
  friend class VertexCollection;
  friend class VertexCollectionIterator;

public:
  using mutable_type = MutableVertex;
  using collection_type = VertexCollection;

  /// default constructor
  Vertex();
  Vertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  Vertex(VertexObj* obj);

  /// copy constructor
  Vertex(const Vertex& other);

  /// copy-assignment operator
  Vertex& operator=(Vertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~Vertex();


public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Vertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableVertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Vertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Vertex& a, Vertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Vertex& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableVertex_H
#define EDM4HEP_MutableVertex_H

#include "edm4hep/VertexObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Vertex.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {


/** @class MutableVertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class MutableVertex {

  friend class VertexCollection;
  friend class VertexMutableCollectionIterator;
  friend class Vertex;

public:
  using object_type = Vertex;
  using collection_type = VertexCollection;

  /// default constructor
  MutableVertex();
  MutableVertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  MutableVertex(VertexObj* obj);

  /// copy constructor
  MutableVertex(const MutableVertex& other);

  /// copy-assignment operator
  MutableVertex& operator=(MutableVertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~MutableVertex();

  /// conversion to const object
  operator Vertex() const;

public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  /// Set the boolean flag, if vertex is the primary vertex of the event
  void setPrimary(std::int32_t value);

  /// Set the chi-squared of the vertex fit
  void setChi2(float value);

  /// Set the probability of the vertex fit
  void setProbability(float value);

  /// Set the [mm] position of the vertex.
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to [mm] position of the vertex.
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::array<float, 6>& covMatrix();

  /// Set the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  void setAlgorithmType(std::int32_t value);


  /// Set the reconstructed particle associated to this vertex.
  void setAssociatedParticle(edm4hep::ReconstructedParticle value);

  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableVertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const Vertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableVertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableVertex& a, MutableVertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableVertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexOBJ_H
#define EDM4HEP_VertexOBJ_H

// data model specific includes
#include "edm4hep/VertexData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class ReconstructedParticle;
}


namespace edm4hep {

class Vertex;

class VertexObj : public podio::ObjBase {
public:
  /// constructor
  VertexObj();
  /// copy constructor (does a deep-copy of relation containers)
  VertexObj(const VertexObj&);
  /// constructor from ObjectID and VertexData
  /// does not initialize the internal relation containers
  VertexObj(const podio::ObjectID id, VertexData data);
  /// No assignment operator
  VertexObj& operator=(const VertexObj&) = delete;
  virtual ~VertexObj();

public:
  VertexData data;
  edm4hep::ReconstructedParticle* m_associatedParticle{nullptr};
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_CollectionData_H
#define EDM4HEP_Vertex_CollectionData_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using VertexObjPointerContainer = std::deque<VertexObj*>;
using VertexDataContainer = std::vector<VertexData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class VertexCollectionData {
public:
  /**
   * The Objs of this collection
   */
  VertexObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  VertexCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  VertexCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  VertexCollectionData(const VertexCollectionData&) = delete;
  VertexCollectionData& operator=(const VertexCollectionData&) = delete;
  VertexCollectionData(VertexCollectionData&& other) = default;
  VertexCollectionData& operator=(VertexCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~VertexCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(VertexObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_associatedParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<VertexDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleDATA_H
#define EDM4HEP_ReconstructedParticleDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ReconstructedParticleData
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticleData {
public:
  std::int32_t type{}; ///< type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  float energy{}; ///< [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f momentum{}; ///< [GeV] particle momentum. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f referencePoint{}; ///< [mm] reference, i.e. where the particle has been measured
  float charge{}; ///< charge of the reconstructed particle.
  float mass{}; ///< [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  float goodnessOfPID{}; ///< overall goodness of the PID on a scale of [0;1]
  std::array<float, 10> covMatrix{}; ///< cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##

  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
  unsigned int particles_begin{};
  unsigned int particles_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_H
#define EDM4HEP_ReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {

class MutableReconstructedParticle;
class ReconstructedParticleCollection;

/** @class ReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticle {

  friend class MutableReconstructedParticle;
  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleCollectionIterator;

public:
  using mutable_type = MutableReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  ReconstructedParticle();
  ReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  ReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  ReconstructedParticle(const ReconstructedParticle& other);

  /// copy-assignment operator
  ReconstructedParticle& operator=(ReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~ReconstructedParticle();


public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ReconstructedParticle& a, ReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableReconstructedParticle_H
#define EDM4HEP_MutableReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ReconstructedParticle.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {


/** @class MutableReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class MutableReconstructedParticle {

  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleMutableCollectionIterator;
  friend class ReconstructedParticle;

public:
  using object_type = ReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  MutableReconstructedParticle();
  MutableReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  MutableReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  MutableReconstructedParticle(const MutableReconstructedParticle& other);

  /// copy-assignment operator
  MutableReconstructedParticle& operator=(MutableReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~MutableReconstructedParticle();

  /// conversion to const object
  operator ReconstructedParticle() const;

public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  /// Set the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  void setType(std::int32_t value);

  /// Set the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  void setEnergy(float value);

  /// Set the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to [GeV] particle momentum. Four momentum state is not kept consistent internally.
  edm4hep::Vector3f& momentum();

  /// Set the [mm] reference, i.e. where the particle has been measured
  void setReferencePoint(edm4hep::Vector3f value);
  /// Get reference to [mm] reference, i.e. where the particle has been measured
  edm4hep::Vector3f& referencePoint();

  /// Set the charge of the reconstructed particle.
  void setCharge(float value);

  /// Set the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  void setMass(float value);

  /// Set the overall goodness of the PID on a scale of [0;1]
  void setGoodnessOfPID(float value);

  /// Set the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  void setCovMatrix(std::array<float, 10> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  std::array<float, 10>& covMatrix();


  /// Set the start vertex associated to this particle
  void setStartVertex(edm4hep::Vertex value);
  /// Set the particle Id used for the kinematics of this particle
  void setParticleIDUsed(edm4hep::ParticleID value);

  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToParticles(edm4hep::ReconstructedParticle);
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

 //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.
 //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const ReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableReconstructedParticle& a, MutableReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleOBJ_H
#define EDM4HEP_ReconstructedParticleOBJ_H

// data model specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Vertex;
class ParticleID;
}


namespace edm4hep {

class ReconstructedParticle;

class ReconstructedParticleObj : public podio::ObjBase {
public:
  /// constructor
  ReconstructedParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  ReconstructedParticleObj(const ReconstructedParticleObj&);
  /// constructor from ObjectID and ReconstructedParticleData
  /// does not initialize the internal relation containers
  ReconstructedParticleObj(const podio::ObjectID id, ReconstructedParticleData data);
  /// No assignment operator
  ReconstructedParticleObj& operator=(const ReconstructedParticleObj&) = delete;
  virtual ~ReconstructedParticleObj();

public:
  ReconstructedParticleData data;
  edm4hep::Vertex* m_startVertex{nullptr};
  edm4hep::ParticleID* m_particleIDUsed{nullptr};
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<edm4hep::ReconstructedParticle>* m_particles{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_CollectionData_H
#define EDM4HEP_ReconstructedParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ReconstructedParticleObjPointerContainer = std::deque<ReconstructedParticleObj*>;
using ReconstructedParticleDataContainer = std::vector<ReconstructedParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ReconstructedParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ReconstructedParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ReconstructedParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ReconstructedParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ReconstructedParticleCollectionData(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData& operator=(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData(ReconstructedParticleCollectionData&& other) = default;
  ReconstructedParticleCollectionData& operator=(ReconstructedParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ReconstructedParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ReconstructedParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_particles;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ReconstructedParticle>> m_rel_particles_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Vertex> m_rel_startVertex{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDUsed{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ReconstructedParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationDATA_H
#define EDM4HEP_MCRecoParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoParticleAssociationData
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_H
#define EDM4HEP_MCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoParticleAssociation;
class MCRecoParticleAssociationCollection;

/** @class MCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociation {

  friend class MutableMCRecoParticleAssociation;
  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MCRecoParticleAssociation();
  MCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MCRecoParticleAssociation(const MCRecoParticleAssociation& other);

  /// copy-assignment operator
  MCRecoParticleAssociation& operator=(MCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MCRecoParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoParticleAssociation& a, MCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoParticleAssociation_H
#define EDM4HEP_MutableMCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoParticleAssociation {

  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationMutableCollectionIterator;
  friend class MCRecoParticleAssociation;

public:
  using object_type = MCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MutableMCRecoParticleAssociation();
  MutableMCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MutableMCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoParticleAssociation(const MutableMCRecoParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoParticleAssociation& operator=(MutableMCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoParticleAssociation();

  /// conversion to const object
  operator MCRecoParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoParticleAssociation& a, MutableMCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationOBJ_H
#define EDM4HEP_MCRecoParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MCParticle;
}


namespace edm4hep {

class MCRecoParticleAssociation;

class MCRecoParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoParticleAssociationObj(const MCRecoParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoParticleAssociationObj(const podio::ObjectID id, MCRecoParticleAssociationData data);
  /// No assignment operator
  MCRecoParticleAssociationObj& operator=(const MCRecoParticleAssociationObj&) = delete;
  virtual ~MCRecoParticleAssociationObj();

public:
  MCRecoParticleAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoParticleAssociationObjPointerContainer = std::deque<MCRecoParticleAssociationObj*>;
using MCRecoParticleAssociationDataContainer = std::vector<MCRecoParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoParticleAssociationCollectionData(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData& operator=(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData(MCRecoParticleAssociationCollectionData&& other) = default;
  MCRecoParticleAssociationCollectionData& operator=(MCRecoParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationDATA_H
#define EDM4HEP_MCRecoCaloAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloAssociationData
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_H
#define EDM4HEP_MCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {

class MutableMCRecoCaloAssociation;
class MCRecoCaloAssociationCollection;

/** @class MCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociation {

  friend class MutableMCRecoCaloAssociation;
  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MCRecoCaloAssociation();
  MCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MCRecoCaloAssociation(const MCRecoCaloAssociation& other);

  /// copy-assignment operator
  MCRecoCaloAssociation& operator=(MCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MCRecoCaloAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloAssociation& a, MCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloAssociation_H
#define EDM4HEP_MutableMCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {


/** @class MutableMCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoCaloAssociation {

  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationMutableCollectionIterator;
  friend class MCRecoCaloAssociation;

public:
  using object_type = MCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MutableMCRecoCaloAssociation();
  MutableMCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MutableMCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloAssociation(const MutableMCRecoCaloAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloAssociation& operator=(MutableMCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloAssociation();

  /// conversion to const object
  operator MCRecoCaloAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimCalorimeterHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloAssociation& a, MutableMCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationOBJ_H
#define EDM4HEP_MCRecoCaloAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class SimCalorimeterHit;
}


namespace edm4hep {

class MCRecoCaloAssociation;

class MCRecoCaloAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloAssociationObj(const MCRecoCaloAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloAssociationObj(const podio::ObjectID id, MCRecoCaloAssociationData data);
  /// No assignment operator
  MCRecoCaloAssociationObj& operator=(const MCRecoCaloAssociationObj&) = delete;
  virtual ~MCRecoCaloAssociationObj();

public:
  MCRecoCaloAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::SimCalorimeterHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/SimCalorimeterHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloAssociationObjPointerContainer = std::deque<MCRecoCaloAssociationObj*>;
using MCRecoCaloAssociationDataContainer = std::vector<MCRecoCaloAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloAssociationCollectionData(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData& operator=(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData(MCRecoCaloAssociationCollectionData&& other) = default;
  MCRecoCaloAssociationCollectionData& operator=(MCRecoCaloAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimCalorimeterHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationDATA_H
#define EDM4HEP_MCRecoTrackerAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerAssociationData
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_H
#define EDM4HEP_MCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerAssociation;
class MCRecoTrackerAssociationCollection;

/** @class MCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociation {

  friend class MutableMCRecoTrackerAssociation;
  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MCRecoTrackerAssociation();
  MCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerAssociation(const MCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerAssociation& operator=(MCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MCRecoTrackerAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerAssociation& a, MCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerAssociation_H
#define EDM4HEP_MutableMCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoTrackerAssociation {

  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationMutableCollectionIterator;
  friend class MCRecoTrackerAssociation;

public:
  using object_type = MCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerAssociation();
  MutableMCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MutableMCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerAssociation(const MutableMCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerAssociation& operator=(MutableMCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerAssociation();

  /// conversion to const object
  operator MCRecoTrackerAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerAssociation& a, MutableMCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHit;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerAssociation;

class MCRecoTrackerAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerAssociationObj(const MCRecoTrackerAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerAssociationObj(const podio::ObjectID id, MCRecoTrackerAssociationData data);
  /// No assignment operator
  MCRecoTrackerAssociationObj& operator=(const MCRecoTrackerAssociationObj&) = delete;
  virtual ~MCRecoTrackerAssociationObj();

public:
  MCRecoTrackerAssociationData data;
  edm4hep::TrackerHit* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerAssociationObjPointerContainer = std::deque<MCRecoTrackerAssociationObj*>;
using MCRecoTrackerAssociationDataContainer = std::vector<MCRecoTrackerAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerAssociationCollectionData(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData& operator=(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData(MCRecoTrackerAssociationCollectionData&& other) = default;
  MCRecoTrackerAssociationCollectionData& operator=(MCRecoTrackerAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerHitPlaneAssociationData
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerHitPlaneAssociation;
class MCRecoTrackerHitPlaneAssociationCollection;

/** @class MCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociation {

  friend class MutableMCRecoTrackerHitPlaneAssociation;
  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MCRecoTrackerHitPlaneAssociation();
  MCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerHitPlaneAssociation(const MCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerHitPlaneAssociation& operator=(MCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MCRecoTrackerHitPlaneAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerHitPlaneAssociation& a, MCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackerHitPlaneAssociation {

  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;
  friend class MCRecoTrackerHitPlaneAssociation;

public:
  using object_type = MCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerHitPlaneAssociation();
  MutableMCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MutableMCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerHitPlaneAssociation(const MutableMCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerHitPlaneAssociation& operator=(MutableMCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerHitPlaneAssociation();

  /// conversion to const object
  operator MCRecoTrackerHitPlaneAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHitPlane value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerHitPlaneAssociation& a, MutableMCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerHitPlaneAssociation;

class MCRecoTrackerHitPlaneAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerHitPlaneAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerHitPlaneAssociationObj(const MCRecoTrackerHitPlaneAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerHitPlaneAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerHitPlaneAssociationObj(const podio::ObjectID id, MCRecoTrackerHitPlaneAssociationData data);
  /// No assignment operator
  MCRecoTrackerHitPlaneAssociationObj& operator=(const MCRecoTrackerHitPlaneAssociationObj&) = delete;
  virtual ~MCRecoTrackerHitPlaneAssociationObj();

public:
  MCRecoTrackerHitPlaneAssociationData data;
  edm4hep::TrackerHitPlane* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHitPlane.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerHitPlaneAssociationObjPointerContainer = std::deque<MCRecoTrackerHitPlaneAssociationObj*>;
using MCRecoTrackerHitPlaneAssociationDataContainer = std::vector<MCRecoTrackerHitPlaneAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerHitPlaneAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerHitPlaneAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerHitPlaneAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHitPlane> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerHitPlaneAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationDATA_H
#define EDM4HEP_MCRecoCaloParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloParticleAssociationData
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_H
#define EDM4HEP_MCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoCaloParticleAssociation;
class MCRecoCaloParticleAssociationCollection;

/** @class MCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociation {

  friend class MutableMCRecoCaloParticleAssociation;
  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MCRecoCaloParticleAssociation();
  MCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MCRecoCaloParticleAssociation(const MCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MCRecoCaloParticleAssociation& operator=(MCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MCRecoCaloParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloParticleAssociation& a, MCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloParticleAssociation_H
#define EDM4HEP_MutableMCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoCaloParticleAssociation {

  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationMutableCollectionIterator;
  friend class MCRecoCaloParticleAssociation;

public:
  using object_type = MCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MutableMCRecoCaloParticleAssociation();
  MutableMCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MutableMCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloParticleAssociation(const MutableMCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloParticleAssociation& operator=(MutableMCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloParticleAssociation();

  /// conversion to const object
  operator MCRecoCaloParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloParticleAssociation& a, MutableMCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationOBJ_H
#define EDM4HEP_MCRecoCaloParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MCParticle;
}


namespace edm4hep {

class MCRecoCaloParticleAssociation;

class MCRecoCaloParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloParticleAssociationObj(const MCRecoCaloParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloParticleAssociationObj(const podio::ObjectID id, MCRecoCaloParticleAssociationData data);
  /// No assignment operator
  MCRecoCaloParticleAssociationObj& operator=(const MCRecoCaloParticleAssociationObj&) = delete;
  virtual ~MCRecoCaloParticleAssociationObj();

public:
  MCRecoCaloParticleAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloParticleAssociationObjPointerContainer = std::deque<MCRecoCaloParticleAssociationObj*>;
using MCRecoCaloParticleAssociationDataContainer = std::vector<MCRecoCaloParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloParticleAssociationCollectionData(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData& operator=(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData(MCRecoCaloParticleAssociationCollectionData&& other) = default;
  MCRecoCaloParticleAssociationCollectionData& operator=(MCRecoCaloParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationDATA_H
#define EDM4HEP_MCRecoClusterParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoClusterParticleAssociationData
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_H
#define EDM4HEP_MCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoClusterParticleAssociation;
class MCRecoClusterParticleAssociationCollection;

/** @class MCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociation {

  friend class MutableMCRecoClusterParticleAssociation;
  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MCRecoClusterParticleAssociation();
  MCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MCRecoClusterParticleAssociation(const MCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MCRecoClusterParticleAssociation& operator=(MCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MCRecoClusterParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoClusterParticleAssociation& a, MCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoClusterParticleAssociation_H
#define EDM4HEP_MutableMCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoClusterParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoClusterParticleAssociation {

  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationMutableCollectionIterator;
  friend class MCRecoClusterParticleAssociation;

public:
  using object_type = MCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MutableMCRecoClusterParticleAssociation();
  MutableMCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MutableMCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoClusterParticleAssociation(const MutableMCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoClusterParticleAssociation& operator=(MutableMCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoClusterParticleAssociation();

  /// conversion to const object
  operator MCRecoClusterParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the cluster
  void setRec(edm4hep::Cluster value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoClusterParticleAssociation& a, MutableMCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationOBJ_H
#define EDM4HEP_MCRecoClusterParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Cluster;
class MCParticle;
}


namespace edm4hep {

class MCRecoClusterParticleAssociation;

class MCRecoClusterParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoClusterParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoClusterParticleAssociationObj(const MCRecoClusterParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoClusterParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoClusterParticleAssociationObj(const podio::ObjectID id, MCRecoClusterParticleAssociationData data);
  /// No assignment operator
  MCRecoClusterParticleAssociationObj& operator=(const MCRecoClusterParticleAssociationObj&) = delete;
  virtual ~MCRecoClusterParticleAssociationObj();

public:
  MCRecoClusterParticleAssociationData data;
  edm4hep::Cluster* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoClusterParticleAssociationObjPointerContainer = std::deque<MCRecoClusterParticleAssociationObj*>;
using MCRecoClusterParticleAssociationDataContainer = std::vector<MCRecoClusterParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoClusterParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoClusterParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoClusterParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoClusterParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoClusterParticleAssociationCollectionData(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData& operator=(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData(MCRecoClusterParticleAssociationCollectionData&& other) = default;
  MCRecoClusterParticleAssociationCollectionData& operator=(MCRecoClusterParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoClusterParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoClusterParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationDATA_H
#define EDM4HEP_MCRecoTrackParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackParticleAssociationData
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_H
#define EDM4HEP_MCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoTrackParticleAssociation;
class MCRecoTrackParticleAssociationCollection;

/** @class MCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociation {

  friend class MutableMCRecoTrackParticleAssociation;
  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MCRecoTrackParticleAssociation();
  MCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MCRecoTrackParticleAssociation(const MCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MCRecoTrackParticleAssociation& operator=(MCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MCRecoTrackParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackParticleAssociation& a, MCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackParticleAssociation_H
#define EDM4HEP_MutableMCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackParticleAssociation {

  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationMutableCollectionIterator;
  friend class MCRecoTrackParticleAssociation;

public:
  using object_type = MCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MutableMCRecoTrackParticleAssociation();
  MutableMCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MutableMCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackParticleAssociation(const MutableMCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackParticleAssociation& operator=(MutableMCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackParticleAssociation();

  /// conversion to const object
  operator MCRecoTrackParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the track
  void setRec(edm4hep::Track value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackParticleAssociation& a, MutableMCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationOBJ_H
#define EDM4HEP_MCRecoTrackParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Track;
class MCParticle;
}


namespace edm4hep {

class MCRecoTrackParticleAssociation;

class MCRecoTrackParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackParticleAssociationObj(const MCRecoTrackParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackParticleAssociationObj(const podio::ObjectID id, MCRecoTrackParticleAssociationData data);
  /// No assignment operator
  MCRecoTrackParticleAssociationObj& operator=(const MCRecoTrackParticleAssociationObj&) = delete;
  virtual ~MCRecoTrackParticleAssociationObj();

public:
  MCRecoTrackParticleAssociationData data;
  edm4hep::Track* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackParticleAssociationObjPointerContainer = std::deque<MCRecoTrackParticleAssociationObj*>;
using MCRecoTrackParticleAssociationDataContainer = std::vector<MCRecoTrackParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackParticleAssociationCollectionData(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData& operator=(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData(MCRecoTrackParticleAssociationCollectionData&& other) = default;
  MCRecoTrackParticleAssociationCollectionData& operator=(MCRecoTrackParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationDATA_H
#define EDM4HEP_RecoParticleVertexAssociationDATA_H


namespace edm4hep {


/** @class RecoParticleVertexAssociationData
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_H
#define EDM4HEP_RecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {

class MutableRecoParticleVertexAssociation;
class RecoParticleVertexAssociationCollection;

/** @class RecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociation {

  friend class MutableRecoParticleVertexAssociation;
  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationCollectionIterator;

public:
  using mutable_type = MutableRecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  RecoParticleVertexAssociation();
  RecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  RecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  RecoParticleVertexAssociation(const RecoParticleVertexAssociation& other);

  /// copy-assignment operator
  RecoParticleVertexAssociation& operator=(RecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~RecoParticleVertexAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecoParticleVertexAssociation& a, RecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecoParticleVertexAssociation_H
#define EDM4HEP_MutableRecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecoParticleVertexAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {


/** @class MutableRecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class MutableRecoParticleVertexAssociation {

  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationMutableCollectionIterator;
  friend class RecoParticleVertexAssociation;

public:
  using object_type = RecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  MutableRecoParticleVertexAssociation();
  MutableRecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  MutableRecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  MutableRecoParticleVertexAssociation(const MutableRecoParticleVertexAssociation& other);

  /// copy-assignment operator
  MutableRecoParticleVertexAssociation& operator=(MutableRecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~MutableRecoParticleVertexAssociation();

  /// conversion to const object
  operator RecoParticleVertexAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the vertex
  void setVertex(edm4hep::Vertex value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecoParticleVertexAssociation& a, MutableRecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationOBJ_H
#define EDM4HEP_RecoParticleVertexAssociationOBJ_H

// data model specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class Vertex;
}


namespace edm4hep {

class RecoParticleVertexAssociation;

class RecoParticleVertexAssociationObj : public podio::ObjBase {
public:
  /// constructor
  RecoParticleVertexAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecoParticleVertexAssociationObj(const RecoParticleVertexAssociationObj&);
  /// constructor from ObjectID and RecoParticleVertexAssociationData
  /// does not initialize the internal relation containers
  RecoParticleVertexAssociationObj(const podio::ObjectID id, RecoParticleVertexAssociationData data);
  /// No assignment operator
  RecoParticleVertexAssociationObj& operator=(const RecoParticleVertexAssociationObj&) = delete;
  virtual ~RecoParticleVertexAssociationObj();

public:
  RecoParticleVertexAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::Vertex* m_vertex{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_CollectionData_H
#define EDM4HEP_RecoParticleVertexAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecoParticleVertexAssociationObjPointerContainer = std::deque<RecoParticleVertexAssociationObj*>;
using RecoParticleVertexAssociationDataContainer = std::vector<RecoParticleVertexAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecoParticleVertexAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecoParticleVertexAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecoParticleVertexAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecoParticleVertexAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecoParticleVertexAssociationCollectionData(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData& operator=(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData(RecoParticleVertexAssociationCollectionData&& other) = default;
  RecoParticleVertexAssociationCollectionData& operator=(RecoParticleVertexAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecoParticleVertexAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::Vertex> m_rel_vertex{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecoParticleVertexAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterDATA_H
#define EDM4HEP_SimPrimaryIonizationClusterDATA_H

#include "edm4hep/Vector3d.h"
#include <cstdint>

namespace edm4hep {


/** @class SimPrimaryIonizationClusterData
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< the primary ionization's time in the lab frame [ns].
  ::edm4hep::Vector3d position{}; ///< the primary ionization's position [mm].
  std::int16_t type{}; ///< type.

  unsigned int electronCellID_begin{};
  unsigned int electronCellID_end{};
  unsigned int electronTime_begin{};
  unsigned int electronTime_end{};
  unsigned int electronPosition_begin{};
  unsigned int electronPosition_end{};
  unsigned int pulseTime_begin{};
  unsigned int pulseTime_end{};
  unsigned int pulseAmplitude_begin{};
  unsigned int pulseAmplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_H
#define EDM4HEP_SimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimPrimaryIonizationCluster;
class SimPrimaryIonizationClusterCollection;

/** @class SimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationCluster {

  friend class MutableSimPrimaryIonizationCluster;
  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableSimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  SimPrimaryIonizationCluster();
  SimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  SimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  SimPrimaryIonizationCluster(const SimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  SimPrimaryIonizationCluster& operator=(SimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~SimPrimaryIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimPrimaryIonizationCluster& a, SimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimPrimaryIonizationCluster_H
#define EDM4HEP_MutableSimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimPrimaryIonizationCluster.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class MutableSimPrimaryIonizationCluster {

  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterMutableCollectionIterator;
  friend class SimPrimaryIonizationCluster;

public:
  using object_type = SimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  MutableSimPrimaryIonizationCluster();
  MutableSimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  MutableSimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  MutableSimPrimaryIonizationCluster(const MutableSimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  MutableSimPrimaryIonizationCluster& operator=(MutableSimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~MutableSimPrimaryIonizationCluster();

  /// conversion to const object
  operator SimPrimaryIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the the primary ionization's time in the lab frame [ns].
  void setTime(float value);

  /// Set the the primary ionization's position [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the primary ionization's position [mm].
  edm4hep::Vector3d& position();

  /// Set the type.
  void setType(std::int16_t value);


  /// Set the the particle that caused the ionizing collisions.
  void setMCParticle(edm4hep::MCParticle value);

  void addToElectronCellID(std::uint64_t);
  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  void addToElectronTime(float);
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  void addToElectronPosition(edm4hep::Vector3d);
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  void addToPulseTime(float);
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  void addToPulseAmplitude(float);
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimPrimaryIonizationCluster& a, MutableSimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterOBJ_H
#define EDM4HEP_SimPrimaryIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/Vector3d.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimPrimaryIonizationCluster;

class SimPrimaryIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  SimPrimaryIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimPrimaryIonizationClusterObj(const SimPrimaryIonizationClusterObj&);
  /// constructor from ObjectID and SimPrimaryIonizationClusterData
  /// does not initialize the internal relation containers
  SimPrimaryIonizationClusterObj(const podio::ObjectID id, SimPrimaryIonizationClusterData data);
  /// No assignment operator
  SimPrimaryIonizationClusterObj& operator=(const SimPrimaryIonizationClusterObj&) = delete;
  virtual ~SimPrimaryIonizationClusterObj();

public:
  SimPrimaryIonizationClusterData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
  std::vector<std::uint64_t>* m_electronCellID{nullptr};
  std::vector<float>* m_electronTime{nullptr};
  std::vector<edm4hep::Vector3d>* m_electronPosition{nullptr};
  std::vector<float>* m_pulseTime{nullptr};
  std::vector<float>* m_pulseAmplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H
#define EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimPrimaryIonizationClusterObjPointerContainer = std::deque<SimPrimaryIonizationClusterObj*>;
using SimPrimaryIonizationClusterDataContainer = std::vector<SimPrimaryIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimPrimaryIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimPrimaryIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimPrimaryIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimPrimaryIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimPrimaryIonizationClusterCollectionData(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData& operator=(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData(SimPrimaryIonizationClusterCollectionData&& other) = default;
  SimPrimaryIonizationClusterCollectionData& operator=(SimPrimaryIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimPrimaryIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimPrimaryIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<std::uint64_t> m_vec_electronCellID{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::uint64_t>> m_vecs_electronCellID{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_electronTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_electronTime{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Vector3d> m_vec_electronPosition{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Vector3d>> m_vecs_electronPosition{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseTime{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseAmplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseAmplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimPrimaryIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseDATA_H
#define EDM4HEP_TrackerPulseDATA_H

#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerPulseData
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulseData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< time [ns].
  float charge{}; ///< charge [fC].
  std::int16_t quality{}; ///< quality.
  std::array<float, 3> covMatrix{}; ///< lower triangle covariance matrix of the charge(c) and time(t) measurements.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_H
#define EDM4HEP_TrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {

class MutableTrackerPulse;
class TrackerPulseCollection;

/** @class TrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulse {

  friend class MutableTrackerPulse;
  friend class TrackerPulseCollection;
  friend class TrackerPulseCollectionIterator;

public:
  using mutable_type = MutableTrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  TrackerPulse();
  TrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  TrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  TrackerPulse(const TrackerPulse& other);

  /// copy-assignment operator
  TrackerPulse& operator=(TrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~TrackerPulse();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerPulse& a, TrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerPulse& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerPulse_H
#define EDM4HEP_MutableTrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerPulse.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {


/** @class MutableTrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class MutableTrackerPulse {

  friend class TrackerPulseCollection;
  friend class TrackerPulseMutableCollectionIterator;
  friend class TrackerPulse;

public:
  using object_type = TrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  MutableTrackerPulse();
  MutableTrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  MutableTrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  MutableTrackerPulse(const MutableTrackerPulse& other);

  /// copy-assignment operator
  MutableTrackerPulse& operator=(MutableTrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~MutableTrackerPulse();

  /// conversion to const object
  operator TrackerPulse() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the time [ns].
  void setTime(float value);

  /// Set the charge [fC].
  void setCharge(float value);

  /// Set the quality.
  void setQuality(std::int16_t value);

  /// Set the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  void setCovMatrix(std::array<float, 3> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to lower triangle covariance matrix of the charge(c) and time(t) measurements.
  std::array<float, 3>& covMatrix();


  /// Set the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  void setTimeSeries(edm4hep::TimeSeries value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerPulse& a, MutableTrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseOBJ_H
#define EDM4HEP_TrackerPulseOBJ_H

// data model specific includes
#include "edm4hep/TrackerPulseData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TimeSeries;
}


namespace edm4hep {

class TrackerPulse;

class TrackerPulseObj : public podio::ObjBase {
public:
  /// constructor
  TrackerPulseObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerPulseObj(const TrackerPulseObj&);
  /// constructor from ObjectID and TrackerPulseData
  /// does not initialize the internal relation containers
  TrackerPulseObj(const podio::ObjectID id, TrackerPulseData data);
  /// No assignment operator
  TrackerPulseObj& operator=(const TrackerPulseObj&) = delete;
  virtual ~TrackerPulseObj();

public:
  TrackerPulseData data;
  edm4hep::TimeSeries* m_timeSeries{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_CollectionData_H
#define EDM4HEP_TrackerPulse_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TimeSeries.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerPulseObjPointerContainer = std::deque<TrackerPulseObj*>;
using TrackerPulseDataContainer = std::vector<TrackerPulseData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerPulseCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerPulseObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerPulseCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerPulseCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerPulseCollectionData(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData& operator=(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData(TrackerPulseCollectionData&& other) = default;
  TrackerPulseCollectionData& operator=(TrackerPulseCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerPulseCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TimeSeries> m_rel_timeSeries{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerPulseDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterDATA_H
#define EDM4HEP_RecIonizationClusterDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RecIonizationClusterData
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float significance{}; ///< significance.
  std::int16_t type{}; ///< type.

  unsigned int trackerPulse_begin{};
  unsigned int trackerPulse_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_H
#define EDM4HEP_RecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRecIonizationCluster;
class RecIonizationClusterCollection;

/** @class RecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationCluster {

  friend class MutableRecIonizationCluster;
  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableRecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  RecIonizationCluster();
  RecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  RecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  RecIonizationCluster(const RecIonizationCluster& other);

  /// copy-assignment operator
  RecIonizationCluster& operator=(RecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~RecIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecIonizationCluster& a, RecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecIonizationCluster_H
#define EDM4HEP_MutableRecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecIonizationCluster.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecIonizationCluster {

  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterMutableCollectionIterator;
  friend class RecIonizationCluster;

public:
  using object_type = RecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  MutableRecIonizationCluster();
  MutableRecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  MutableRecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  MutableRecIonizationCluster(const MutableRecIonizationCluster& other);

  /// copy-assignment operator
  MutableRecIonizationCluster& operator=(MutableRecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~MutableRecIonizationCluster();

  /// conversion to const object
  operator RecIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the significance.
  void setSignificance(float value);

  /// Set the type.
  void setType(std::int16_t value);



  void addToTrackerPulse(edm4hep::TrackerPulse);
  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecIonizationCluster& a, MutableRecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterOBJ_H
#define EDM4HEP_RecIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/TrackerPulse.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RecIonizationCluster;

class RecIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  RecIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecIonizationClusterObj(const RecIonizationClusterObj&);
  /// constructor from ObjectID and RecIonizationClusterData
  /// does not initialize the internal relation containers
  RecIonizationClusterObj(const podio::ObjectID id, RecIonizationClusterData data);
  /// No assignment operator
  RecIonizationClusterObj& operator=(const RecIonizationClusterObj&) = delete;
  virtual ~RecIonizationClusterObj();

public:
  RecIonizationClusterData data;
  std::vector<edm4hep::TrackerPulse>* m_trackerPulse{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_CollectionData_H
#define EDM4HEP_RecIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/TrackerPulse.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecIonizationClusterObjPointerContainer = std::deque<RecIonizationClusterObj*>;
using RecIonizationClusterDataContainer = std::vector<RecIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecIonizationClusterCollectionData(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData& operator=(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData(RecIonizationClusterCollectionData&& other) = default;
  RecIonizationClusterCollectionData& operator=(RecIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerPulse> m_rel_trackerPulse;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerPulse>> m_rel_trackerPulse_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesDATA_H
#define EDM4HEP_TimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TimeSeriesData
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeriesData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< begin time [ns].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int amplitude_begin{};
  unsigned int amplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_H
#define EDM4HEP_TimeSeries_H

#include "edm4hep/TimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTimeSeries;
class TimeSeriesCollection;

/** @class TimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeries {

  friend class MutableTimeSeries;
  friend class TimeSeriesCollection;
  friend class TimeSeriesCollectionIterator;

public:
  using mutable_type = MutableTimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  TimeSeries();
  TimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  TimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  TimeSeries(const TimeSeries& other);

  /// copy-assignment operator
  TimeSeries& operator=(TimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~TimeSeries();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TimeSeries& a, TimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTimeSeries_H
#define EDM4HEP_MutableTimeSeries_H

#include "edm4hep/TimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class MutableTimeSeries {

  friend class TimeSeriesCollection;
  friend class TimeSeriesMutableCollectionIterator;
  friend class TimeSeries;

public:
  using object_type = TimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  MutableTimeSeries();
  MutableTimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  MutableTimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  MutableTimeSeries(const MutableTimeSeries& other);

  /// copy-assignment operator
  MutableTimeSeries& operator=(MutableTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~MutableTimeSeries();

  /// conversion to const object
  operator TimeSeries() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the begin time [ns].
  void setTime(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAmplitude(float);
  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const TimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTimeSeries& a, MutableTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesOBJ_H
#define EDM4HEP_TimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/TimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TimeSeries;

class TimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  TimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  TimeSeriesObj(const TimeSeriesObj&);
  /// constructor from ObjectID and TimeSeriesData
  /// does not initialize the internal relation containers
  TimeSeriesObj(const podio::ObjectID id, TimeSeriesData data);
  /// No assignment operator
  TimeSeriesObj& operator=(const TimeSeriesObj&) = delete;
  virtual ~TimeSeriesObj();

public:
  TimeSeriesData data;
  std::vector<float>* m_amplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_CollectionData_H
#define EDM4HEP_TimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TimeSeriesObjPointerContainer = std::deque<TimeSeriesObj*>;
using TimeSeriesDataContainer = std::vector<TimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TimeSeriesCollectionData(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData& operator=(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData(TimeSeriesCollectionData&& other) = default;
  TimeSeriesCollectionData& operator=(TimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_amplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_amplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxDATA_H
#define EDM4HEP_RecDqdxDATA_H

#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class RecDqdxData
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdxData {
public:
  ::edm4hep::Quantity dQdx{}; ///< the reconstructed dEdx or dNdx and its error
  std::int16_t particleType{}; ///< particle type, e(0),mu(1),pi(2),K(3),p(4).
  std::int16_t type{}; ///< type.
  std::array<edm4hep::Hypothesis, 5> hypotheses{}; ///< 5 particle hypothesis

  unsigned int hitData_begin{};
  unsigned int hitData_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_H
#define EDM4HEP_RecDqdx_H

#include "edm4hep/RecDqdxObj.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {

class MutableRecDqdx;
class RecDqdxCollection;

/** @class RecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdx {

  friend class MutableRecDqdx;
  friend class RecDqdxCollection;
  friend class RecDqdxCollectionIterator;

public:
  using mutable_type = MutableRecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  RecDqdx();
  RecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  RecDqdx(RecDqdxObj* obj);

  /// copy constructor
  RecDqdx(const RecDqdx& other);

  /// copy-assignment operator
  RecDqdx& operator=(RecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~RecDqdx();


public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecDqdx& a, RecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecDqdx& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecDqdx_H
#define EDM4HEP_MutableRecDqdx_H

#include "edm4hep/RecDqdxObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecDqdx.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {


/** @class MutableRecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecDqdx {

  friend class RecDqdxCollection;
  friend class RecDqdxMutableCollectionIterator;
  friend class RecDqdx;

public:
  using object_type = RecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  MutableRecDqdx();
  MutableRecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  MutableRecDqdx(RecDqdxObj* obj);

  /// copy constructor
  MutableRecDqdx(const MutableRecDqdx& other);

  /// copy-assignment operator
  MutableRecDqdx& operator=(MutableRecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~MutableRecDqdx();

  /// conversion to const object
  operator RecDqdx() const;

public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  /// Set the the reconstructed dEdx or dNdx and its error
  void setDQdx(edm4hep::Quantity value);
  /// Get reference to the reconstructed dEdx or dNdx and its error
  edm4hep::Quantity& dQdx();

  /// Set the particle type, e(0),mu(1),pi(2),K(3),p(4).
  void setParticleType(std::int16_t value);

  /// Set the type.
  void setType(std::int16_t value);

  /// Set the 5 particle hypothesis
  void setHypotheses(std::array<edm4hep::Hypothesis, 5> value);
  void setHypotheses(size_t i, edm4hep::Hypothesis value);
  /// Get reference to 5 particle hypothesis
  std::array<edm4hep::Hypothesis, 5>& hypotheses();


  /// Set the the corresponding track.
  void setTrack(edm4hep::Track value);

  void addToHitData(edm4hep::HitLevelData);
  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecDqdx& a, MutableRecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxOBJ_H
#define EDM4HEP_RecDqdxOBJ_H

// data model specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/HitLevelData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Track;
}


namespace edm4hep {

class RecDqdx;

class RecDqdxObj : public podio::ObjBase {
public:
  /// constructor
  RecDqdxObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecDqdxObj(const RecDqdxObj&);
  /// constructor from ObjectID and RecDqdxData
  /// does not initialize the internal relation containers
  RecDqdxObj(const podio::ObjectID id, RecDqdxData data);
  /// No assignment operator
  RecDqdxObj& operator=(const RecDqdxObj&) = delete;
  virtual ~RecDqdxObj();

public:
  RecDqdxData data;
  edm4hep::Track* m_track{nullptr};
  std::vector<edm4hep::HitLevelData>* m_hitData{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_CollectionData_H
#define EDM4HEP_RecDqdx_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecDqdxObjPointerContainer = std::deque<RecDqdxObj*>;
using RecDqdxDataContainer = std::vector<RecDqdxData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecDqdxCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecDqdxObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecDqdxCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecDqdxCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecDqdxCollectionData(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData& operator=(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData(RecDqdxCollectionData&& other) = default;
  RecDqdxCollectionData& operator=(RecDqdxCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecDqdxCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecDqdxObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_track{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<edm4hep::HitLevelData> m_vec_hitData{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::HitLevelData>> m_vecs_hitData{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecDqdxDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#include "podio/DatamodelRegistry.h"
#include "podio/SchemaEvolution.h"

namespace edm4hep::meta {
/**
 * The complete definition of the datamodel at generation time in JSON format.
 */
static constexpr auto edm4hep__JSONDefinition = R"DATAMODELDEF({"options": {"getSyntax": true, "exposePODMembers": false, "includeSubfolder": "edm4hep/", "schema_version": 1}, "schema_version": 1, "components": {"edm4hep::Vector3f": {"Members": ["float x", "float y", "float z"], "ExtraCode": {"declaration": " constexpr Vector3f() : x(0),y(0),z(0) {}\n constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr float operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector3d": {"Members": ["double x", "double y", "double z"], "ExtraCode": {"declaration": " constexpr Vector3d() : x(0),y(0),z(0) {}\n constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr double operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector2i": {"Members": ["std::int32_t a", "std::int32_t b"], "ExtraCode": {"declaration": " constexpr Vector2i() : a(0),b(0) {}\n constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}\n constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }\n constexpr int operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::Vector2f": {"Members": ["float a", "float b"], "ExtraCode": {"declaration": " constexpr Vector2f() : a(0),b(0) {}\n constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}\n constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }\n constexpr float operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::TrackState": {"Members": ["std::int32_t location // for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation", "float D0 // transverse impact parameter", "float phi // azimuthal angle", "float omega // is the signed curvature of the track in [1/mm].", "float Z0 // longitudinal impact parameter", "float tanLambda // lambda is the dip angle of the track in r-z", "float time // time of the track at this trackstate", "edm4hep::Vector3f referencePoint // Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]", "std::array<float, 21> covMatrix // lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix."], "ExtraCode": {"declaration": " static const int AtOther = 0 ; // any location other than the ones defined below\n static const int AtIP = 1 ;\n static const int AtFirstHit = 2 ;\n static const int AtLastHit = 3 ;\n static const int AtCalorimeter = 4 ;\n static const int AtVertex = 5 ;\n static const int LastLocation = AtVertex  ;\n "}}, "edm4hep::ObjectID": {"Members": ["std::int32_t index", "std::int32_t collectionID"], "ExtraCode": {"includes": "#include <podio/ObjectID.h>\n", "declaration": " ObjectID() = default;\n ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}\n "}}, "edm4hep::Quantity": {"Members": ["std::int16_t type // flag identifying how to interpret the quantity", "float value // value of the quantity", "float error // error on the value of the quantity"]}, "edm4hep::Hypothesis": {"Members": ["float chi2 // chi2", "float expected // expected value", "float sigma // sigma value"]}, "edm4hep::HitLevelData": {"Members": ["std::uint64_t cellID // cell id", "std::uint32_t N // number of reconstructed ionization cluster.", "float eDep // reconstructed energy deposit [GeV].", "float pathLength // track path length [mm]."]}}, "datatypes": {"edm4hep::EventHeader": {"Description": "Event Header. Additional parameters are assumed to go into the metadata tree.", "Author": "F.Gaede", "Members": ["std::int32_t eventNumber // event number", "std::int32_t runNumber // run number", "std::uint64_t timeStamp // time stamp", "float weight // event weight"], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCParticle": {"Description": "The Monte Carlo particle - based on the lcio::MCParticle.", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the particle", "std::int32_t generatorStatus // status of the particle as defined by the generator", "std::int32_t simulatorStatus // status of the particle from the simulation program - use BIT constants below", "float charge // particle charge", "float time // creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.", "double mass // mass of the particle in [GeV]", "edm4hep::Vector3d vertex // production vertex of the particle in [mm].", "edm4hep::Vector3d endpoint // endpoint of the particle in [mm]", "edm4hep::Vector3f momentum // particle 3-momentum at the production vertex in [GeV]", "edm4hep::Vector3f momentumAtEndpoint // particle 3-momentum at the endpoint in [GeV]", "edm4hep::Vector3f spin // spin (helicity) vector of the particle.", "edm4hep::Vector2i colorFlow // color flow as defined by the generator"], "OneToManyRelations": ["edm4hep::MCParticle parents // The parents of this particle.", "edm4hep::MCParticle daughters // The daughters this particle."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               \n void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  \t\t     \n void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  \t\t\t     \n void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } \n void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  \t\t     \n void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  \t\t     \n void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  \t\t\t     \n void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  \t\t\t\t     \n void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         \n "}, "ExtraCode": {"declaration": " // define the bit positions for the simulation flag\n static const int BITEndpoint = 31;\n static const int BITCreatedInSimulation = 30;\n static const int BITBackscatter = 29 ;\n static const int BITVertexIsNotEndpointOfParent = 28 ;  \n static const int BITDecayedInTracker = 27 ; \n static const int BITDecayedInCalorimeter = 26 ;   \n static const int BITLeftDetector = 25 ;     \n static const int BITStopped = 24 ;    \n static const int BITOverlay = 23 ;    \n /// return energy computed from momentum and mass \n double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+\n getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} \n\n/// True if the particle has been created by the simulation program (rather than the generator).     \n bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    \n /// True if the particle is the result of a backscatter from a calorimeter shower. \n bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   \n /// True if the particle's vertex is not the endpoint of the  parent particle.     \n bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } \n /// True if the particle has interacted in a tracking region.                \n bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     \n /// True if the particle has interacted in a calorimeter region.             \n bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   \n /// True if the particle has left the world volume undecayed.                \n bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }\n /// True if the particle has been stopped by the simulation program.         \n bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     \n /// True if the particle has been overlayed by the simulation (or digitization)  program.\n bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     \n "}, "VectorMembers": [], "OneToOneRelations": []}, "edm4hep::SimTrackerHit": {"Description": "Simulated tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float EDep // energy deposited in the hit [GeV].", "float time // proper time of the hit in the lab frame in [ns].", "float pathLength // path length of the particle in the sensitive material that resulted in this hit.", "std::int32_t quality // quality bit flag.", "edm4hep::Vector3d position // the hit position in [mm].", "edm4hep::Vector3f momentum // the 3-momentum of the particle at the hits position in [GeV]"], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // MCParticle that caused the hit."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }\n void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }\n void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }\n "}, "ExtraCode": {"declaration": " static const int  BITOverlay = 31;\n static const int  BITProducedBySecondary = 30;\n bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }\n bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }\n double x() const {return getPosition()[0];}\n double y() const {return getPosition()[1];}\n double z() const {return getPosition()[2];}\n double rho() const {return sqrt(x()*x() + y()*y());}\n "}, "VectorMembers": [], "OneToManyRelations": []}, "edm4hep::CaloHitContribution": {"Description": "Monte Carlo contribution to SimCalorimeterHit", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the shower particle that caused this contribution.", "float energy // energy in [GeV] of the this contribution", "float time // time in [ns] of this contribution", "edm4hep::Vector3f stepPosition // position of this energy deposition (step) [mm]"], "OneToOneRelations": ["edm4hep::MCParticle particle // primary MCParticle that caused the shower responsible for this contribution to the hit."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimCalorimeterHit": {"Description": "Simulated calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float energy // energy of the hit in [GeV].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm]."], "OneToManyRelations": ["edm4hep::CaloHitContribution contributions // Monte Carlo step contribution - parallel to particle"], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawCalorimeterHit": {"Description": "Raw calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "std::int32_t amplitude // amplitude of the hit in ADC counts.", "std::int32_t timeStamp // time stamp for the hit."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::CalorimeterHit": {"Description": "Calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "float energy // energy of the hit in [GeV].", "float energyError // error of the hit energy in [GeV].", "float time // time of the hit in [ns].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm].", "std::int32_t type // type of hit. Mapping of integer types to names via collection parameters \"CalorimeterHitTypeNames\" and \"CalorimeterHitTypeValues\"."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ParticleID": {"Description": "ParticleID", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // userdefined type", "std::int32_t PDG // PDG code of this id - ( 999999 ) if unknown.", "std::int32_t algorithmType // type of the algorithm/module that created this hypothesis", "float likelihood // likelihood of this hypothesis - in a user defined normalization."], "VectorMembers": ["float parameters // parameters associated with this hypothesis. Check/set collection parameters ParameterNames_PIDAlgorithmTypeName for decoding the indices."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Cluster": {"Description": "Calorimeter Hit Cluster", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of cluster. Bits 16-31 are used internally.", "float energy // energy of the cluster [GeV]", "float energyError // error on the energy", "edm4hep::Vector3f position // position of the cluster [mm]", "std::array<float, 6> positionError // covariance matrix of the position (6 Parameters)", "float iTheta // intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.", "float phi // intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.", "edm4hep::Vector3f directionError // covariance matrix of the direction (3 Parameters) [mm^2]"], "VectorMembers": ["float shapeParameters // shape parameters - check/set collection parameter ClusterShapeParameters for size and names of parameters.", "float subdetectorEnergies // energy observed in a particular subdetector. Check/set collection parameter ClusterSubdetectorNames for decoding the indices of the array."], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been combined to this cluster.", "edm4hep::CalorimeterHit hits // hits that have been combined to this cluster.", "edm4hep::ParticleID particleIDs // particle IDs (sorted by their likelihood)"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHit": {"Description": "Tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHitPlane": {"Description": "Tracker hit plane", "Author": "Placido Fernandez Declara, CERN", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector2f u // measurement direction vector, u lies in the x-y plane", "edm4hep::Vector2f v // measurement direction vector, v is along z", "float du // measurement error along the direction", "float dv // measurement error along the direction", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawTimeSeries": {"Description": "Raw data of a detector readout", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific cell id.", "std::int32_t quality // quality flag for the hit.", "float time // time of the hit [ns].", "float charge // integrated charge of the hit [fC].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["std::int32_t adcCounts // raw data (32-bit) word at i."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Track": {"Description": "Reconstructed track", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of track.Bits 16-31 are used internally", "float chi2 // Chi^2 of the track fit", "std::int32_t ndf // number of degrees of freedom of the track fit", "float dEdx // dEdx of the track.", "float dEdxError // error of dEdx.", "float radiusOfInnermostHit // radius of the innermost hit that has been used in the track fit"], "VectorMembers": ["std::int32_t subdetectorHitNumbers // number of hits in particular subdetectors.Check/set collection variable TrackSubdetectorNames for decoding the indices", "edm4hep::TrackState trackStates // track states", "edm4hep::Quantity dxQuantities // different measurements of dx quantities"], "OneToManyRelations": ["edm4hep::TrackerHit trackerHits // hits that have been used to create this track", "edm4hep::Track tracks // tracks (segments) that have been combined to create this track"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Vertex": {"Description": "Vertex", "Author": "F.Gaede, DESY", "Members": ["std::int32_t primary // boolean flag, if vertex is the primary vertex of the event", "float chi2 // chi-squared of the vertex fit", "float probability // probability of the vertex fit", "edm4hep::Vector3f position // [mm] position of the vertex.", "std::array<float, 6> covMatrix // covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )", "std::int32_t algorithmType // type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType."], "VectorMembers": ["float parameters // additional parameters related to this vertex - check/set the collection parameter \"VertexParameterNames\" for the parameters meaning."], "OneToOneRelations": ["edm4hep::ReconstructedParticle associatedParticle // reconstructed particle associated to this vertex."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ReconstructedParticle": {"Description": "Reconstructed Particle", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.", "float energy // [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f momentum // [GeV] particle momentum. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f referencePoint // [mm] reference, i.e. where the particle has been measured", "float charge // charge of the reconstructed particle.", "float mass // [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.", "float goodnessOfPID // overall goodness of the PID on a scale of [0;1]", "std::array<float, 10> covMatrix // cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##"], "OneToOneRelations": ["edm4hep::Vertex startVertex // start vertex associated to this particle", "edm4hep::ParticleID particleIDUsed // particle Id used for the kinematics of this particle"], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been used for this particle.", "edm4hep::Track tracks // tracks that have been used for this particle.", "edm4hep::ReconstructedParticle particles // reconstructed particles that have been combined to this particle.", "edm4hep::ParticleID particleIDs // particle Ids (not sorted by their likelihood)"], "ExtraCode": {"declaration": " bool isCompound() const { return particles_size() > 0 ;}\n "}, "MutableExtraCode": {"declaration": " //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.\n //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }\n "}, "VectorMembers": []}, "edm4hep::MCRecoParticleAssociation": {"Description": "Used to keep track of the correspondence between MC and reconstructed particles", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloAssociation": {"Description": "Association between a CaloHit and the corresponding simulated CaloHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::SimCalorimeterHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerAssociation": {"Description": "Association between a TrackerHit and the corresponding simulated TrackerHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHit rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerHitPlaneAssociation": {"Description": "Association between a TrackerHitPlane and the corresponding simulated TrackerHit", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHitPlane rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloParticleAssociation": {"Description": "Association between a CalorimeterHit and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoClusterParticleAssociation": {"Description": "Association between a Cluster and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Cluster rec // reference to the cluster", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackParticleAssociation": {"Description": "Association between a Track and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Track rec // reference to the track", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecoParticleVertexAssociation": {"Description": "Association between a Reconstructed Particle and a Vertex", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::Vertex vertex // reference to the vertex"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimPrimaryIonizationCluster": {"Description": "Simulated Primary Ionization", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // the primary ionization's time in the lab frame [ns].", "edm4hep::Vector3d position // the primary ionization's position [mm].", "std::int16_t type // type."], "VectorMembers": ["std::uint64_t electronCellID // cell id.", "float electronTime // the time in the lab frame [ns].", "edm4hep::Vector3d electronPosition // the position in the lab frame [mm].", "float pulseTime // the pulse's time in the lab frame [ns].", "float pulseAmplitude // the pulse's amplitude [fC]."], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // the particle that caused the ionizing collisions."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerPulse": {"Description": "Reconstructed Tracker Pulse", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // time [ns].", "float charge // charge [fC].", "std::int16_t quality // quality.", "std::array<float, 3> covMatrix // lower triangle covariance matrix of the charge(c) and time(t) measurements."], "OneToOneRelations": ["edm4hep::TimeSeries timeSeries // Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecIonizationCluster": {"Description": "Reconstructed Ionization Cluster", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float significance // significance.", "std::int16_t type // type."], "OneToManyRelations": ["edm4hep::TrackerPulse trackerPulse // the TrackerPulse used to create the ionization cluster."], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TimeSeries": {"Description": "Calibrated Detector Data", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // begin time [ns].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["float amplitude // calibrated detector data."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecDqdx": {"Description": "dN/dx or dE/dx info of Track.", "Author": "Wenxing Fang, IHEP", "Members": ["edm4hep::Quantity dQdx // the reconstructed dEdx or dNdx and its error", "std::int16_t particleType // particle type, e(0),mu(1),pi(2),K(3),p(4).", "std::int16_t type // type.", "std::array<edm4hep::Hypothesis, 5> hypotheses // 5 particle hypothesis"], "VectorMembers": ["edm4hep::HitLevelData hitData // hit level data"], "OneToOneRelations": ["edm4hep::Track track // the corresponding track."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}}})DATAMODELDEF";


/**
 * The names of all relations and vector members for all datatypes
 */
inline podio::RelationNameMapping edm4hep__getRelationNames() {
  using namespace std::string_view_literals;
  return {
    {"edm4hep::EventHeader"sv,
      {  },
      {  },
    },
    {"edm4hep::MCParticle"sv,
      { "parents"sv, "daughters"sv },
      {  },
    },
    {"edm4hep::SimTrackerHit"sv,
      { "MCParticle"sv },
      {  },
    },
    {"edm4hep::CaloHitContribution"sv,
      { "particle"sv },
      {  },
    },
    {"edm4hep::SimCalorimeterHit"sv,
      { "contributions"sv },
      {  },
    },
    {"edm4hep::RawCalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::CalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::ParticleID"sv,
      {  },
      { "parameters"sv },
    },
    {"edm4hep::Cluster"sv,
      { "clusters"sv, "hits"sv, "particleIDs"sv },
      { "shapeParameters"sv, "subdetectorEnergies"sv },
    },
    {"edm4hep::TrackerHit"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::TrackerHitPlane"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::RawTimeSeries"sv,
      {  },
      { "adcCounts"sv },
    },
    {"edm4hep::Track"sv,
      { "trackerHits"sv, "tracks"sv },
      { "subdetectorHitNumbers"sv, "trackStates"sv, "dxQuantities"sv },
    },
    {"edm4hep::Vertex"sv,
      { "associatedParticle"sv },
      { "parameters"sv },
    },
    {"edm4hep::ReconstructedParticle"sv,
      { "clusters"sv, "tracks"sv, "particles"sv, "particleIDs"sv, "startVertex"sv, "particleIDUsed"sv },
      {  },
    },
    {"edm4hep::MCRecoParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerHitPlaneAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoClusterParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::RecoParticleVertexAssociation"sv,
      { "rec"sv, "vertex"sv },
      {  },
    },
    {"edm4hep::SimPrimaryIonizationCluster"sv,
      { "MCParticle"sv },
      { "electronCellID"sv, "electronTime"sv, "electronPosition"sv, "pulseTime"sv, "pulseAmplitude"sv },
    },
    {"edm4hep::TrackerPulse"sv,
      { "timeSeries"sv },
      {  },
    },
    {"edm4hep::RecIonizationCluster"sv,
      { "trackerPulse"sv },
      {  },
    },
    {"edm4hep::TimeSeries"sv,
      {  },
      { "amplitude"sv },
    },
    {"edm4hep::RecDqdx"sv,
      { "track"sv },
      { "hitData"sv },
    },
  };
}

/**
 * The schema version at generation time
 */
static constexpr podio::SchemaVersionT schemaVersion = 1;

/**
 * The helper class that takes care of registering the datamodel definition to
 * the DatamodelRegistry and to provide the index in that registry.
 *
 * Implemented as a singleton mainly to ensure only a single registration of
 * each datamodel, during the constructor
 */
class DatamodelRegistryIndex {
public:
  static size_t value() {
    static const auto relationNames = edm4hep__getRelationNames();
    static auto index = DatamodelRegistryIndex(podio::DatamodelRegistry::mutInstance().registerDatamodel("edm4hep", edm4hep__JSONDefinition, relationNames));
    return index.m_value;
  }
private:
  DatamodelRegistryIndex(size_t v) : m_value(v) {}
  size_t m_value{podio::DatamodelRegistry::NoDefinitionAvailable};
};


namespace static_registration {
  // The usual trick via an IIFE and a const variable that we assign to, to
  // ensure that we populate this before everything starts
  inline  bool ensureRegistration() {
    const static auto reg = []() {
      return edm4hep::meta::DatamodelRegistryIndex::value() != podio::DatamodelRegistry::NoDefinitionAvailable;
    }();
    return reg;
  }

  const auto registrationEnsured = ensureRegistration();
}

} // namespace edm4hep::meta

#undef  _BACKWARD_BACKWARD_WARNING_H

TInterpreter::A...  ERROR Error parsing payload code for class edm4hep::MCParticleData with content:

#line 1 "libedm4hepDict dictionary payload"

#ifndef PODIO_JSON_OUTPUT
  #define PODIO_JSON_OUTPUT 1
#endif
#ifndef JSON_USE_IMPLICIT_CONVERSIONS
  #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif
#ifndef JSON_DIAGNOSTICS
  #define JSON_DIAGNOSTICS 0
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3f_H
#define EDM4HEP_Vector3f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3f
 *  
 *  @author: 
 */
class Vector3f {
public:
  float x{};
  float y{};
  float z{};

 constexpr Vector3f() : x(0),y(0),z(0) {}
 constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr float operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector3d_H
#define EDM4HEP_Vector3d_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector3d
 *  
 *  @author: 
 */
class Vector3d {
public:
  double x{};
  double y{};
  double z{};

 constexpr Vector3d() : x(0),y(0),z(0) {}
 constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}
 constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}
 constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }
 constexpr double operator[](unsigned i) const { return *( &x + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector3d& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector3d& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2i_H
#define EDM4HEP_Vector2i_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2i
 *  
 *  @author: 
 */
class Vector2i {
public:
  std::int32_t a{};
  std::int32_t b{};

 constexpr Vector2i() : a(0),b(0) {}
 constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}
 constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }
 constexpr int operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2i& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2i& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vector2f_H
#define EDM4HEP_Vector2f_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Vector2f
 *  
 *  @author: 
 */
class Vector2f {
public:
  float a{};
  float b{};

 constexpr Vector2f() : a(0),b(0) {}
 constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}
 constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}
 constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }
 constexpr float operator[](unsigned i) const { return *( &a + i ) ; }
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::Vector2f& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vector2f& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackState_H
#define EDM4HEP_TrackState_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class TrackState
 *  
 *  @author: 
 */
class TrackState {
public:
  std::int32_t location{}; ///< for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
  float D0{}; ///< transverse impact parameter
  float phi{}; ///< azimuthal angle
  float omega{}; ///< is the signed curvature of the track in [1/mm].
  float Z0{}; ///< longitudinal impact parameter
  float tanLambda{}; ///< lambda is the dip angle of the track in r-z
  float time{}; ///< time of the track at this trackstate
  ::edm4hep::Vector3f referencePoint{}; ///< Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
  std::array<float, 21> covMatrix{}; ///< lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.

 static const int AtOther = 0 ; // any location other than the ones defined below
 static const int AtIP = 1 ;
 static const int AtFirstHit = 2 ;
 static const int AtLastHit = 3 ;
 static const int AtCalorimeter = 4 ;
 static const int AtVertex = 5 ;
 static const int LastLocation = AtVertex  ;
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::TrackState& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackState& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ObjectID_H
#define EDM4HEP_ObjectID_H

#include <podio/ObjectID.h>
#include <cstdint>
#include <podio/ObjectID.h>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class ObjectID
 *  
 *  @author: 
 */
class ObjectID {
public:
  std::int32_t index{};
  std::int32_t collectionID{};

 ObjectID() = default;
 ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}
 

};

std::ostream& operator<<(std::ostream& o, const edm4hep::ObjectID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ObjectID& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Quantity_H
#define EDM4HEP_Quantity_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Quantity
 *  
 *  @author: 
 */
class Quantity {
public:
  std::int16_t type{}; ///< flag identifying how to interpret the quantity
  float value{}; ///< value of the quantity
  float error{}; ///< error on the value of the quantity


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Quantity& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Quantity& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Hypothesis_H
#define EDM4HEP_Hypothesis_H

#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class Hypothesis
 *  
 *  @author: 
 */
class Hypothesis {
public:
  float chi2{}; ///< chi2
  float expected{}; ///< expected value
  float sigma{}; ///< sigma value


};

std::ostream& operator<<(std::ostream& o, const edm4hep::Hypothesis& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Hypothesis& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_HitLevelData_H
#define EDM4HEP_HitLevelData_H

#include <cstdint>
#include <ostream>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

namespace edm4hep {

/** @class HitLevelData
 *  
 *  @author: 
 */
class HitLevelData {
public:
  std::uint64_t cellID{}; ///< cell id
  std::uint32_t N{}; ///< number of reconstructed ionization cluster.
  float eDep{}; ///< reconstructed energy deposit [GeV].
  float pathLength{}; ///< track path length [mm].


};

std::ostream& operator<<(std::ostream& o, const edm4hep::HitLevelData& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const HitLevelData& value);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderDATA_H
#define EDM4HEP_EventHeaderDATA_H

#include <cstdint>

namespace edm4hep {


/** @class EventHeaderData
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeaderData {
public:
  std::int32_t eventNumber{}; ///< event number
  std::int32_t runNumber{}; ///< run number
  std::uint64_t timeStamp{}; ///< time stamp
  float weight{}; ///< event weight

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_H
#define EDM4HEP_EventHeader_H

#include "edm4hep/EventHeaderObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableEventHeader;
class EventHeaderCollection;

/** @class EventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class EventHeader {

  friend class MutableEventHeader;
  friend class EventHeaderCollection;
  friend class EventHeaderCollectionIterator;

public:
  using mutable_type = MutableEventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  EventHeader();
  EventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  EventHeader(EventHeaderObj* obj);

  /// copy constructor
  EventHeader(const EventHeader& other);

  /// copy-assignment operator
  EventHeader& operator=(EventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~EventHeader();


public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const EventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableEventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const EventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(EventHeader& a, EventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const EventHeader& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableEventHeader_H
#define EDM4HEP_MutableEventHeader_H

#include "edm4hep/EventHeaderObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/EventHeader.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableEventHeader
 *  Event Header. Additional parameters are assumed to go into the metadata tree.
 *  @author: F.Gaede
 */
class MutableEventHeader {

  friend class EventHeaderCollection;
  friend class EventHeaderMutableCollectionIterator;
  friend class EventHeader;

public:
  using object_type = EventHeader;
  using collection_type = EventHeaderCollection;

  /// default constructor
  MutableEventHeader();
  MutableEventHeader(std::int32_t eventNumber, std::int32_t runNumber, std::uint64_t timeStamp, float weight);

  /// constructor from existing EventHeaderObj
  MutableEventHeader(EventHeaderObj* obj);

  /// copy constructor
  MutableEventHeader(const MutableEventHeader& other);

  /// copy-assignment operator
  MutableEventHeader& operator=(MutableEventHeader other);

  /// create a mutable deep-copy of the object with identical relations
  MutableEventHeader clone() const;

  /// destructor
  ~MutableEventHeader();

  /// conversion to const object
  operator EventHeader() const;

public:

  /// Access the event number
  const std::int32_t& getEventNumber() const;

  /// Access the run number
  const std::int32_t& getRunNumber() const;

  /// Access the time stamp
  const std::uint64_t& getTimeStamp() const;

  /// Access the event weight
  const float& getWeight() const;



  /// Set the event number
  void setEventNumber(std::int32_t value);

  /// Set the run number
  void setRunNumber(std::int32_t value);

  /// Set the time stamp
  void setTimeStamp(std::uint64_t value);

  /// Set the event weight
  void setWeight(float value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from EventHeaderObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableEventHeader& other) const { return m_obj == other.m_obj; }
  bool operator==(const EventHeader& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableEventHeader& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableEventHeader& a, MutableEventHeader& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  EventHeaderObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableEventHeader& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderOBJ_H
#define EDM4HEP_EventHeaderOBJ_H

// data model specific includes
#include "edm4hep/EventHeaderData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class EventHeader;

class EventHeaderObj : public podio::ObjBase {
public:
  /// constructor
  EventHeaderObj();
  /// copy constructor (does a deep-copy of relation containers)
  EventHeaderObj(const EventHeaderObj&);
  /// constructor from ObjectID and EventHeaderData
  /// does not initialize the internal relation containers
  EventHeaderObj(const podio::ObjectID id, EventHeaderData data);
  /// No assignment operator
  EventHeaderObj& operator=(const EventHeaderObj&) = delete;
  virtual ~EventHeaderObj() = default;

public:
  EventHeaderData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeaderCollection_H
#define EDM4HEP_EventHeaderCollection_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeader.h"
#include "edm4hep/MutableEventHeader.h"
#include "edm4hep/EventHeaderObj.h"
#include "edm4hep/EventHeaderCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class EventHeaderCollectionIterator {
public:
  EventHeaderCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderCollectionIterator(const EventHeaderCollectionIterator&) = delete;
  EventHeaderCollectionIterator& operator=(const EventHeaderCollectionIterator&) = delete;

  bool operator!=(const EventHeaderCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  EventHeader operator*();
  EventHeader* operator->();
  EventHeaderCollectionIterator& operator++();

private:
  size_t m_index;
  EventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


class EventHeaderMutableCollectionIterator {
public:
  EventHeaderMutableCollectionIterator(size_t index, const EventHeaderObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  EventHeaderMutableCollectionIterator(const EventHeaderMutableCollectionIterator&) = delete;
  EventHeaderMutableCollectionIterator& operator=(const EventHeaderMutableCollectionIterator&) = delete;

  bool operator!=(const EventHeaderMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const EventHeaderMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableEventHeader operator*();
  MutableEventHeader* operator->();
  EventHeaderMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableEventHeader m_object;
  const EventHeaderObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class EventHeaderCollection : public podio::CollectionBase {
public:
  using value_type = EventHeader;
  using const_iterator = EventHeaderCollectionIterator;
  using iterator = EventHeaderMutableCollectionIterator;

  EventHeaderCollection();
  EventHeaderCollection(EventHeaderCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  EventHeaderCollection(const EventHeaderCollection& ) = delete;
  EventHeaderCollection& operator=(const EventHeaderCollection& ) = delete;
  EventHeaderCollection(EventHeaderCollection&&) = default;
  EventHeaderCollection& operator=(EventHeaderCollection&&) = default;

//  EventHeaderCollection(EventHeaderVector* data, uint32_t collectionID);
  ~EventHeaderCollection();

  constexpr static auto typeName = "edm4hep::EventHeaderCollection";
  constexpr static auto valueTypeName = "edm4hep::EventHeader";
  constexpr static auto dataTypeName = "edm4hep::EventHeaderData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  EventHeaderCollection* operator->() { return (EventHeaderCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableEventHeader create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableEventHeader create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  EventHeader operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableEventHeader operator[](std::size_t index);
  /// Returns the const object of given index
  EventHeader at(std::size_t index) const;
  /// Returns the object of given index
  MutableEventHeader at(std::size_t index);


  /// Append object to the collection
  void push_back(EventHeader object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (EventHeaderObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> eventNumber(const size_t nElem = 0) const;
  std::vector<std::int32_t> runNumber(const size_t nElem = 0) const;
  std::vector<std::uint64_t> timeStamp(const size_t nElem = 0) const;
  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class EventHeaderCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable EventHeaderCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const EventHeaderCollection& v);

template<typename... Args>
MutableEventHeader EventHeaderCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new EventHeaderObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableEventHeader(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const EventHeaderCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_EventHeader_CollectionData_H
#define EDM4HEP_EventHeader_CollectionData_H

// datamodel specific includes
#include "edm4hep/EventHeaderData.h"
#include "edm4hep/EventHeaderObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using EventHeaderObjPointerContainer = std::deque<EventHeaderObj*>;
using EventHeaderDataContainer = std::vector<EventHeaderData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class EventHeaderCollectionData {
public:
  /**
   * The Objs of this collection
   */
  EventHeaderObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  EventHeaderCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  EventHeaderCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  EventHeaderCollectionData(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData& operator=(const EventHeaderCollectionData&) = delete;
  EventHeaderCollectionData(EventHeaderCollectionData&& other) = default;
  EventHeaderCollectionData& operator=(EventHeaderCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~EventHeaderCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<EventHeaderDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleDATA_H
#define EDM4HEP_MCParticleDATA_H

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class MCParticleData
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticleData {
public:
  std::int32_t PDG{}; ///< PDG code of the particle
  std::int32_t generatorStatus{}; ///< status of the particle as defined by the generator
  std::int32_t simulatorStatus{}; ///< status of the particle from the simulation program - use BIT constants below
  float charge{}; ///< particle charge
  float time{}; ///< creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  double mass{}; ///< mass of the particle in [GeV]
  ::edm4hep::Vector3d vertex{}; ///< production vertex of the particle in [mm].
  ::edm4hep::Vector3d endpoint{}; ///< endpoint of the particle in [mm]
  ::edm4hep::Vector3f momentum{}; ///< particle 3-momentum at the production vertex in [GeV]
  ::edm4hep::Vector3f momentumAtEndpoint{}; ///< particle 3-momentum at the endpoint in [GeV]
  ::edm4hep::Vector3f spin{}; ///< spin (helicity) vector of the particle.
  ::edm4hep::Vector2i colorFlow{}; ///< color flow as defined by the generator

  unsigned int parents_begin{};
  unsigned int parents_end{};
  unsigned int daughters_begin{};
  unsigned int daughters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_H
#define EDM4HEP_MCParticle_H

#include "edm4hep/MCParticleObj.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableMCParticle;
class MCParticleCollection;

/** @class MCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MCParticle {

  friend class MutableMCParticle;
  friend class MCParticleCollection;
  friend class MCParticleCollectionIterator;

public:
  using mutable_type = MutableMCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MCParticle();
  MCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MCParticle(MCParticleObj* obj);

  /// copy constructor
  MCParticle(const MCParticle& other);

  /// copy-assignment operator
  MCParticle& operator=(MCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MCParticle();


public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCParticle& a, MCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCParticle_H
#define EDM4HEP_MutableMCParticle_H

#include "edm4hep/MCParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCParticle.h"

#include "edm4hep/Vector2i.h"
#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cmath>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableMCParticle
 *  The Monte Carlo particle - based on the lcio::MCParticle.
 *  @author: F.Gaede, DESY
 */
class MutableMCParticle {

  friend class MCParticleCollection;
  friend class MCParticleMutableCollectionIterator;
  friend class MCParticle;

public:
  using object_type = MCParticle;
  using collection_type = MCParticleCollection;

  /// default constructor
  MutableMCParticle();
  MutableMCParticle(std::int32_t PDG, std::int32_t generatorStatus, std::int32_t simulatorStatus, float charge, float time, double mass, edm4hep::Vector3d vertex, edm4hep::Vector3d endpoint, edm4hep::Vector3f momentum, edm4hep::Vector3f momentumAtEndpoint, edm4hep::Vector3f spin, edm4hep::Vector2i colorFlow);

  /// constructor from existing MCParticleObj
  MutableMCParticle(MCParticleObj* obj);

  /// copy constructor
  MutableMCParticle(const MutableMCParticle& other);

  /// copy-assignment operator
  MutableMCParticle& operator=(MutableMCParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCParticle clone() const;

  /// destructor
  ~MutableMCParticle();

  /// conversion to const object
  operator MCParticle() const;

public:

  /// Access the PDG code of the particle
  const std::int32_t& getPDG() const;

  /// Access the status of the particle as defined by the generator
  const std::int32_t& getGeneratorStatus() const;

  /// Access the status of the particle from the simulation program - use BIT constants below
  const std::int32_t& getSimulatorStatus() const;

  /// Access the particle charge
  const float& getCharge() const;

  /// Access the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  const float& getTime() const;

  /// Access the mass of the particle in [GeV]
  const double& getMass() const;

  /// Access the production vertex of the particle in [mm].
  const edm4hep::Vector3d& getVertex() const;

  /// Access the endpoint of the particle in [mm]
  const edm4hep::Vector3d& getEndpoint() const;

  /// Access the particle 3-momentum at the production vertex in [GeV]
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the particle 3-momentum at the endpoint in [GeV]
  const edm4hep::Vector3f& getMomentumAtEndpoint() const;

  /// Access the spin (helicity) vector of the particle.
  const edm4hep::Vector3f& getSpin() const;

  /// Access the color flow as defined by the generator
  const edm4hep::Vector2i& getColorFlow() const;



  /// Set the PDG code of the particle
  void setPDG(std::int32_t value);

  /// Set the status of the particle as defined by the generator
  void setGeneratorStatus(std::int32_t value);

  /// Set the status of the particle from the simulation program - use BIT constants below
  void setSimulatorStatus(std::int32_t value);

  /// Set the particle charge
  void setCharge(float value);

  /// Set the creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.
  void setTime(float value);

  /// Set the mass of the particle in [GeV]
  void setMass(double value);

  /// Set the production vertex of the particle in [mm].
  void setVertex(edm4hep::Vector3d value);
  /// Get reference to production vertex of the particle in [mm].
  edm4hep::Vector3d& vertex();

  /// Set the endpoint of the particle in [mm]
  void setEndpoint(edm4hep::Vector3d value);
  /// Get reference to endpoint of the particle in [mm]
  edm4hep::Vector3d& endpoint();

  /// Set the particle 3-momentum at the production vertex in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the production vertex in [GeV]
  edm4hep::Vector3f& momentum();

  /// Set the particle 3-momentum at the endpoint in [GeV]
  void setMomentumAtEndpoint(edm4hep::Vector3f value);
  /// Get reference to particle 3-momentum at the endpoint in [GeV]
  edm4hep::Vector3f& momentumAtEndpoint();

  /// Set the spin (helicity) vector of the particle.
  void setSpin(edm4hep::Vector3f value);
  /// Get reference to spin (helicity) vector of the particle.
  edm4hep::Vector3f& spin();

  /// Set the color flow as defined by the generator
  void setColorFlow(edm4hep::Vector2i value);
  /// Get reference to color flow as defined by the generator
  edm4hep::Vector2i& colorFlow();



  void addToParents(edm4hep::MCParticle);
  std::size_t parents_size() const;
  edm4hep::MCParticle getParents(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator parents_end() const;
  podio::RelationRange<edm4hep::MCParticle> getParents() const;
  void addToDaughters(edm4hep::MCParticle);
  std::size_t daughters_size() const;
  edm4hep::MCParticle getDaughters(std::size_t) const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_begin() const;
  std::vector<edm4hep::MCParticle>::const_iterator daughters_end() const;
  podio::RelationRange<edm4hep::MCParticle> getDaughters() const;

 // define the bit positions for the simulation flag
 static const int BITEndpoint = 31;
 static const int BITCreatedInSimulation = 30;
 static const int BITBackscatter = 29 ;
 static const int BITVertexIsNotEndpointOfParent = 28 ;  
 static const int BITDecayedInTracker = 27 ; 
 static const int BITDecayedInCalorimeter = 26 ;   
 static const int BITLeftDetector = 25 ;     
 static const int BITStopped = 24 ;    
 static const int BITOverlay = 23 ;    
 /// return energy computed from momentum and mass 
 double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+
 getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} 

/// True if the particle has been created by the simulation program (rather than the generator).     
 bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    
 /// True if the particle is the result of a backscatter from a calorimeter shower. 
 bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   
 /// True if the particle's vertex is not the endpoint of the  parent particle.     
 bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } 
 /// True if the particle has interacted in a tracking region.                
 bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     
 /// True if the particle has interacted in a calorimeter region.             
 bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   
 /// True if the particle has left the world volume undecayed.                
 bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }
 /// True if the particle has been stopped by the simulation program.         
 bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     
 /// True if the particle has been overlayed by the simulation (or digitization)  program.
 bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               
 void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  		     
 void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  			     
 void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } 
 void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  		     
 void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  		     
 void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  			     
 void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  				     
 void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCParticle& a, MutableMCParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleOBJ_H
#define EDM4HEP_MCParticleOBJ_H

// data model specific includes
#include "edm4hep/MCParticleData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class MCParticle;

class MCParticleObj : public podio::ObjBase {
public:
  /// constructor
  MCParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCParticleObj(const MCParticleObj&);
  /// constructor from ObjectID and MCParticleData
  /// does not initialize the internal relation containers
  MCParticleObj(const podio::ObjectID id, MCParticleData data);
  /// No assignment operator
  MCParticleObj& operator=(const MCParticleObj&) = delete;
  virtual ~MCParticleObj();

public:
  MCParticleData data;
  std::vector<edm4hep::MCParticle>* m_parents{nullptr};
  std::vector<edm4hep::MCParticle>* m_daughters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticleCollection_H
#define EDM4HEP_MCParticleCollection_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/MutableMCParticle.h"
#include "edm4hep/MCParticleObj.h"
#include "edm4hep/MCParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCParticleCollectionIterator {
public:
  MCParticleCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleCollectionIterator(const MCParticleCollectionIterator&) = delete;
  MCParticleCollectionIterator& operator=(const MCParticleCollectionIterator&) = delete;

  bool operator!=(const MCParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCParticle operator*();
  MCParticle* operator->();
  MCParticleCollectionIterator& operator++();

private:
  size_t m_index;
  MCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


class MCParticleMutableCollectionIterator {
public:
  MCParticleMutableCollectionIterator(size_t index, const MCParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCParticleMutableCollectionIterator(const MCParticleMutableCollectionIterator&) = delete;
  MCParticleMutableCollectionIterator& operator=(const MCParticleMutableCollectionIterator&) = delete;

  bool operator!=(const MCParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCParticle operator*();
  MutableMCParticle* operator->();
  MCParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCParticle m_object;
  const MCParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCParticleCollection : public podio::CollectionBase {
public:
  using value_type = MCParticle;
  using const_iterator = MCParticleCollectionIterator;
  using iterator = MCParticleMutableCollectionIterator;

  MCParticleCollection();
  MCParticleCollection(MCParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCParticleCollection(const MCParticleCollection& ) = delete;
  MCParticleCollection& operator=(const MCParticleCollection& ) = delete;
  MCParticleCollection(MCParticleCollection&&) = default;
  MCParticleCollection& operator=(MCParticleCollection&&) = default;

//  MCParticleCollection(MCParticleVector* data, uint32_t collectionID);
  ~MCParticleCollection();

  constexpr static auto typeName = "edm4hep::MCParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::MCParticle";
  constexpr static auto dataTypeName = "edm4hep::MCParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCParticleCollection* operator->() { return (MCParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCParticle operator[](std::size_t index);
  /// Returns the const object of given index
  MCParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(MCParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> generatorStatus(const size_t nElem = 0) const;
  std::vector<std::int32_t> simulatorStatus(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<double> mass(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> vertex(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> endpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentumAtEndpoint(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> spin(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2i> colorFlow(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCParticleCollection& v);

template<typename... Args>
MutableMCParticle MCParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, MCParticleData} constructor
  obj->m_parents = new std::vector<edm4hep::MCParticle>();
  obj->m_daughters = new std::vector<edm4hep::MCParticle>();
  m_storage.createRelations(obj);
  return MutableMCParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCParticle_CollectionData_H
#define EDM4HEP_MCParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCParticleData.h"
#include "edm4hep/MCParticleObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCParticleObjPointerContainer = std::deque<MCParticleObj*>;
using MCParticleDataContainer = std::vector<MCParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCParticleCollectionData(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData& operator=(const MCParticleCollectionData&) = delete;
  MCParticleCollectionData(MCParticleCollectionData&& other) = default;
  MCParticleCollectionData& operator=(MCParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(MCParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_parents;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_parents_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::MCParticle> m_rel_daughters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::MCParticle>> m_rel_daughters_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitDATA_H
#define EDM4HEP_SimTrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimTrackerHitData
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float EDep{}; ///< energy deposited in the hit [GeV].
  float time{}; ///< proper time of the hit in the lab frame in [ns].
  float pathLength{}; ///< path length of the particle in the sensitive material that resulted in this hit.
  std::int32_t quality{}; ///< quality bit flag.
  ::edm4hep::Vector3d position{}; ///< the hit position in [mm].
  ::edm4hep::Vector3f momentum{}; ///< the 3-momentum of the particle at the hits position in [GeV]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_H
#define EDM4HEP_SimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimTrackerHit;
class SimTrackerHitCollection;

/** @class SimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class SimTrackerHit {

  friend class MutableSimTrackerHit;
  friend class SimTrackerHitCollection;
  friend class SimTrackerHitCollectionIterator;

public:
  using mutable_type = MutableSimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  SimTrackerHit();
  SimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  SimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  SimTrackerHit(const SimTrackerHit& other);

  /// copy-assignment operator
  SimTrackerHit& operator=(SimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~SimTrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimTrackerHit& a, SimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimTrackerHit_H
#define EDM4HEP_MutableSimTrackerHit_H

#include "edm4hep/SimTrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimTrackerHit.h"

#include "edm4hep/Vector3d.h"
#include "edm4hep/Vector3f.h"
#include <cmath>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimTrackerHit
 *  Simulated tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableSimTrackerHit {

  friend class SimTrackerHitCollection;
  friend class SimTrackerHitMutableCollectionIterator;
  friend class SimTrackerHit;

public:
  using object_type = SimTrackerHit;
  using collection_type = SimTrackerHitCollection;

  /// default constructor
  MutableSimTrackerHit();
  MutableSimTrackerHit(std::uint64_t cellID, float EDep, float time, float pathLength, std::int32_t quality, edm4hep::Vector3d position, edm4hep::Vector3f momentum);

  /// constructor from existing SimTrackerHitObj
  MutableSimTrackerHit(SimTrackerHitObj* obj);

  /// copy constructor
  MutableSimTrackerHit(const MutableSimTrackerHit& other);

  /// copy-assignment operator
  MutableSimTrackerHit& operator=(MutableSimTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimTrackerHit clone() const;

  /// destructor
  ~MutableSimTrackerHit();

  /// conversion to const object
  operator SimTrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy deposited in the hit [GeV].
  const float& getEDep() const;

  /// Access the proper time of the hit in the lab frame in [ns].
  const float& getTime() const;

  /// Access the path length of the particle in the sensitive material that resulted in this hit.
  const float& getPathLength() const;

  /// Access the quality bit flag.
  const std::int32_t& getQuality() const;

  /// Access the the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the the 3-momentum of the particle at the hits position in [GeV]
  const edm4hep::Vector3f& getMomentum() const;


  /// Access the MCParticle that caused the hit.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy deposited in the hit [GeV].
  void setEDep(float value);

  /// Set the proper time of the hit in the lab frame in [ns].
  void setTime(float value);

  /// Set the path length of the particle in the sensitive material that resulted in this hit.
  void setPathLength(float value);

  /// Set the quality bit flag.
  void setQuality(std::int32_t value);

  /// Set the the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the the 3-momentum of the particle at the hits position in [GeV]
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to the 3-momentum of the particle at the hits position in [GeV]
  edm4hep::Vector3f& momentum();


  /// Set the MCParticle that caused the hit.
  void setMCParticle(edm4hep::MCParticle value);


 static const int  BITOverlay = 31;
 static const int  BITProducedBySecondary = 30;
 bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }
 bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }
 double x() const {return getPosition()[0];}
 double y() const {return getPosition()[1];}
 double z() const {return getPosition()[2];}
 double rho() const {return sqrt(x()*x() + y()*y());}
 

 int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }
 void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }
 void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimTrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimTrackerHit& a, MutableSimTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimTrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitOBJ_H
#define EDM4HEP_SimTrackerHitOBJ_H

// data model specific includes
#include "edm4hep/SimTrackerHitData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimTrackerHit;

class SimTrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  SimTrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimTrackerHitObj(const SimTrackerHitObj&);
  /// constructor from ObjectID and SimTrackerHitData
  /// does not initialize the internal relation containers
  SimTrackerHitObj(const podio::ObjectID id, SimTrackerHitData data);
  /// No assignment operator
  SimTrackerHitObj& operator=(const SimTrackerHitObj&) = delete;
  virtual ~SimTrackerHitObj();

public:
  SimTrackerHitData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHitCollection_H
#define EDM4HEP_SimTrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/MutableSimTrackerHit.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/SimTrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimTrackerHitCollectionIterator {
public:
  SimTrackerHitCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitCollectionIterator(const SimTrackerHitCollectionIterator&) = delete;
  SimTrackerHitCollectionIterator& operator=(const SimTrackerHitCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimTrackerHit operator*();
  SimTrackerHit* operator->();
  SimTrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


class SimTrackerHitMutableCollectionIterator {
public:
  SimTrackerHitMutableCollectionIterator(size_t index, const SimTrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimTrackerHitMutableCollectionIterator(const SimTrackerHitMutableCollectionIterator&) = delete;
  SimTrackerHitMutableCollectionIterator& operator=(const SimTrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimTrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimTrackerHit operator*();
  MutableSimTrackerHit* operator->();
  SimTrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimTrackerHit m_object;
  const SimTrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimTrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = SimTrackerHit;
  using const_iterator = SimTrackerHitCollectionIterator;
  using iterator = SimTrackerHitMutableCollectionIterator;

  SimTrackerHitCollection();
  SimTrackerHitCollection(SimTrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimTrackerHitCollection(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection& operator=(const SimTrackerHitCollection& ) = delete;
  SimTrackerHitCollection(SimTrackerHitCollection&&) = default;
  SimTrackerHitCollection& operator=(SimTrackerHitCollection&&) = default;

//  SimTrackerHitCollection(SimTrackerHitVector* data, uint32_t collectionID);
  ~SimTrackerHitCollection();

  constexpr static auto typeName = "edm4hep::SimTrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimTrackerHit";
  constexpr static auto dataTypeName = "edm4hep::SimTrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimTrackerHitCollection* operator->() { return (SimTrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimTrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimTrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimTrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimTrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> EDep(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> pathLength(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimTrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimTrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimTrackerHitCollection& v);

template<typename... Args>
MutableSimTrackerHit SimTrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimTrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableSimTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimTrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimTrackerHit_CollectionData_H
#define EDM4HEP_SimTrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimTrackerHitData.h"
#include "edm4hep/SimTrackerHitObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimTrackerHitObjPointerContainer = std::deque<SimTrackerHitObj*>;
using SimTrackerHitDataContainer = std::vector<SimTrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimTrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimTrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimTrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimTrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimTrackerHitCollectionData(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData& operator=(const SimTrackerHitCollectionData&) = delete;
  SimTrackerHitCollectionData(SimTrackerHitCollectionData&& other) = default;
  SimTrackerHitCollectionData& operator=(SimTrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimTrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimTrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionDATA_H
#define EDM4HEP_CaloHitContributionDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CaloHitContributionData
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContributionData {
public:
  std::int32_t PDG{}; ///< PDG code of the shower particle that caused this contribution.
  float energy{}; ///< energy in [GeV] of the this contribution
  float time{}; ///< time in [ns] of this contribution
  ::edm4hep::Vector3f stepPosition{}; ///< position of this energy deposition (step) [mm]

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_H
#define EDM4HEP_CaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableCaloHitContribution;
class CaloHitContributionCollection;

/** @class CaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class CaloHitContribution {

  friend class MutableCaloHitContribution;
  friend class CaloHitContributionCollection;
  friend class CaloHitContributionCollectionIterator;

public:
  using mutable_type = MutableCaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  CaloHitContribution();
  CaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  CaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  CaloHitContribution(const CaloHitContribution& other);

  /// copy-assignment operator
  CaloHitContribution& operator=(CaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~CaloHitContribution();


public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CaloHitContribution& a, CaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CaloHitContribution& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCaloHitContribution_H
#define EDM4HEP_MutableCaloHitContribution_H

#include "edm4hep/CaloHitContributionObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CaloHitContribution.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableCaloHitContribution
 *  Monte Carlo contribution to SimCalorimeterHit
 *  @author: F.Gaede, DESY
 */
class MutableCaloHitContribution {

  friend class CaloHitContributionCollection;
  friend class CaloHitContributionMutableCollectionIterator;
  friend class CaloHitContribution;

public:
  using object_type = CaloHitContribution;
  using collection_type = CaloHitContributionCollection;

  /// default constructor
  MutableCaloHitContribution();
  MutableCaloHitContribution(std::int32_t PDG, float energy, float time, edm4hep::Vector3f stepPosition);

  /// constructor from existing CaloHitContributionObj
  MutableCaloHitContribution(CaloHitContributionObj* obj);

  /// copy constructor
  MutableCaloHitContribution(const MutableCaloHitContribution& other);

  /// copy-assignment operator
  MutableCaloHitContribution& operator=(MutableCaloHitContribution other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCaloHitContribution clone() const;

  /// destructor
  ~MutableCaloHitContribution();

  /// conversion to const object
  operator CaloHitContribution() const;

public:

  /// Access the PDG code of the shower particle that caused this contribution.
  const std::int32_t& getPDG() const;

  /// Access the energy in [GeV] of the this contribution
  const float& getEnergy() const;

  /// Access the time in [ns] of this contribution
  const float& getTime() const;

  /// Access the position of this energy deposition (step) [mm]
  const edm4hep::Vector3f& getStepPosition() const;


  /// Access the primary MCParticle that caused the shower responsible for this contribution to the hit.
  const edm4hep::MCParticle getParticle() const;

  /// Set the PDG code of the shower particle that caused this contribution.
  void setPDG(std::int32_t value);

  /// Set the energy in [GeV] of the this contribution
  void setEnergy(float value);

  /// Set the time in [ns] of this contribution
  void setTime(float value);

  /// Set the position of this energy deposition (step) [mm]
  void setStepPosition(edm4hep::Vector3f value);
  /// Get reference to position of this energy deposition (step) [mm]
  edm4hep::Vector3f& stepPosition();


  /// Set the primary MCParticle that caused the shower responsible for this contribution to the hit.
  void setParticle(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CaloHitContributionObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCaloHitContribution& other) const { return m_obj == other.m_obj; }
  bool operator==(const CaloHitContribution& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCaloHitContribution& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCaloHitContribution& a, MutableCaloHitContribution& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CaloHitContributionObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCaloHitContribution& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionOBJ_H
#define EDM4HEP_CaloHitContributionOBJ_H

// data model specific includes
#include "edm4hep/CaloHitContributionData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class CaloHitContribution;

class CaloHitContributionObj : public podio::ObjBase {
public:
  /// constructor
  CaloHitContributionObj();
  /// copy constructor (does a deep-copy of relation containers)
  CaloHitContributionObj(const CaloHitContributionObj&);
  /// constructor from ObjectID and CaloHitContributionData
  /// does not initialize the internal relation containers
  CaloHitContributionObj(const podio::ObjectID id, CaloHitContributionData data);
  /// No assignment operator
  CaloHitContributionObj& operator=(const CaloHitContributionObj&) = delete;
  virtual ~CaloHitContributionObj();

public:
  CaloHitContributionData data;
  edm4hep::MCParticle* m_particle{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContributionCollection_H
#define EDM4HEP_CaloHitContributionCollection_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/MutableCaloHitContribution.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/CaloHitContributionCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CaloHitContributionCollectionIterator {
public:
  CaloHitContributionCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionCollectionIterator(const CaloHitContributionCollectionIterator&) = delete;
  CaloHitContributionCollectionIterator& operator=(const CaloHitContributionCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CaloHitContribution operator*();
  CaloHitContribution* operator->();
  CaloHitContributionCollectionIterator& operator++();

private:
  size_t m_index;
  CaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


class CaloHitContributionMutableCollectionIterator {
public:
  CaloHitContributionMutableCollectionIterator(size_t index, const CaloHitContributionObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CaloHitContributionMutableCollectionIterator(const CaloHitContributionMutableCollectionIterator&) = delete;
  CaloHitContributionMutableCollectionIterator& operator=(const CaloHitContributionMutableCollectionIterator&) = delete;

  bool operator!=(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CaloHitContributionMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCaloHitContribution operator*();
  MutableCaloHitContribution* operator->();
  CaloHitContributionMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCaloHitContribution m_object;
  const CaloHitContributionObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CaloHitContributionCollection : public podio::CollectionBase {
public:
  using value_type = CaloHitContribution;
  using const_iterator = CaloHitContributionCollectionIterator;
  using iterator = CaloHitContributionMutableCollectionIterator;

  CaloHitContributionCollection();
  CaloHitContributionCollection(CaloHitContributionCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CaloHitContributionCollection(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection& operator=(const CaloHitContributionCollection& ) = delete;
  CaloHitContributionCollection(CaloHitContributionCollection&&) = default;
  CaloHitContributionCollection& operator=(CaloHitContributionCollection&&) = default;

//  CaloHitContributionCollection(CaloHitContributionVector* data, uint32_t collectionID);
  ~CaloHitContributionCollection();

  constexpr static auto typeName = "edm4hep::CaloHitContributionCollection";
  constexpr static auto valueTypeName = "edm4hep::CaloHitContribution";
  constexpr static auto dataTypeName = "edm4hep::CaloHitContributionData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CaloHitContributionCollection* operator->() { return (CaloHitContributionCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCaloHitContribution create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCaloHitContribution create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CaloHitContribution operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCaloHitContribution operator[](std::size_t index);
  /// Returns the const object of given index
  CaloHitContribution at(std::size_t index) const;
  /// Returns the object of given index
  MutableCaloHitContribution at(std::size_t index);


  /// Append object to the collection
  void push_back(CaloHitContribution object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CaloHitContributionObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> stepPosition(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CaloHitContributionCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CaloHitContributionCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CaloHitContributionCollection& v);

template<typename... Args>
MutableCaloHitContribution CaloHitContributionCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CaloHitContributionObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCaloHitContribution(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CaloHitContributionCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CaloHitContribution_CollectionData_H
#define EDM4HEP_CaloHitContribution_CollectionData_H

// datamodel specific includes
#include "edm4hep/CaloHitContributionData.h"
#include "edm4hep/CaloHitContributionObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CaloHitContributionObjPointerContainer = std::deque<CaloHitContributionObj*>;
using CaloHitContributionDataContainer = std::vector<CaloHitContributionData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CaloHitContributionCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CaloHitContributionObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CaloHitContributionCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CaloHitContributionCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CaloHitContributionCollectionData(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData& operator=(const CaloHitContributionCollectionData&) = delete;
  CaloHitContributionCollectionData(CaloHitContributionCollectionData&& other) = default;
  CaloHitContributionCollectionData& operator=(CaloHitContributionCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CaloHitContributionCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_particle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CaloHitContributionDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitDATA_H
#define EDM4HEP_SimCalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class SimCalorimeterHitData
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  float energy{}; ///< energy of the hit in [GeV].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].

  unsigned int contributions_begin{};
  unsigned int contributions_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_H
#define EDM4HEP_SimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableSimCalorimeterHit;
class SimCalorimeterHitCollection;

/** @class SimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class SimCalorimeterHit {

  friend class MutableSimCalorimeterHit;
  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableSimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  SimCalorimeterHit();
  SimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  SimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  SimCalorimeterHit(const SimCalorimeterHit& other);

  /// copy-assignment operator
  SimCalorimeterHit& operator=(SimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~SimCalorimeterHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimCalorimeterHit& a, SimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimCalorimeterHit_H
#define EDM4HEP_MutableSimCalorimeterHit_H

#include "edm4hep/SimCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimCalorimeterHit.h"

#include "edm4hep/CaloHitContribution.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableSimCalorimeterHit
 *  Simulated calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableSimCalorimeterHit {

  friend class SimCalorimeterHitCollection;
  friend class SimCalorimeterHitMutableCollectionIterator;
  friend class SimCalorimeterHit;

public:
  using object_type = SimCalorimeterHit;
  using collection_type = SimCalorimeterHitCollection;

  /// default constructor
  MutableSimCalorimeterHit();
  MutableSimCalorimeterHit(std::uint64_t cellID, float energy, edm4hep::Vector3f position);

  /// constructor from existing SimCalorimeterHitObj
  MutableSimCalorimeterHit(SimCalorimeterHitObj* obj);

  /// copy constructor
  MutableSimCalorimeterHit(const MutableSimCalorimeterHit& other);

  /// copy-assignment operator
  MutableSimCalorimeterHit& operator=(MutableSimCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimCalorimeterHit clone() const;

  /// destructor
  ~MutableSimCalorimeterHit();

  /// conversion to const object
  operator SimCalorimeterHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;



  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();



  void addToContributions(edm4hep::CaloHitContribution);
  std::size_t contributions_size() const;
  edm4hep::CaloHitContribution getContributions(std::size_t) const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_begin() const;
  std::vector<edm4hep::CaloHitContribution>::const_iterator contributions_end() const;
  podio::RelationRange<edm4hep::CaloHitContribution> getContributions() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimCalorimeterHit& a, MutableSimCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitOBJ_H
#define EDM4HEP_SimCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/CaloHitContribution.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class SimCalorimeterHit;

class SimCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  SimCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimCalorimeterHitObj(const SimCalorimeterHitObj&);
  /// constructor from ObjectID and SimCalorimeterHitData
  /// does not initialize the internal relation containers
  SimCalorimeterHitObj(const podio::ObjectID id, SimCalorimeterHitData data);
  /// No assignment operator
  SimCalorimeterHitObj& operator=(const SimCalorimeterHitObj&) = delete;
  virtual ~SimCalorimeterHitObj();

public:
  SimCalorimeterHitData data;
  std::vector<edm4hep::CaloHitContribution>* m_contributions{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHitCollection_H
#define EDM4HEP_SimCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/MutableSimCalorimeterHit.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/SimCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimCalorimeterHitCollectionIterator {
public:
  SimCalorimeterHitCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitCollectionIterator(const SimCalorimeterHitCollectionIterator&) = delete;
  SimCalorimeterHitCollectionIterator& operator=(const SimCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimCalorimeterHit operator*();
  SimCalorimeterHit* operator->();
  SimCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  SimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


class SimCalorimeterHitMutableCollectionIterator {
public:
  SimCalorimeterHitMutableCollectionIterator(size_t index, const SimCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimCalorimeterHitMutableCollectionIterator(const SimCalorimeterHitMutableCollectionIterator&) = delete;
  SimCalorimeterHitMutableCollectionIterator& operator=(const SimCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimCalorimeterHit operator*();
  MutableSimCalorimeterHit* operator->();
  SimCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimCalorimeterHit m_object;
  const SimCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = SimCalorimeterHit;
  using const_iterator = SimCalorimeterHitCollectionIterator;
  using iterator = SimCalorimeterHitMutableCollectionIterator;

  SimCalorimeterHitCollection();
  SimCalorimeterHitCollection(SimCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimCalorimeterHitCollection(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection& operator=(const SimCalorimeterHitCollection& ) = delete;
  SimCalorimeterHitCollection(SimCalorimeterHitCollection&&) = default;
  SimCalorimeterHitCollection& operator=(SimCalorimeterHitCollection&&) = default;

//  SimCalorimeterHitCollection(SimCalorimeterHitVector* data, uint32_t collectionID);
  ~SimCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::SimCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::SimCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::SimCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimCalorimeterHitCollection* operator->() { return (SimCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  SimCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(SimCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimCalorimeterHitCollection& v);

template<typename... Args>
MutableSimCalorimeterHit SimCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimCalorimeterHitData} constructor
  obj->m_contributions = new std::vector<edm4hep::CaloHitContribution>();
  m_storage.createRelations(obj);
  return MutableSimCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimCalorimeterHit_CollectionData_H
#define EDM4HEP_SimCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimCalorimeterHitData.h"
#include "edm4hep/SimCalorimeterHitObj.h"
#include "edm4hep/CaloHitContribution.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimCalorimeterHitObjPointerContainer = std::deque<SimCalorimeterHitObj*>;
using SimCalorimeterHitDataContainer = std::vector<SimCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimCalorimeterHitCollectionData(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData& operator=(const SimCalorimeterHitCollectionData&) = delete;
  SimCalorimeterHitCollectionData(SimCalorimeterHitCollectionData&& other) = default;
  SimCalorimeterHitCollectionData& operator=(SimCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimCalorimeterHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CaloHitContribution> m_rel_contributions;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CaloHitContribution>> m_rel_contributions_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitDATA_H
#define EDM4HEP_RawCalorimeterHitDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawCalorimeterHitData
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  std::int32_t amplitude{}; ///< amplitude of the hit in ADC counts.
  std::int32_t timeStamp{}; ///< time stamp for the hit.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_H
#define EDM4HEP_RawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawCalorimeterHit;
class RawCalorimeterHitCollection;

/** @class RawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class RawCalorimeterHit {

  friend class MutableRawCalorimeterHit;
  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableRawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  RawCalorimeterHit();
  RawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  RawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  RawCalorimeterHit(const RawCalorimeterHit& other);

  /// copy-assignment operator
  RawCalorimeterHit& operator=(RawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~RawCalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawCalorimeterHit& a, RawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawCalorimeterHit_H
#define EDM4HEP_MutableRawCalorimeterHit_H

#include "edm4hep/RawCalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawCalorimeterHit.h"

#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawCalorimeterHit
 *  Raw calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableRawCalorimeterHit {

  friend class RawCalorimeterHitCollection;
  friend class RawCalorimeterHitMutableCollectionIterator;
  friend class RawCalorimeterHit;

public:
  using object_type = RawCalorimeterHit;
  using collection_type = RawCalorimeterHitCollection;

  /// default constructor
  MutableRawCalorimeterHit();
  MutableRawCalorimeterHit(std::uint64_t cellID, std::int32_t amplitude, std::int32_t timeStamp);

  /// constructor from existing RawCalorimeterHitObj
  MutableRawCalorimeterHit(RawCalorimeterHitObj* obj);

  /// copy constructor
  MutableRawCalorimeterHit(const MutableRawCalorimeterHit& other);

  /// copy-assignment operator
  MutableRawCalorimeterHit& operator=(MutableRawCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawCalorimeterHit clone() const;

  /// destructor
  ~MutableRawCalorimeterHit();

  /// conversion to const object
  operator RawCalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the amplitude of the hit in ADC counts.
  const std::int32_t& getAmplitude() const;

  /// Access the time stamp for the hit.
  const std::int32_t& getTimeStamp() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the amplitude of the hit in ADC counts.
  void setAmplitude(std::int32_t value);

  /// Set the time stamp for the hit.
  void setTimeStamp(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawCalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawCalorimeterHit& a, MutableRawCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawCalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitOBJ_H
#define EDM4HEP_RawCalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/RawCalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class RawCalorimeterHit;

class RawCalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  RawCalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawCalorimeterHitObj(const RawCalorimeterHitObj&);
  /// constructor from ObjectID and RawCalorimeterHitData
  /// does not initialize the internal relation containers
  RawCalorimeterHitObj(const podio::ObjectID id, RawCalorimeterHitData data);
  /// No assignment operator
  RawCalorimeterHitObj& operator=(const RawCalorimeterHitObj&) = delete;
  virtual ~RawCalorimeterHitObj() = default;

public:
  RawCalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHitCollection_H
#define EDM4HEP_RawCalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHit.h"
#include "edm4hep/MutableRawCalorimeterHit.h"
#include "edm4hep/RawCalorimeterHitObj.h"
#include "edm4hep/RawCalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawCalorimeterHitCollectionIterator {
public:
  RawCalorimeterHitCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitCollectionIterator(const RawCalorimeterHitCollectionIterator&) = delete;
  RawCalorimeterHitCollectionIterator& operator=(const RawCalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawCalorimeterHit operator*();
  RawCalorimeterHit* operator->();
  RawCalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  RawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


class RawCalorimeterHitMutableCollectionIterator {
public:
  RawCalorimeterHitMutableCollectionIterator(size_t index, const RawCalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawCalorimeterHitMutableCollectionIterator(const RawCalorimeterHitMutableCollectionIterator&) = delete;
  RawCalorimeterHitMutableCollectionIterator& operator=(const RawCalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawCalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawCalorimeterHit operator*();
  MutableRawCalorimeterHit* operator->();
  RawCalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawCalorimeterHit m_object;
  const RawCalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawCalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = RawCalorimeterHit;
  using const_iterator = RawCalorimeterHitCollectionIterator;
  using iterator = RawCalorimeterHitMutableCollectionIterator;

  RawCalorimeterHitCollection();
  RawCalorimeterHitCollection(RawCalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawCalorimeterHitCollection(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection& operator=(const RawCalorimeterHitCollection& ) = delete;
  RawCalorimeterHitCollection(RawCalorimeterHitCollection&&) = default;
  RawCalorimeterHitCollection& operator=(RawCalorimeterHitCollection&&) = default;

//  RawCalorimeterHitCollection(RawCalorimeterHitVector* data, uint32_t collectionID);
  ~RawCalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::RawCalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::RawCalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::RawCalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawCalorimeterHitCollection* operator->() { return (RawCalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawCalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  RawCalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(RawCalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawCalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> amplitude(const size_t nElem = 0) const;
  std::vector<std::int32_t> timeStamp(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawCalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawCalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawCalorimeterHitCollection& v);

template<typename... Args>
MutableRawCalorimeterHit RawCalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawCalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRawCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawCalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawCalorimeterHit_CollectionData_H
#define EDM4HEP_RawCalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawCalorimeterHitData.h"
#include "edm4hep/RawCalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawCalorimeterHitObjPointerContainer = std::deque<RawCalorimeterHitObj*>;
using RawCalorimeterHitDataContainer = std::vector<RawCalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawCalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawCalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawCalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawCalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawCalorimeterHitCollectionData(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData& operator=(const RawCalorimeterHitCollectionData&) = delete;
  RawCalorimeterHitCollectionData(RawCalorimeterHitCollectionData&& other) = default;
  RawCalorimeterHitCollectionData& operator=(RawCalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawCalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawCalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitDATA_H
#define EDM4HEP_CalorimeterHitDATA_H

#include "edm4hep/Vector3f.h"
#include <cstdint>

namespace edm4hep {


/** @class CalorimeterHitData
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHitData {
public:
  std::uint64_t cellID{}; ///< detector specific (geometrical) cell id.
  float energy{}; ///< energy of the hit in [GeV].
  float energyError{}; ///< error of the hit energy in [GeV].
  float time{}; ///< time of the hit in [ns].
  ::edm4hep::Vector3f position{}; ///< position of the hit in world coordinates in [mm].
  std::int32_t type{}; ///< type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_H
#define EDM4HEP_CalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCalorimeterHit;
class CalorimeterHitCollection;

/** @class CalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class CalorimeterHit {

  friend class MutableCalorimeterHit;
  friend class CalorimeterHitCollection;
  friend class CalorimeterHitCollectionIterator;

public:
  using mutable_type = MutableCalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  CalorimeterHit();
  CalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  CalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  CalorimeterHit(const CalorimeterHit& other);

  /// copy-assignment operator
  CalorimeterHit& operator=(CalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~CalorimeterHit();


public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;





  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const CalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const CalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(CalorimeterHit& a, CalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCalorimeterHit_H
#define EDM4HEP_MutableCalorimeterHit_H

#include "edm4hep/CalorimeterHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/CalorimeterHit.h"

#include "edm4hep/Vector3f.h"
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCalorimeterHit
 *  Calorimeter hit
 *  @author: F.Gaede, DESY
 */
class MutableCalorimeterHit {

  friend class CalorimeterHitCollection;
  friend class CalorimeterHitMutableCollectionIterator;
  friend class CalorimeterHit;

public:
  using object_type = CalorimeterHit;
  using collection_type = CalorimeterHitCollection;

  /// default constructor
  MutableCalorimeterHit();
  MutableCalorimeterHit(std::uint64_t cellID, float energy, float energyError, float time, edm4hep::Vector3f position, std::int32_t type);

  /// constructor from existing CalorimeterHitObj
  MutableCalorimeterHit(CalorimeterHitObj* obj);

  /// copy constructor
  MutableCalorimeterHit(const MutableCalorimeterHit& other);

  /// copy-assignment operator
  MutableCalorimeterHit& operator=(MutableCalorimeterHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCalorimeterHit clone() const;

  /// destructor
  ~MutableCalorimeterHit();

  /// conversion to const object
  operator CalorimeterHit() const;

public:

  /// Access the detector specific (geometrical) cell id.
  const std::uint64_t& getCellID() const;

  /// Access the energy of the hit in [GeV].
  const float& getEnergy() const;

  /// Access the error of the hit energy in [GeV].
  const float& getEnergyError() const;

  /// Access the time of the hit in [ns].
  const float& getTime() const;

  /// Access the position of the hit in world coordinates in [mm].
  const edm4hep::Vector3f& getPosition() const;

  /// Access the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  const std::int32_t& getType() const;



  /// Set the detector specific (geometrical) cell id.
  void setCellID(std::uint64_t value);

  /// Set the energy of the hit in [GeV].
  void setEnergy(float value);

  /// Set the error of the hit energy in [GeV].
  void setEnergyError(float value);

  /// Set the time of the hit in [ns].
  void setTime(float value);

  /// Set the position of the hit in world coordinates in [mm].
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the hit in world coordinates in [mm].
  edm4hep::Vector3f& position();

  /// Set the type of hit. Mapping of integer types to names via collection parameters "CalorimeterHitTypeNames" and "CalorimeterHitTypeValues".
  void setType(std::int32_t value);






  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from CalorimeterHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCalorimeterHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const CalorimeterHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCalorimeterHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCalorimeterHit& a, MutableCalorimeterHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  CalorimeterHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCalorimeterHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitOBJ_H
#define EDM4HEP_CalorimeterHitOBJ_H

// data model specific includes
#include "edm4hep/CalorimeterHitData.h"

#include "podio/ObjBase.h"



namespace edm4hep {

class CalorimeterHit;

class CalorimeterHitObj : public podio::ObjBase {
public:
  /// constructor
  CalorimeterHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  CalorimeterHitObj(const CalorimeterHitObj&);
  /// constructor from ObjectID and CalorimeterHitData
  /// does not initialize the internal relation containers
  CalorimeterHitObj(const podio::ObjectID id, CalorimeterHitData data);
  /// No assignment operator
  CalorimeterHitObj& operator=(const CalorimeterHitObj&) = delete;
  virtual ~CalorimeterHitObj() = default;

public:
  CalorimeterHitData data;
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHitCollection_H
#define EDM4HEP_CalorimeterHitCollection_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MutableCalorimeterHit.h"
#include "edm4hep/CalorimeterHitObj.h"
#include "edm4hep/CalorimeterHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class CalorimeterHitCollectionIterator {
public:
  CalorimeterHitCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitCollectionIterator(const CalorimeterHitCollectionIterator&) = delete;
  CalorimeterHitCollectionIterator& operator=(const CalorimeterHitCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  CalorimeterHit operator*();
  CalorimeterHit* operator->();
  CalorimeterHitCollectionIterator& operator++();

private:
  size_t m_index;
  CalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


class CalorimeterHitMutableCollectionIterator {
public:
  CalorimeterHitMutableCollectionIterator(size_t index, const CalorimeterHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  CalorimeterHitMutableCollectionIterator(const CalorimeterHitMutableCollectionIterator&) = delete;
  CalorimeterHitMutableCollectionIterator& operator=(const CalorimeterHitMutableCollectionIterator&) = delete;

  bool operator!=(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const CalorimeterHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCalorimeterHit operator*();
  MutableCalorimeterHit* operator->();
  CalorimeterHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCalorimeterHit m_object;
  const CalorimeterHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class CalorimeterHitCollection : public podio::CollectionBase {
public:
  using value_type = CalorimeterHit;
  using const_iterator = CalorimeterHitCollectionIterator;
  using iterator = CalorimeterHitMutableCollectionIterator;

  CalorimeterHitCollection();
  CalorimeterHitCollection(CalorimeterHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  CalorimeterHitCollection(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection& operator=(const CalorimeterHitCollection& ) = delete;
  CalorimeterHitCollection(CalorimeterHitCollection&&) = default;
  CalorimeterHitCollection& operator=(CalorimeterHitCollection&&) = default;

//  CalorimeterHitCollection(CalorimeterHitVector* data, uint32_t collectionID);
  ~CalorimeterHitCollection();

  constexpr static auto typeName = "edm4hep::CalorimeterHitCollection";
  constexpr static auto valueTypeName = "edm4hep::CalorimeterHit";
  constexpr static auto dataTypeName = "edm4hep::CalorimeterHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  CalorimeterHitCollection* operator->() { return (CalorimeterHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCalorimeterHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCalorimeterHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  CalorimeterHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCalorimeterHit operator[](std::size_t index);
  /// Returns the const object of given index
  CalorimeterHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableCalorimeterHit at(std::size_t index);


  /// Append object to the collection
  void push_back(CalorimeterHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (CalorimeterHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class CalorimeterHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable CalorimeterHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const CalorimeterHitCollection& v);

template<typename... Args>
MutableCalorimeterHit CalorimeterHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new CalorimeterHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableCalorimeterHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const CalorimeterHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_CalorimeterHit_CollectionData_H
#define EDM4HEP_CalorimeterHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/CalorimeterHitData.h"
#include "edm4hep/CalorimeterHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using CalorimeterHitObjPointerContainer = std::deque<CalorimeterHitObj*>;
using CalorimeterHitDataContainer = std::vector<CalorimeterHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class CalorimeterHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  CalorimeterHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  CalorimeterHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  CalorimeterHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  CalorimeterHitCollectionData(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData& operator=(const CalorimeterHitCollectionData&) = delete;
  CalorimeterHitCollectionData(CalorimeterHitCollectionData&& other) = default;
  CalorimeterHitCollectionData& operator=(CalorimeterHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~CalorimeterHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<CalorimeterHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDDATA_H
#define EDM4HEP_ParticleIDDATA_H

#include <cstdint>

namespace edm4hep {


/** @class ParticleIDData
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleIDData {
public:
  std::int32_t type{}; ///< userdefined type
  std::int32_t PDG{}; ///< PDG code of this id - ( 999999 ) if unknown.
  std::int32_t algorithmType{}; ///< type of the algorithm/module that created this hypothesis
  float likelihood{}; ///< likelihood of this hypothesis - in a user defined normalization.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_H
#define EDM4HEP_ParticleID_H

#include "edm4hep/ParticleIDObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableParticleID;
class ParticleIDCollection;

/** @class ParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class ParticleID {

  friend class MutableParticleID;
  friend class ParticleIDCollection;
  friend class ParticleIDCollectionIterator;

public:
  using mutable_type = MutableParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  ParticleID();
  ParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  ParticleID(ParticleIDObj* obj);

  /// copy constructor
  ParticleID(const ParticleID& other);

  /// copy-assignment operator
  ParticleID& operator=(ParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~ParticleID();


public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ParticleID& a, ParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ParticleID& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableParticleID_H
#define EDM4HEP_MutableParticleID_H

#include "edm4hep/ParticleIDObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ParticleID.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableParticleID
 *  ParticleID
 *  @author: F.Gaede, DESY
 */
class MutableParticleID {

  friend class ParticleIDCollection;
  friend class ParticleIDMutableCollectionIterator;
  friend class ParticleID;

public:
  using object_type = ParticleID;
  using collection_type = ParticleIDCollection;

  /// default constructor
  MutableParticleID();
  MutableParticleID(std::int32_t type, std::int32_t PDG, std::int32_t algorithmType, float likelihood);

  /// constructor from existing ParticleIDObj
  MutableParticleID(ParticleIDObj* obj);

  /// copy constructor
  MutableParticleID(const MutableParticleID& other);

  /// copy-assignment operator
  MutableParticleID& operator=(MutableParticleID other);

  /// create a mutable deep-copy of the object with identical relations
  MutableParticleID clone() const;

  /// destructor
  ~MutableParticleID();

  /// conversion to const object
  operator ParticleID() const;

public:

  /// Access the userdefined type
  const std::int32_t& getType() const;

  /// Access the PDG code of this id - ( 999999 ) if unknown.
  const std::int32_t& getPDG() const;

  /// Access the type of the algorithm/module that created this hypothesis
  const std::int32_t& getAlgorithmType() const;

  /// Access the likelihood of this hypothesis - in a user defined normalization.
  const float& getLikelihood() const;



  /// Set the userdefined type
  void setType(std::int32_t value);

  /// Set the PDG code of this id - ( 999999 ) if unknown.
  void setPDG(std::int32_t value);

  /// Set the type of the algorithm/module that created this hypothesis
  void setAlgorithmType(std::int32_t value);

  /// Set the likelihood of this hypothesis - in a user defined normalization.
  void setLikelihood(float value);



  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ParticleIDObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableParticleID& other) const { return m_obj == other.m_obj; }
  bool operator==(const ParticleID& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableParticleID& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableParticleID& a, MutableParticleID& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ParticleIDObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableParticleID& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDOBJ_H
#define EDM4HEP_ParticleIDOBJ_H

// data model specific includes
#include "edm4hep/ParticleIDData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class ParticleID;

class ParticleIDObj : public podio::ObjBase {
public:
  /// constructor
  ParticleIDObj();
  /// copy constructor (does a deep-copy of relation containers)
  ParticleIDObj(const ParticleIDObj&);
  /// constructor from ObjectID and ParticleIDData
  /// does not initialize the internal relation containers
  ParticleIDObj(const podio::ObjectID id, ParticleIDData data);
  /// No assignment operator
  ParticleIDObj& operator=(const ParticleIDObj&) = delete;
  virtual ~ParticleIDObj();

public:
  ParticleIDData data;
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleIDCollection_H
#define EDM4HEP_ParticleIDCollection_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/MutableParticleID.h"
#include "edm4hep/ParticleIDObj.h"
#include "edm4hep/ParticleIDCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ParticleIDCollectionIterator {
public:
  ParticleIDCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDCollectionIterator(const ParticleIDCollectionIterator&) = delete;
  ParticleIDCollectionIterator& operator=(const ParticleIDCollectionIterator&) = delete;

  bool operator!=(const ParticleIDCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ParticleID operator*();
  ParticleID* operator->();
  ParticleIDCollectionIterator& operator++();

private:
  size_t m_index;
  ParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


class ParticleIDMutableCollectionIterator {
public:
  ParticleIDMutableCollectionIterator(size_t index, const ParticleIDObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ParticleIDMutableCollectionIterator(const ParticleIDMutableCollectionIterator&) = delete;
  ParticleIDMutableCollectionIterator& operator=(const ParticleIDMutableCollectionIterator&) = delete;

  bool operator!=(const ParticleIDMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ParticleIDMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableParticleID operator*();
  MutableParticleID* operator->();
  ParticleIDMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableParticleID m_object;
  const ParticleIDObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ParticleIDCollection : public podio::CollectionBase {
public:
  using value_type = ParticleID;
  using const_iterator = ParticleIDCollectionIterator;
  using iterator = ParticleIDMutableCollectionIterator;

  ParticleIDCollection();
  ParticleIDCollection(ParticleIDCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ParticleIDCollection(const ParticleIDCollection& ) = delete;
  ParticleIDCollection& operator=(const ParticleIDCollection& ) = delete;
  ParticleIDCollection(ParticleIDCollection&&) = default;
  ParticleIDCollection& operator=(ParticleIDCollection&&) = default;

//  ParticleIDCollection(ParticleIDVector* data, uint32_t collectionID);
  ~ParticleIDCollection();

  constexpr static auto typeName = "edm4hep::ParticleIDCollection";
  constexpr static auto valueTypeName = "edm4hep::ParticleID";
  constexpr static auto dataTypeName = "edm4hep::ParticleIDData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ParticleIDCollection* operator->() { return (ParticleIDCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableParticleID create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableParticleID create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ParticleID operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableParticleID operator[](std::size_t index);
  /// Returns the const object of given index
  ParticleID at(std::size_t index) const;
  /// Returns the object of given index
  MutableParticleID at(std::size_t index);


  /// Append object to the collection
  void push_back(ParticleID object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ParticleIDObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> PDG(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;
  std::vector<float> likelihood(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ParticleIDCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ParticleIDCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ParticleIDCollection& v);

template<typename... Args>
MutableParticleID ParticleIDCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ParticleIDObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ParticleIDData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableParticleID(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ParticleIDCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ParticleID_CollectionData_H
#define EDM4HEP_ParticleID_CollectionData_H

// datamodel specific includes
#include "edm4hep/ParticleIDData.h"
#include "edm4hep/ParticleIDObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ParticleIDObjPointerContainer = std::deque<ParticleIDObj*>;
using ParticleIDDataContainer = std::vector<ParticleIDData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ParticleIDCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ParticleIDObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ParticleIDCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ParticleIDCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ParticleIDCollectionData(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData& operator=(const ParticleIDCollectionData&) = delete;
  ParticleIDCollectionData(ParticleIDCollectionData&& other) = default;
  ParticleIDCollectionData& operator=(ParticleIDCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ParticleIDCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ParticleIDObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ParticleIDDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterDATA_H
#define EDM4HEP_ClusterDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ClusterData
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class ClusterData {
public:
  std::int32_t type{}; ///< flagword that defines the type of cluster. Bits 16-31 are used internally.
  float energy{}; ///< energy of the cluster [GeV]
  float energyError{}; ///< error on the energy
  ::edm4hep::Vector3f position{}; ///< position of the cluster [mm]
  std::array<float, 6> positionError{}; ///< covariance matrix of the position (6 Parameters)
  float iTheta{}; ///< intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  float phi{}; ///< intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  ::edm4hep::Vector3f directionError{}; ///< covariance matrix of the direction (3 Parameters) [mm^2]

  unsigned int shapeParameters_begin{};
  unsigned int shapeParameters_end{};
  unsigned int subdetectorEnergies_begin{};
  unsigned int subdetectorEnergies_end{};
  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int hits_begin{};
  unsigned int hits_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_H
#define EDM4HEP_Cluster_H

#include "edm4hep/ClusterObj.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableCluster;
class ClusterCollection;

/** @class Cluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class Cluster {

  friend class MutableCluster;
  friend class ClusterCollection;
  friend class ClusterCollectionIterator;

public:
  using mutable_type = MutableCluster;
  using collection_type = ClusterCollection;

  /// default constructor
  Cluster();
  Cluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  Cluster(ClusterObj* obj);

  /// copy constructor
  Cluster(const Cluster& other);

  /// copy-assignment operator
  Cluster& operator=(Cluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~Cluster();


public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Cluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Cluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Cluster& a, Cluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Cluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Cluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableCluster_H
#define EDM4HEP_MutableCluster_H

#include "edm4hep/ClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Cluster.h"

#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableCluster
 *  Calorimeter Hit Cluster
 *  @author: F.Gaede, DESY
 */
class MutableCluster {

  friend class ClusterCollection;
  friend class ClusterMutableCollectionIterator;
  friend class Cluster;

public:
  using object_type = Cluster;
  using collection_type = ClusterCollection;

  /// default constructor
  MutableCluster();
  MutableCluster(std::int32_t type, float energy, float energyError, edm4hep::Vector3f position, std::array<float, 6> positionError, float iTheta, float phi, edm4hep::Vector3f directionError);

  /// constructor from existing ClusterObj
  MutableCluster(ClusterObj* obj);

  /// copy constructor
  MutableCluster(const MutableCluster& other);

  /// copy-assignment operator
  MutableCluster& operator=(MutableCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableCluster clone() const;

  /// destructor
  ~MutableCluster();

  /// conversion to const object
  operator Cluster() const;

public:

  /// Access the flagword that defines the type of cluster. Bits 16-31 are used internally.
  const std::int32_t& getType() const;

  /// Access the energy of the cluster [GeV]
  const float& getEnergy() const;

  /// Access the error on the energy
  const float& getEnergyError() const;

  /// Access the position of the cluster [mm]
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (6 Parameters)
  const std::array<float, 6>& getPositionError() const;
  /// Access item i of the covariance matrix of the position (6 Parameters)
  const float& getPositionError(size_t i) const;
  /// Access the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  const float& getITheta() const;

  /// Access the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  const float& getPhi() const;

  /// Access the covariance matrix of the direction (3 Parameters) [mm^2]
  const edm4hep::Vector3f& getDirectionError() const;



  /// Set the flagword that defines the type of cluster. Bits 16-31 are used internally.
  void setType(std::int32_t value);

  /// Set the energy of the cluster [GeV]
  void setEnergy(float value);

  /// Set the error on the energy
  void setEnergyError(float value);

  /// Set the position of the cluster [mm]
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to position of the cluster [mm]
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (6 Parameters)
  void setPositionError(std::array<float, 6> value);
  void setPositionError(size_t i, float value);
  /// Get reference to covariance matrix of the position (6 Parameters)
  std::array<float, 6>& positionError();

  /// Set the intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.
  void setITheta(float value);

  /// Set the intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.
  void setPhi(float value);

  /// Set the covariance matrix of the direction (3 Parameters) [mm^2]
  void setDirectionError(edm4hep::Vector3f value);
  /// Get reference to covariance matrix of the direction (3 Parameters) [mm^2]
  edm4hep::Vector3f& directionError();



  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToHits(edm4hep::CalorimeterHit);
  std::size_t hits_size() const;
  edm4hep::CalorimeterHit getHits(std::size_t) const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_begin() const;
  std::vector<edm4hep::CalorimeterHit>::const_iterator hits_end() const;
  podio::RelationRange<edm4hep::CalorimeterHit> getHits() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;
  void addToShapeParameters(float);
  std::size_t shapeParameters_size() const;
  float getShapeParameters(std::size_t) const;
  std::vector<float>::const_iterator shapeParameters_begin() const;
  std::vector<float>::const_iterator shapeParameters_end() const;
  podio::RelationRange<float> getShapeParameters() const;
  void addToSubdetectorEnergies(float);
  std::size_t subdetectorEnergies_size() const;
  float getSubdetectorEnergies(std::size_t) const;
  std::vector<float>::const_iterator subdetectorEnergies_begin() const;
  std::vector<float>::const_iterator subdetectorEnergies_end() const;
  podio::RelationRange<float> getSubdetectorEnergies() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const Cluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableCluster& a, MutableCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterOBJ_H
#define EDM4HEP_ClusterOBJ_H

// data model specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Cluster;

class ClusterObj : public podio::ObjBase {
public:
  /// constructor
  ClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  ClusterObj(const ClusterObj&);
  /// constructor from ObjectID and ClusterData
  /// does not initialize the internal relation containers
  ClusterObj(const podio::ObjectID id, ClusterData data);
  /// No assignment operator
  ClusterObj& operator=(const ClusterObj&) = delete;
  virtual ~ClusterObj();

public:
  ClusterData data;
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::CalorimeterHit>* m_hits{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
  std::vector<float>* m_shapeParameters{nullptr};
  std::vector<float>* m_subdetectorEnergies{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ClusterCollection_H
#define EDM4HEP_ClusterCollection_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MutableCluster.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/ClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ClusterCollectionIterator {
public:
  ClusterCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterCollectionIterator(const ClusterCollectionIterator&) = delete;
  ClusterCollectionIterator& operator=(const ClusterCollectionIterator&) = delete;

  bool operator!=(const ClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Cluster operator*();
  Cluster* operator->();
  ClusterCollectionIterator& operator++();

private:
  size_t m_index;
  Cluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


class ClusterMutableCollectionIterator {
public:
  ClusterMutableCollectionIterator(size_t index, const ClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ClusterMutableCollectionIterator(const ClusterMutableCollectionIterator&) = delete;
  ClusterMutableCollectionIterator& operator=(const ClusterMutableCollectionIterator&) = delete;

  bool operator!=(const ClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableCluster operator*();
  MutableCluster* operator->();
  ClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableCluster m_object;
  const ClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ClusterCollection : public podio::CollectionBase {
public:
  using value_type = Cluster;
  using const_iterator = ClusterCollectionIterator;
  using iterator = ClusterMutableCollectionIterator;

  ClusterCollection();
  ClusterCollection(ClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ClusterCollection(const ClusterCollection& ) = delete;
  ClusterCollection& operator=(const ClusterCollection& ) = delete;
  ClusterCollection(ClusterCollection&&) = default;
  ClusterCollection& operator=(ClusterCollection&&) = default;

//  ClusterCollection(ClusterVector* data, uint32_t collectionID);
  ~ClusterCollection();

  constexpr static auto typeName = "edm4hep::ClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::Cluster";
  constexpr static auto dataTypeName = "edm4hep::ClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ClusterCollection* operator->() { return (ClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Cluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableCluster operator[](std::size_t index);
  /// Returns the const object of given index
  Cluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(Cluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<float> energyError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> positionError(const size_t nElem = 0) const;
  std::vector<float> iTheta(const size_t nElem = 0) const;
  std::vector<float> phi(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> directionError(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ClusterCollection& v);

template<typename... Args>
MutableCluster ClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ClusterData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_hits = new std::vector<edm4hep::CalorimeterHit>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  obj->m_shapeParameters = new std::vector<float>();
  obj->m_subdetectorEnergies = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Cluster_CollectionData_H
#define EDM4HEP_Cluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/ClusterData.h"
#include "edm4hep/ClusterObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/ParticleID.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ClusterObjPointerContainer = std::deque<ClusterObj*>;
using ClusterDataContainer = std::vector<ClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ClusterCollectionData(const ClusterCollectionData&) = delete;
  ClusterCollectionData& operator=(const ClusterCollectionData&) = delete;
  ClusterCollectionData(ClusterCollectionData&& other) = default;
  ClusterCollectionData& operator=(ClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_hits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::CalorimeterHit>> m_rel_hits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<float> m_vec_shapeParameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_shapeParameters{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_subdetectorEnergies{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_subdetectorEnergies{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitDATA_H
#define EDM4HEP_TrackerHitDATA_H

#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitData
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHitData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_H
#define EDM4HEP_TrackerHit_H

#include "edm4hep/TrackerHitObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHit;
class TrackerHitCollection;

/** @class TrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class TrackerHit {

  friend class MutableTrackerHit;
  friend class TrackerHitCollection;
  friend class TrackerHitCollectionIterator;

public:
  using mutable_type = MutableTrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  TrackerHit();
  TrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  TrackerHit(TrackerHitObj* obj);

  /// copy constructor
  TrackerHit(const TrackerHit& other);

  /// copy-assignment operator
  TrackerHit& operator=(TrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~TrackerHit();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHit& a, TrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHit& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHit_H
#define EDM4HEP_MutableTrackerHit_H

#include "edm4hep/TrackerHitObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHit.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHit
 *  Tracker hit
 *  @author: F.Gaede, DESY
 */
class MutableTrackerHit {

  friend class TrackerHitCollection;
  friend class TrackerHitMutableCollectionIterator;
  friend class TrackerHit;

public:
  using object_type = TrackerHit;
  using collection_type = TrackerHitCollection;

  /// default constructor
  MutableTrackerHit();
  MutableTrackerHit(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitObj
  MutableTrackerHit(TrackerHitObj* obj);

  /// copy constructor
  MutableTrackerHit(const MutableTrackerHit& other);

  /// copy-assignment operator
  MutableTrackerHit& operator=(MutableTrackerHit other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHit clone() const;

  /// destructor
  ~MutableTrackerHit();

  /// conversion to const object
  operator TrackerHit() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHit& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHit& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHit& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHit& a, MutableTrackerHit& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHit& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitOBJ_H
#define EDM4HEP_TrackerHitOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHit;

class TrackerHitObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitObj(const TrackerHitObj&);
  /// constructor from ObjectID and TrackerHitData
  /// does not initialize the internal relation containers
  TrackerHitObj(const podio::ObjectID id, TrackerHitData data);
  /// No assignment operator
  TrackerHitObj& operator=(const TrackerHitObj&) = delete;
  virtual ~TrackerHitObj();

public:
  TrackerHitData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitCollection_H
#define EDM4HEP_TrackerHitCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHit.h"
#include "edm4hep/MutableTrackerHit.h"
#include "edm4hep/TrackerHitObj.h"
#include "edm4hep/TrackerHitCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitCollectionIterator {
public:
  TrackerHitCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitCollectionIterator(const TrackerHitCollectionIterator&) = delete;
  TrackerHitCollectionIterator& operator=(const TrackerHitCollectionIterator&) = delete;

  bool operator!=(const TrackerHitCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHit operator*();
  TrackerHit* operator->();
  TrackerHitCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


class TrackerHitMutableCollectionIterator {
public:
  TrackerHitMutableCollectionIterator(size_t index, const TrackerHitObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitMutableCollectionIterator(const TrackerHitMutableCollectionIterator&) = delete;
  TrackerHitMutableCollectionIterator& operator=(const TrackerHitMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHit operator*();
  MutableTrackerHit* operator->();
  TrackerHitMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHit m_object;
  const TrackerHitObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHit;
  using const_iterator = TrackerHitCollectionIterator;
  using iterator = TrackerHitMutableCollectionIterator;

  TrackerHitCollection();
  TrackerHitCollection(TrackerHitCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitCollection(const TrackerHitCollection& ) = delete;
  TrackerHitCollection& operator=(const TrackerHitCollection& ) = delete;
  TrackerHitCollection(TrackerHitCollection&&) = default;
  TrackerHitCollection& operator=(TrackerHitCollection&&) = default;

//  TrackerHitCollection(TrackerHitVector* data, uint32_t collectionID);
  ~TrackerHitCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHit";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitCollection* operator->() { return (TrackerHitCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHit create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHit create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHit operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHit operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHit at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHit at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHit object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitCollection& v);

template<typename... Args>
MutableTrackerHit TrackerHitCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHit(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHit_CollectionData_H
#define EDM4HEP_TrackerHit_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitData.h"
#include "edm4hep/TrackerHitObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitObjPointerContainer = std::deque<TrackerHitObj*>;
using TrackerHitDataContainer = std::vector<TrackerHitData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitCollectionData(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData& operator=(const TrackerHitCollectionData&) = delete;
  TrackerHitCollectionData(TrackerHitCollectionData&& other) = default;
  TrackerHitCollectionData& operator=(TrackerHitCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneDATA_H
#define EDM4HEP_TrackerHitPlaneDATA_H

#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerHitPlaneData
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlaneData {
public:
  std::uint64_t cellID{}; ///< ID of the sensor that created this hit
  std::int32_t type{}; ///< type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  std::int32_t quality{}; ///< quality bit flag of the hit.
  float time{}; ///< time of the hit [ns].
  float eDep{}; ///< energy deposited on the hit [GeV].
  float eDepError{}; ///< error measured on EDep [GeV].
  ::edm4hep::Vector2f u{}; ///< measurement direction vector, u lies in the x-y plane
  ::edm4hep::Vector2f v{}; ///< measurement direction vector, v is along z
  float du{}; ///< measurement error along the direction
  float dv{}; ///< measurement error along the direction
  ::edm4hep::Vector3d position{}; ///< hit position in [mm].
  std::array<float, 6> covMatrix{}; ///< covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)

  unsigned int rawHits_begin{};
  unsigned int rawHits_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_H
#define EDM4HEP_TrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrackerHitPlane;
class TrackerHitPlaneCollection;

/** @class TrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class TrackerHitPlane {

  friend class MutableTrackerHitPlane;
  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneCollectionIterator;

public:
  using mutable_type = MutableTrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  TrackerHitPlane();
  TrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  TrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  TrackerHitPlane(const TrackerHitPlane& other);

  /// copy-assignment operator
  TrackerHitPlane& operator=(TrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~TrackerHitPlane();


public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerHitPlane& a, TrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlane& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerHitPlane_H
#define EDM4HEP_MutableTrackerHitPlane_H

#include "edm4hep/TrackerHitPlaneObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerHitPlane.h"

#include "edm4hep/ObjectID.h"
#include "edm4hep/Vector2f.h"
#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrackerHitPlane
 *  Tracker hit plane
 *  @author: Placido Fernandez Declara, CERN
 */
class MutableTrackerHitPlane {

  friend class TrackerHitPlaneCollection;
  friend class TrackerHitPlaneMutableCollectionIterator;
  friend class TrackerHitPlane;

public:
  using object_type = TrackerHitPlane;
  using collection_type = TrackerHitPlaneCollection;

  /// default constructor
  MutableTrackerHitPlane();
  MutableTrackerHitPlane(std::uint64_t cellID, std::int32_t type, std::int32_t quality, float time, float eDep, float eDepError, edm4hep::Vector2f u, edm4hep::Vector2f v, float du, float dv, edm4hep::Vector3d position, std::array<float, 6> covMatrix);

  /// constructor from existing TrackerHitPlaneObj
  MutableTrackerHitPlane(TrackerHitPlaneObj* obj);

  /// copy constructor
  MutableTrackerHitPlane(const MutableTrackerHitPlane& other);

  /// copy-assignment operator
  MutableTrackerHitPlane& operator=(MutableTrackerHitPlane other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerHitPlane clone() const;

  /// destructor
  ~MutableTrackerHitPlane();

  /// conversion to const object
  operator TrackerHitPlane() const;

public:

  /// Access the ID of the sensor that created this hit
  const std::uint64_t& getCellID() const;

  /// Access the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  const std::int32_t& getType() const;

  /// Access the quality bit flag of the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the energy deposited on the hit [GeV].
  const float& getEDep() const;

  /// Access the error measured on EDep [GeV].
  const float& getEDepError() const;

  /// Access the measurement direction vector, u lies in the x-y plane
  const edm4hep::Vector2f& getU() const;

  /// Access the measurement direction vector, v is along z
  const edm4hep::Vector2f& getV() const;

  /// Access the measurement error along the direction
  const float& getDu() const;

  /// Access the measurement error along the direction
  const float& getDv() const;

  /// Access the hit position in [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  const float& getCovMatrix(size_t i) const;


  /// Set the ID of the sensor that created this hit
  void setCellID(std::uint64_t value);

  /// Set the type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters "TrackerHitTypeNames" and "TrackerHitTypeValues".
  void setType(std::int32_t value);

  /// Set the quality bit flag of the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the energy deposited on the hit [GeV].
  void setEDep(float value);

  /// Set the error measured on EDep [GeV].
  void setEDepError(float value);

  /// Set the measurement direction vector, u lies in the x-y plane
  void setU(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, u lies in the x-y plane
  edm4hep::Vector2f& u();

  /// Set the measurement direction vector, v is along z
  void setV(edm4hep::Vector2f value);
  /// Get reference to measurement direction vector, v is along z
  edm4hep::Vector2f& v();

  /// Set the measurement error along the direction
  void setDu(float value);

  /// Set the measurement error along the direction
  void setDv(float value);

  /// Set the hit position in [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to hit position in [mm].
  edm4hep::Vector3d& position();

  /// Set the covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)
  std::array<float, 6>& covMatrix();



  void addToRawHits(edm4hep::ObjectID);
  std::size_t rawHits_size() const;
  edm4hep::ObjectID getRawHits(std::size_t) const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_begin() const;
  std::vector<edm4hep::ObjectID>::const_iterator rawHits_end() const;
  podio::RelationRange<edm4hep::ObjectID> getRawHits() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerHitPlaneObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerHitPlane& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerHitPlane& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerHitPlane& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerHitPlane& a, MutableTrackerHitPlane& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerHitPlaneObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerHitPlane& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneOBJ_H
#define EDM4HEP_TrackerHitPlaneOBJ_H

// data model specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/ObjectID.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TrackerHitPlane;

class TrackerHitPlaneObj : public podio::ObjBase {
public:
  /// constructor
  TrackerHitPlaneObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerHitPlaneObj(const TrackerHitPlaneObj&);
  /// constructor from ObjectID and TrackerHitPlaneData
  /// does not initialize the internal relation containers
  TrackerHitPlaneObj(const podio::ObjectID id, TrackerHitPlaneData data);
  /// No assignment operator
  TrackerHitPlaneObj& operator=(const TrackerHitPlaneObj&) = delete;
  virtual ~TrackerHitPlaneObj();

public:
  TrackerHitPlaneData data;
  std::vector<edm4hep::ObjectID>* m_rawHits{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlaneCollection_H
#define EDM4HEP_TrackerHitPlaneCollection_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlane.h"
#include "edm4hep/MutableTrackerHitPlane.h"
#include "edm4hep/TrackerHitPlaneObj.h"
#include "edm4hep/TrackerHitPlaneCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerHitPlaneCollectionIterator {
public:
  TrackerHitPlaneCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneCollectionIterator(const TrackerHitPlaneCollectionIterator&) = delete;
  TrackerHitPlaneCollectionIterator& operator=(const TrackerHitPlaneCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerHitPlane operator*();
  TrackerHitPlane* operator->();
  TrackerHitPlaneCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


class TrackerHitPlaneMutableCollectionIterator {
public:
  TrackerHitPlaneMutableCollectionIterator(size_t index, const TrackerHitPlaneObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerHitPlaneMutableCollectionIterator(const TrackerHitPlaneMutableCollectionIterator&) = delete;
  TrackerHitPlaneMutableCollectionIterator& operator=(const TrackerHitPlaneMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerHitPlaneMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerHitPlane operator*();
  MutableTrackerHitPlane* operator->();
  TrackerHitPlaneMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerHitPlane m_object;
  const TrackerHitPlaneObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerHitPlaneCollection : public podio::CollectionBase {
public:
  using value_type = TrackerHitPlane;
  using const_iterator = TrackerHitPlaneCollectionIterator;
  using iterator = TrackerHitPlaneMutableCollectionIterator;

  TrackerHitPlaneCollection();
  TrackerHitPlaneCollection(TrackerHitPlaneCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerHitPlaneCollection(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection& operator=(const TrackerHitPlaneCollection& ) = delete;
  TrackerHitPlaneCollection(TrackerHitPlaneCollection&&) = default;
  TrackerHitPlaneCollection& operator=(TrackerHitPlaneCollection&&) = default;

//  TrackerHitPlaneCollection(TrackerHitPlaneVector* data, uint32_t collectionID);
  ~TrackerHitPlaneCollection();

  constexpr static auto typeName = "edm4hep::TrackerHitPlaneCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerHitPlane";
  constexpr static auto dataTypeName = "edm4hep::TrackerHitPlaneData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerHitPlaneCollection* operator->() { return (TrackerHitPlaneCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerHitPlane create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerHitPlane create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerHitPlane operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerHitPlane operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerHitPlane at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerHitPlane at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerHitPlane object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerHitPlaneObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> eDep(const size_t nElem = 0) const;
  std::vector<float> eDepError(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> u(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector2f> v(const size_t nElem = 0) const;
  std::vector<float> du(const size_t nElem = 0) const;
  std::vector<float> dv(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerHitPlaneCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerHitPlaneCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerHitPlaneCollection& v);

template<typename... Args>
MutableTrackerHitPlane TrackerHitPlaneCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerHitPlaneObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackerHitPlaneData} constructor
  obj->m_rawHits = new std::vector<edm4hep::ObjectID>();
  m_storage.createRelations(obj);
  return MutableTrackerHitPlane(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerHitPlaneCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerHitPlane_CollectionData_H
#define EDM4HEP_TrackerHitPlane_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerHitPlaneData.h"
#include "edm4hep/TrackerHitPlaneObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerHitPlaneObjPointerContainer = std::deque<TrackerHitPlaneObj*>;
using TrackerHitPlaneDataContainer = std::vector<TrackerHitPlaneData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerHitPlaneCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerHitPlaneObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerHitPlaneCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerHitPlaneCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerHitPlaneCollectionData(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData& operator=(const TrackerHitPlaneCollectionData&) = delete;
  TrackerHitPlaneCollectionData(TrackerHitPlaneCollectionData&& other) = default;
  TrackerHitPlaneCollectionData& operator=(TrackerHitPlaneCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerHitPlaneCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackerHitPlaneObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<edm4hep::ObjectID> m_vec_rawHits{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::ObjectID>> m_vecs_rawHits{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerHitPlaneDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesDATA_H
#define EDM4HEP_RawTimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RawTimeSeriesData
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeriesData {
public:
  std::uint64_t cellID{}; ///< detector specific cell id.
  std::int32_t quality{}; ///< quality flag for the hit.
  float time{}; ///< time of the hit [ns].
  float charge{}; ///< integrated charge of the hit [fC].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int adcCounts_begin{};
  unsigned int adcCounts_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_H
#define EDM4HEP_RawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRawTimeSeries;
class RawTimeSeriesCollection;

/** @class RawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class RawTimeSeries {

  friend class MutableRawTimeSeries;
  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesCollectionIterator;

public:
  using mutable_type = MutableRawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  RawTimeSeries();
  RawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  RawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  RawTimeSeries(const RawTimeSeries& other);

  /// copy-assignment operator
  RawTimeSeries& operator=(RawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~RawTimeSeries();


public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RawTimeSeries& a, RawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRawTimeSeries_H
#define EDM4HEP_MutableRawTimeSeries_H

#include "edm4hep/RawTimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RawTimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRawTimeSeries
 *  Raw data of a detector readout
 *  @author: F.Gaede, DESY
 */
class MutableRawTimeSeries {

  friend class RawTimeSeriesCollection;
  friend class RawTimeSeriesMutableCollectionIterator;
  friend class RawTimeSeries;

public:
  using object_type = RawTimeSeries;
  using collection_type = RawTimeSeriesCollection;

  /// default constructor
  MutableRawTimeSeries();
  MutableRawTimeSeries(std::uint64_t cellID, std::int32_t quality, float time, float charge, float interval);

  /// constructor from existing RawTimeSeriesObj
  MutableRawTimeSeries(RawTimeSeriesObj* obj);

  /// copy constructor
  MutableRawTimeSeries(const MutableRawTimeSeries& other);

  /// copy-assignment operator
  MutableRawTimeSeries& operator=(MutableRawTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRawTimeSeries clone() const;

  /// destructor
  ~MutableRawTimeSeries();

  /// conversion to const object
  operator RawTimeSeries() const;

public:

  /// Access the detector specific cell id.
  const std::uint64_t& getCellID() const;

  /// Access the quality flag for the hit.
  const std::int32_t& getQuality() const;

  /// Access the time of the hit [ns].
  const float& getTime() const;

  /// Access the integrated charge of the hit [fC].
  const float& getCharge() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the detector specific cell id.
  void setCellID(std::uint64_t value);

  /// Set the quality flag for the hit.
  void setQuality(std::int32_t value);

  /// Set the time of the hit [ns].
  void setTime(float value);

  /// Set the integrated charge of the hit [fC].
  void setCharge(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAdcCounts(std::int32_t);
  std::size_t adcCounts_size() const;
  std::int32_t getAdcCounts(std::size_t) const;
  std::vector<std::int32_t>::const_iterator adcCounts_begin() const;
  std::vector<std::int32_t>::const_iterator adcCounts_end() const;
  podio::RelationRange<std::int32_t> getAdcCounts() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RawTimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRawTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const RawTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRawTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRawTimeSeries& a, MutableRawTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RawTimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRawTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesOBJ_H
#define EDM4HEP_RawTimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RawTimeSeries;

class RawTimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  RawTimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  RawTimeSeriesObj(const RawTimeSeriesObj&);
  /// constructor from ObjectID and RawTimeSeriesData
  /// does not initialize the internal relation containers
  RawTimeSeriesObj(const podio::ObjectID id, RawTimeSeriesData data);
  /// No assignment operator
  RawTimeSeriesObj& operator=(const RawTimeSeriesObj&) = delete;
  virtual ~RawTimeSeriesObj();

public:
  RawTimeSeriesData data;
  std::vector<std::int32_t>* m_adcCounts{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeriesCollection_H
#define EDM4HEP_RawTimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeries.h"
#include "edm4hep/MutableRawTimeSeries.h"
#include "edm4hep/RawTimeSeriesObj.h"
#include "edm4hep/RawTimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RawTimeSeriesCollectionIterator {
public:
  RawTimeSeriesCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesCollectionIterator(const RawTimeSeriesCollectionIterator&) = delete;
  RawTimeSeriesCollectionIterator& operator=(const RawTimeSeriesCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RawTimeSeries operator*();
  RawTimeSeries* operator->();
  RawTimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  RawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


class RawTimeSeriesMutableCollectionIterator {
public:
  RawTimeSeriesMutableCollectionIterator(size_t index, const RawTimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RawTimeSeriesMutableCollectionIterator(const RawTimeSeriesMutableCollectionIterator&) = delete;
  RawTimeSeriesMutableCollectionIterator& operator=(const RawTimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RawTimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRawTimeSeries operator*();
  MutableRawTimeSeries* operator->();
  RawTimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRawTimeSeries m_object;
  const RawTimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RawTimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = RawTimeSeries;
  using const_iterator = RawTimeSeriesCollectionIterator;
  using iterator = RawTimeSeriesMutableCollectionIterator;

  RawTimeSeriesCollection();
  RawTimeSeriesCollection(RawTimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RawTimeSeriesCollection(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection& operator=(const RawTimeSeriesCollection& ) = delete;
  RawTimeSeriesCollection(RawTimeSeriesCollection&&) = default;
  RawTimeSeriesCollection& operator=(RawTimeSeriesCollection&&) = default;

//  RawTimeSeriesCollection(RawTimeSeriesVector* data, uint32_t collectionID);
  ~RawTimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::RawTimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::RawTimeSeries";
  constexpr static auto dataTypeName = "edm4hep::RawTimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RawTimeSeriesCollection* operator->() { return (RawTimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRawTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRawTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RawTimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRawTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  RawTimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableRawTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(RawTimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RawTimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<std::int32_t> quality(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RawTimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RawTimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RawTimeSeriesCollection& v);

template<typename... Args>
MutableRawTimeSeries RawTimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RawTimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RawTimeSeriesData} constructor
  obj->m_adcCounts = new std::vector<std::int32_t>();
  m_storage.createRelations(obj);
  return MutableRawTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RawTimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RawTimeSeries_CollectionData_H
#define EDM4HEP_RawTimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/RawTimeSeriesData.h"
#include "edm4hep/RawTimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RawTimeSeriesObjPointerContainer = std::deque<RawTimeSeriesObj*>;
using RawTimeSeriesDataContainer = std::vector<RawTimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RawTimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RawTimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RawTimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RawTimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RawTimeSeriesCollectionData(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData& operator=(const RawTimeSeriesCollectionData&) = delete;
  RawTimeSeriesCollectionData(RawTimeSeriesCollectionData&& other) = default;
  RawTimeSeriesCollectionData& operator=(RawTimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RawTimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RawTimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_adcCounts{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_adcCounts{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RawTimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackDATA_H
#define EDM4HEP_TrackDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TrackData
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class TrackData {
public:
  std::int32_t type{}; ///< flagword that defines the type of track.Bits 16-31 are used internally
  float chi2{}; ///< Chi^2 of the track fit
  std::int32_t ndf{}; ///< number of degrees of freedom of the track fit
  float dEdx{}; ///< dEdx of the track.
  float dEdxError{}; ///< error of dEdx.
  float radiusOfInnermostHit{}; ///< radius of the innermost hit that has been used in the track fit

  unsigned int subdetectorHitNumbers_begin{};
  unsigned int subdetectorHitNumbers_end{};
  unsigned int trackStates_begin{};
  unsigned int trackStates_end{};
  unsigned int dxQuantities_begin{};
  unsigned int dxQuantities_end{};
  unsigned int trackerHits_begin{};
  unsigned int trackerHits_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_H
#define EDM4HEP_Track_H

#include "edm4hep/TrackObj.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTrack;
class TrackCollection;

/** @class Track
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class Track {

  friend class MutableTrack;
  friend class TrackCollection;
  friend class TrackCollectionIterator;

public:
  using mutable_type = MutableTrack;
  using collection_type = TrackCollection;

  /// default constructor
  Track();
  Track(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  Track(TrackObj* obj);

  /// copy constructor
  Track(const Track& other);

  /// copy-assignment operator
  Track& operator=(Track other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~Track();


public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Track& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrack& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Track& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Track& a, Track& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Track& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Track& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrack_H
#define EDM4HEP_MutableTrack_H

#include "edm4hep/TrackObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Track.h"

#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTrack
 *  Reconstructed track
 *  @author: F.Gaede, DESY
 */
class MutableTrack {

  friend class TrackCollection;
  friend class TrackMutableCollectionIterator;
  friend class Track;

public:
  using object_type = Track;
  using collection_type = TrackCollection;

  /// default constructor
  MutableTrack();
  MutableTrack(std::int32_t type, float chi2, std::int32_t ndf, float dEdx, float dEdxError, float radiusOfInnermostHit);

  /// constructor from existing TrackObj
  MutableTrack(TrackObj* obj);

  /// copy constructor
  MutableTrack(const MutableTrack& other);

  /// copy-assignment operator
  MutableTrack& operator=(MutableTrack other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrack clone() const;

  /// destructor
  ~MutableTrack();

  /// conversion to const object
  operator Track() const;

public:

  /// Access the flagword that defines the type of track.Bits 16-31 are used internally
  const std::int32_t& getType() const;

  /// Access the Chi^2 of the track fit
  const float& getChi2() const;

  /// Access the number of degrees of freedom of the track fit
  const std::int32_t& getNdf() const;

  /// Access the dEdx of the track.
  const float& getDEdx() const;

  /// Access the error of dEdx.
  const float& getDEdxError() const;

  /// Access the radius of the innermost hit that has been used in the track fit
  const float& getRadiusOfInnermostHit() const;



  /// Set the flagword that defines the type of track.Bits 16-31 are used internally
  void setType(std::int32_t value);

  /// Set the Chi^2 of the track fit
  void setChi2(float value);

  /// Set the number of degrees of freedom of the track fit
  void setNdf(std::int32_t value);

  /// Set the dEdx of the track.
  void setDEdx(float value);

  /// Set the error of dEdx.
  void setDEdxError(float value);

  /// Set the radius of the innermost hit that has been used in the track fit
  void setRadiusOfInnermostHit(float value);



  void addToTrackerHits(edm4hep::TrackerHit);
  std::size_t trackerHits_size() const;
  edm4hep::TrackerHit getTrackerHits(std::size_t) const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_begin() const;
  std::vector<edm4hep::TrackerHit>::const_iterator trackerHits_end() const;
  podio::RelationRange<edm4hep::TrackerHit> getTrackerHits() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToSubdetectorHitNumbers(std::int32_t);
  std::size_t subdetectorHitNumbers_size() const;
  std::int32_t getSubdetectorHitNumbers(std::size_t) const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_begin() const;
  std::vector<std::int32_t>::const_iterator subdetectorHitNumbers_end() const;
  podio::RelationRange<std::int32_t> getSubdetectorHitNumbers() const;
  void addToTrackStates(edm4hep::TrackState);
  std::size_t trackStates_size() const;
  edm4hep::TrackState getTrackStates(std::size_t) const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_begin() const;
  std::vector<edm4hep::TrackState>::const_iterator trackStates_end() const;
  podio::RelationRange<edm4hep::TrackState> getTrackStates() const;
  void addToDxQuantities(edm4hep::Quantity);
  std::size_t dxQuantities_size() const;
  edm4hep::Quantity getDxQuantities(std::size_t) const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_begin() const;
  std::vector<edm4hep::Quantity>::const_iterator dxQuantities_end() const;
  podio::RelationRange<edm4hep::Quantity> getDxQuantities() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrack& other) const { return m_obj == other.m_obj; }
  bool operator==(const Track& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrack& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrack& a, MutableTrack& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrack& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackOBJ_H
#define EDM4HEP_TrackOBJ_H

// data model specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Quantity.h"
#include "edm4hep/TrackState.h"
#include "edm4hep/TrackerHit.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class Track;

class TrackObj : public podio::ObjBase {
public:
  /// constructor
  TrackObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackObj(const TrackObj&);
  /// constructor from ObjectID and TrackData
  /// does not initialize the internal relation containers
  TrackObj(const podio::ObjectID id, TrackData data);
  /// No assignment operator
  TrackObj& operator=(const TrackObj&) = delete;
  virtual ~TrackObj();

public:
  TrackData data;
  std::vector<edm4hep::TrackerHit>* m_trackerHits{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<std::int32_t>* m_subdetectorHitNumbers{nullptr};
  std::vector<edm4hep::TrackState>* m_trackStates{nullptr};
  std::vector<edm4hep::Quantity>* m_dxQuantities{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackCollection_H
#define EDM4HEP_TrackCollection_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/Track.h"
#include "edm4hep/MutableTrack.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackCollectionIterator {
public:
  TrackCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackCollectionIterator(const TrackCollectionIterator&) = delete;
  TrackCollectionIterator& operator=(const TrackCollectionIterator&) = delete;

  bool operator!=(const TrackCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Track operator*();
  Track* operator->();
  TrackCollectionIterator& operator++();

private:
  size_t m_index;
  Track m_object;
  const TrackObjPointerContainer* m_collection;
};


class TrackMutableCollectionIterator {
public:
  TrackMutableCollectionIterator(size_t index, const TrackObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackMutableCollectionIterator(const TrackMutableCollectionIterator&) = delete;
  TrackMutableCollectionIterator& operator=(const TrackMutableCollectionIterator&) = delete;

  bool operator!=(const TrackMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrack operator*();
  MutableTrack* operator->();
  TrackMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrack m_object;
  const TrackObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackCollection : public podio::CollectionBase {
public:
  using value_type = Track;
  using const_iterator = TrackCollectionIterator;
  using iterator = TrackMutableCollectionIterator;

  TrackCollection();
  TrackCollection(TrackCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackCollection(const TrackCollection& ) = delete;
  TrackCollection& operator=(const TrackCollection& ) = delete;
  TrackCollection(TrackCollection&&) = default;
  TrackCollection& operator=(TrackCollection&&) = default;

//  TrackCollection(TrackVector* data, uint32_t collectionID);
  ~TrackCollection();

  constexpr static auto typeName = "edm4hep::TrackCollection";
  constexpr static auto valueTypeName = "edm4hep::Track";
  constexpr static auto dataTypeName = "edm4hep::TrackData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackCollection* operator->() { return (TrackCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrack create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrack create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Track operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrack operator[](std::size_t index);
  /// Returns the const object of given index
  Track at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrack at(std::size_t index);


  /// Append object to the collection
  void push_back(Track object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<std::int32_t> ndf(const size_t nElem = 0) const;
  std::vector<float> dEdx(const size_t nElem = 0) const;
  std::vector<float> dEdxError(const size_t nElem = 0) const;
  std::vector<float> radiusOfInnermostHit(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackCollection& v);

template<typename... Args>
MutableTrack TrackCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TrackData} constructor
  obj->m_trackerHits = new std::vector<edm4hep::TrackerHit>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_subdetectorHitNumbers = new std::vector<std::int32_t>();
  obj->m_trackStates = new std::vector<edm4hep::TrackState>();
  obj->m_dxQuantities = new std::vector<edm4hep::Quantity>();
  m_storage.createRelations(obj);
  return MutableTrack(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Track_CollectionData_H
#define EDM4HEP_Track_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackData.h"
#include "edm4hep/TrackObj.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackObjPointerContainer = std::deque<TrackObj*>;
using TrackDataContainer = std::vector<TrackData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackCollectionData(const TrackCollectionData&) = delete;
  TrackCollectionData& operator=(const TrackCollectionData&) = delete;
  TrackCollectionData(TrackCollectionData&& other) = default;
  TrackCollectionData& operator=(TrackCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TrackObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_trackerHits;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerHit>> m_rel_trackerHits_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members
  podio::UVecPtr<std::int32_t> m_vec_subdetectorHitNumbers{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::int32_t>> m_vecs_subdetectorHitNumbers{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::TrackState> m_vec_trackStates{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::TrackState>> m_vecs_trackStates{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Quantity> m_vec_dxQuantities{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Quantity>> m_vecs_dxQuantities{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexDATA_H
#define EDM4HEP_VertexDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class VertexData
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class VertexData {
public:
  std::int32_t primary{}; ///< boolean flag, if vertex is the primary vertex of the event
  float chi2{}; ///< chi-squared of the vertex fit
  float probability{}; ///< probability of the vertex fit
  ::edm4hep::Vector3f position{}; ///< [mm] position of the vertex.
  std::array<float, 6> covMatrix{}; ///< covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::int32_t algorithmType{}; ///< type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.

  unsigned int parameters_begin{};
  unsigned int parameters_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_H
#define EDM4HEP_Vertex_H

#include "edm4hep/VertexObj.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {

class MutableVertex;
class VertexCollection;

/** @class Vertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class Vertex {

  friend class MutableVertex;
  friend class VertexCollection;
  friend class VertexCollectionIterator;

public:
  using mutable_type = MutableVertex;
  using collection_type = VertexCollection;

  /// default constructor
  Vertex();
  Vertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  Vertex(VertexObj* obj);

  /// copy constructor
  Vertex(const Vertex& other);

  /// copy-assignment operator
  Vertex& operator=(Vertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~Vertex();


public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const Vertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableVertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const Vertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(Vertex& a, Vertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const Vertex& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const Vertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableVertex_H
#define EDM4HEP_MutableVertex_H

#include "edm4hep/VertexObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/Vertex.h"

#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
}


namespace edm4hep {


/** @class MutableVertex
 *  Vertex
 *  @author: F.Gaede, DESY
 */
class MutableVertex {

  friend class VertexCollection;
  friend class VertexMutableCollectionIterator;
  friend class Vertex;

public:
  using object_type = Vertex;
  using collection_type = VertexCollection;

  /// default constructor
  MutableVertex();
  MutableVertex(std::int32_t primary, float chi2, float probability, edm4hep::Vector3f position, std::array<float, 6> covMatrix, std::int32_t algorithmType);

  /// constructor from existing VertexObj
  MutableVertex(VertexObj* obj);

  /// copy constructor
  MutableVertex(const MutableVertex& other);

  /// copy-assignment operator
  MutableVertex& operator=(MutableVertex other);

  /// create a mutable deep-copy of the object with identical relations
  MutableVertex clone() const;

  /// destructor
  ~MutableVertex();

  /// conversion to const object
  operator Vertex() const;

public:

  /// Access the boolean flag, if vertex is the primary vertex of the event
  const std::int32_t& getPrimary() const;

  /// Access the chi-squared of the vertex fit
  const float& getChi2() const;

  /// Access the probability of the vertex fit
  const float& getProbability() const;

  /// Access the [mm] position of the vertex.
  const edm4hep::Vector3f& getPosition() const;

  /// Access the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const std::array<float, 6>& getCovMatrix() const;
  /// Access item i of the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  const float& getCovMatrix(size_t i) const;
  /// Access the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  const std::int32_t& getAlgorithmType() const;


  /// Access the reconstructed particle associated to this vertex.
  const edm4hep::ReconstructedParticle getAssociatedParticle() const;

  /// Set the boolean flag, if vertex is the primary vertex of the event
  void setPrimary(std::int32_t value);

  /// Set the chi-squared of the vertex fit
  void setChi2(float value);

  /// Set the probability of the vertex fit
  void setProbability(float value);

  /// Set the [mm] position of the vertex.
  void setPosition(edm4hep::Vector3f value);
  /// Get reference to [mm] position of the vertex.
  edm4hep::Vector3f& position();

  /// Set the covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  void setCovMatrix(std::array<float, 6> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )
  std::array<float, 6>& covMatrix();

  /// Set the type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType.
  void setAlgorithmType(std::int32_t value);


  /// Set the reconstructed particle associated to this vertex.
  void setAssociatedParticle(edm4hep::ReconstructedParticle value);

  void addToParameters(float);
  std::size_t parameters_size() const;
  float getParameters(std::size_t) const;
  std::vector<float>::const_iterator parameters_begin() const;
  std::vector<float>::const_iterator parameters_end() const;
  podio::RelationRange<float> getParameters() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from VertexObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableVertex& other) const { return m_obj == other.m_obj; }
  bool operator==(const Vertex& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableVertex& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableVertex& a, MutableVertex& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  VertexObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableVertex& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexOBJ_H
#define EDM4HEP_VertexOBJ_H

// data model specific includes
#include "edm4hep/VertexData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class ReconstructedParticle;
}


namespace edm4hep {

class Vertex;

class VertexObj : public podio::ObjBase {
public:
  /// constructor
  VertexObj();
  /// copy constructor (does a deep-copy of relation containers)
  VertexObj(const VertexObj&);
  /// constructor from ObjectID and VertexData
  /// does not initialize the internal relation containers
  VertexObj(const podio::ObjectID id, VertexData data);
  /// No assignment operator
  VertexObj& operator=(const VertexObj&) = delete;
  virtual ~VertexObj();

public:
  VertexData data;
  edm4hep::ReconstructedParticle* m_associatedParticle{nullptr};
  std::vector<float>* m_parameters{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_VertexCollection_H
#define EDM4HEP_VertexCollection_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/Vertex.h"
#include "edm4hep/MutableVertex.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/VertexCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class VertexCollectionIterator {
public:
  VertexCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexCollectionIterator(const VertexCollectionIterator&) = delete;
  VertexCollectionIterator& operator=(const VertexCollectionIterator&) = delete;

  bool operator!=(const VertexCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  Vertex operator*();
  Vertex* operator->();
  VertexCollectionIterator& operator++();

private:
  size_t m_index;
  Vertex m_object;
  const VertexObjPointerContainer* m_collection;
};


class VertexMutableCollectionIterator {
public:
  VertexMutableCollectionIterator(size_t index, const VertexObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  VertexMutableCollectionIterator(const VertexMutableCollectionIterator&) = delete;
  VertexMutableCollectionIterator& operator=(const VertexMutableCollectionIterator&) = delete;

  bool operator!=(const VertexMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const VertexMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableVertex operator*();
  MutableVertex* operator->();
  VertexMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableVertex m_object;
  const VertexObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class VertexCollection : public podio::CollectionBase {
public:
  using value_type = Vertex;
  using const_iterator = VertexCollectionIterator;
  using iterator = VertexMutableCollectionIterator;

  VertexCollection();
  VertexCollection(VertexCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  VertexCollection(const VertexCollection& ) = delete;
  VertexCollection& operator=(const VertexCollection& ) = delete;
  VertexCollection(VertexCollection&&) = default;
  VertexCollection& operator=(VertexCollection&&) = default;

//  VertexCollection(VertexVector* data, uint32_t collectionID);
  ~VertexCollection();

  constexpr static auto typeName = "edm4hep::VertexCollection";
  constexpr static auto valueTypeName = "edm4hep::Vertex";
  constexpr static auto dataTypeName = "edm4hep::VertexData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  VertexCollection* operator->() { return (VertexCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableVertex create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableVertex create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  Vertex operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableVertex operator[](std::size_t index);
  /// Returns the const object of given index
  Vertex at(std::size_t index) const;
  /// Returns the object of given index
  MutableVertex at(std::size_t index);


  /// Append object to the collection
  void push_back(Vertex object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (VertexObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> primary(const size_t nElem = 0) const;
  std::vector<float> chi2(const size_t nElem = 0) const;
  std::vector<float> probability(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> position(const size_t nElem = 0) const;
  std::vector<std::array<float, 6>> covMatrix(const size_t nElem = 0) const;
  std::vector<std::int32_t> algorithmType(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class VertexCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable VertexCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const VertexCollection& v);

template<typename... Args>
MutableVertex VertexCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new VertexObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, VertexData} constructor
  obj->m_parameters = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableVertex(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const VertexCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_Vertex_CollectionData_H
#define EDM4HEP_Vertex_CollectionData_H

// datamodel specific includes
#include "edm4hep/VertexData.h"
#include "edm4hep/VertexObj.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using VertexObjPointerContainer = std::deque<VertexObj*>;
using VertexDataContainer = std::vector<VertexData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class VertexCollectionData {
public:
  /**
   * The Objs of this collection
   */
  VertexObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  VertexCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  VertexCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  VertexCollectionData(const VertexCollectionData&) = delete;
  VertexCollectionData& operator=(const VertexCollectionData&) = delete;
  VertexCollectionData(VertexCollectionData&& other) = default;
  VertexCollectionData& operator=(VertexCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~VertexCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(VertexObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_associatedParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<float> m_vec_parameters{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_parameters{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<VertexDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleDATA_H
#define EDM4HEP_ReconstructedParticleDATA_H

#include "edm4hep/Vector3f.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class ReconstructedParticleData
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticleData {
public:
  std::int32_t type{}; ///< type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  float energy{}; ///< [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f momentum{}; ///< [GeV] particle momentum. Four momentum state is not kept consistent internally.
  ::edm4hep::Vector3f referencePoint{}; ///< [mm] reference, i.e. where the particle has been measured
  float charge{}; ///< charge of the reconstructed particle.
  float mass{}; ///< [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  float goodnessOfPID{}; ///< overall goodness of the PID on a scale of [0;1]
  std::array<float, 10> covMatrix{}; ///< cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##

  unsigned int clusters_begin{};
  unsigned int clusters_end{};
  unsigned int tracks_begin{};
  unsigned int tracks_end{};
  unsigned int particles_begin{};
  unsigned int particles_end{};
  unsigned int particleIDs_begin{};
  unsigned int particleIDs_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_H
#define EDM4HEP_ReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {

class MutableReconstructedParticle;
class ReconstructedParticleCollection;

/** @class ReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class ReconstructedParticle {

  friend class MutableReconstructedParticle;
  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleCollectionIterator;

public:
  using mutable_type = MutableReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  ReconstructedParticle();
  ReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  ReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  ReconstructedParticle(const ReconstructedParticle& other);

  /// copy-assignment operator
  ReconstructedParticle& operator=(ReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~ReconstructedParticle();


public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const ReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const ReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(ReconstructedParticle& a, ReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticle& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableReconstructedParticle_H
#define EDM4HEP_MutableReconstructedParticle_H

#include "edm4hep/ReconstructedParticleObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/ReconstructedParticle.h"

#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vector3f.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Vertex;
class MutableVertex;
class ParticleID;
class MutableParticleID;
}


namespace edm4hep {


/** @class MutableReconstructedParticle
 *  Reconstructed Particle
 *  @author: F.Gaede, DESY
 */
class MutableReconstructedParticle {

  friend class ReconstructedParticleCollection;
  friend class ReconstructedParticleMutableCollectionIterator;
  friend class ReconstructedParticle;

public:
  using object_type = ReconstructedParticle;
  using collection_type = ReconstructedParticleCollection;

  /// default constructor
  MutableReconstructedParticle();
  MutableReconstructedParticle(std::int32_t type, float energy, edm4hep::Vector3f momentum, edm4hep::Vector3f referencePoint, float charge, float mass, float goodnessOfPID, std::array<float, 10> covMatrix);

  /// constructor from existing ReconstructedParticleObj
  MutableReconstructedParticle(ReconstructedParticleObj* obj);

  /// copy constructor
  MutableReconstructedParticle(const MutableReconstructedParticle& other);

  /// copy-assignment operator
  MutableReconstructedParticle& operator=(MutableReconstructedParticle other);

  /// create a mutable deep-copy of the object with identical relations
  MutableReconstructedParticle clone() const;

  /// destructor
  ~MutableReconstructedParticle();

  /// conversion to const object
  operator ReconstructedParticle() const;

public:

  /// Access the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  const std::int32_t& getType() const;

  /// Access the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  const float& getEnergy() const;

  /// Access the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  const edm4hep::Vector3f& getMomentum() const;

  /// Access the [mm] reference, i.e. where the particle has been measured
  const edm4hep::Vector3f& getReferencePoint() const;

  /// Access the charge of the reconstructed particle.
  const float& getCharge() const;

  /// Access the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  const float& getMass() const;

  /// Access the overall goodness of the PID on a scale of [0;1]
  const float& getGoodnessOfPID() const;

  /// Access the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const std::array<float, 10>& getCovMatrix() const;
  /// Access item i of the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  const float& getCovMatrix(size_t i) const;

  /// Access the start vertex associated to this particle
  const edm4hep::Vertex getStartVertex() const;
  /// Access the particle Id used for the kinematics of this particle
  const edm4hep::ParticleID getParticleIDUsed() const;

  /// Set the type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.
  void setType(std::int32_t value);

  /// Set the [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.
  void setEnergy(float value);

  /// Set the [GeV] particle momentum. Four momentum state is not kept consistent internally.
  void setMomentum(edm4hep::Vector3f value);
  /// Get reference to [GeV] particle momentum. Four momentum state is not kept consistent internally.
  edm4hep::Vector3f& momentum();

  /// Set the [mm] reference, i.e. where the particle has been measured
  void setReferencePoint(edm4hep::Vector3f value);
  /// Get reference to [mm] reference, i.e. where the particle has been measured
  edm4hep::Vector3f& referencePoint();

  /// Set the charge of the reconstructed particle.
  void setCharge(float value);

  /// Set the [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.
  void setMass(float value);

  /// Set the overall goodness of the PID on a scale of [0;1]
  void setGoodnessOfPID(float value);

  /// Set the cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  void setCovMatrix(std::array<float, 10> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##
  std::array<float, 10>& covMatrix();


  /// Set the start vertex associated to this particle
  void setStartVertex(edm4hep::Vertex value);
  /// Set the particle Id used for the kinematics of this particle
  void setParticleIDUsed(edm4hep::ParticleID value);

  void addToClusters(edm4hep::Cluster);
  std::size_t clusters_size() const;
  edm4hep::Cluster getClusters(std::size_t) const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_begin() const;
  std::vector<edm4hep::Cluster>::const_iterator clusters_end() const;
  podio::RelationRange<edm4hep::Cluster> getClusters() const;
  void addToTracks(edm4hep::Track);
  std::size_t tracks_size() const;
  edm4hep::Track getTracks(std::size_t) const;
  std::vector<edm4hep::Track>::const_iterator tracks_begin() const;
  std::vector<edm4hep::Track>::const_iterator tracks_end() const;
  podio::RelationRange<edm4hep::Track> getTracks() const;
  void addToParticles(edm4hep::ReconstructedParticle);
  std::size_t particles_size() const;
  edm4hep::ReconstructedParticle getParticles(std::size_t) const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_begin() const;
  std::vector<edm4hep::ReconstructedParticle>::const_iterator particles_end() const;
  podio::RelationRange<edm4hep::ReconstructedParticle> getParticles() const;
  void addToParticleIDs(edm4hep::ParticleID);
  std::size_t particleIDs_size() const;
  edm4hep::ParticleID getParticleIDs(std::size_t) const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_begin() const;
  std::vector<edm4hep::ParticleID>::const_iterator particleIDs_end() const;
  podio::RelationRange<edm4hep::ParticleID> getParticleIDs() const;

 bool isCompound() const { return particles_size() > 0 ;}
 

 //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.
 //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }
 

  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from ReconstructedParticleObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableReconstructedParticle& other) const { return m_obj == other.m_obj; }
  bool operator==(const ReconstructedParticle& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableReconstructedParticle& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableReconstructedParticle& a, MutableReconstructedParticle& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  ReconstructedParticleObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableReconstructedParticle& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleOBJ_H
#define EDM4HEP_ReconstructedParticleOBJ_H

// data model specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Vertex;
class ParticleID;
}


namespace edm4hep {

class ReconstructedParticle;

class ReconstructedParticleObj : public podio::ObjBase {
public:
  /// constructor
  ReconstructedParticleObj();
  /// copy constructor (does a deep-copy of relation containers)
  ReconstructedParticleObj(const ReconstructedParticleObj&);
  /// constructor from ObjectID and ReconstructedParticleData
  /// does not initialize the internal relation containers
  ReconstructedParticleObj(const podio::ObjectID id, ReconstructedParticleData data);
  /// No assignment operator
  ReconstructedParticleObj& operator=(const ReconstructedParticleObj&) = delete;
  virtual ~ReconstructedParticleObj();

public:
  ReconstructedParticleData data;
  edm4hep::Vertex* m_startVertex{nullptr};
  edm4hep::ParticleID* m_particleIDUsed{nullptr};
  std::vector<edm4hep::Cluster>* m_clusters{nullptr};
  std::vector<edm4hep::Track>* m_tracks{nullptr};
  std::vector<edm4hep::ReconstructedParticle>* m_particles{nullptr};
  std::vector<edm4hep::ParticleID>* m_particleIDs{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticleCollection_H
#define EDM4HEP_ReconstructedParticleCollection_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/MutableReconstructedParticle.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/ReconstructedParticleCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class ReconstructedParticleCollectionIterator {
public:
  ReconstructedParticleCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleCollectionIterator(const ReconstructedParticleCollectionIterator&) = delete;
  ReconstructedParticleCollectionIterator& operator=(const ReconstructedParticleCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  ReconstructedParticle operator*();
  ReconstructedParticle* operator->();
  ReconstructedParticleCollectionIterator& operator++();

private:
  size_t m_index;
  ReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


class ReconstructedParticleMutableCollectionIterator {
public:
  ReconstructedParticleMutableCollectionIterator(size_t index, const ReconstructedParticleObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  ReconstructedParticleMutableCollectionIterator(const ReconstructedParticleMutableCollectionIterator&) = delete;
  ReconstructedParticleMutableCollectionIterator& operator=(const ReconstructedParticleMutableCollectionIterator&) = delete;

  bool operator!=(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const ReconstructedParticleMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableReconstructedParticle operator*();
  MutableReconstructedParticle* operator->();
  ReconstructedParticleMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableReconstructedParticle m_object;
  const ReconstructedParticleObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class ReconstructedParticleCollection : public podio::CollectionBase {
public:
  using value_type = ReconstructedParticle;
  using const_iterator = ReconstructedParticleCollectionIterator;
  using iterator = ReconstructedParticleMutableCollectionIterator;

  ReconstructedParticleCollection();
  ReconstructedParticleCollection(ReconstructedParticleCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  ReconstructedParticleCollection(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection& operator=(const ReconstructedParticleCollection& ) = delete;
  ReconstructedParticleCollection(ReconstructedParticleCollection&&) = default;
  ReconstructedParticleCollection& operator=(ReconstructedParticleCollection&&) = default;

//  ReconstructedParticleCollection(ReconstructedParticleVector* data, uint32_t collectionID);
  ~ReconstructedParticleCollection();

  constexpr static auto typeName = "edm4hep::ReconstructedParticleCollection";
  constexpr static auto valueTypeName = "edm4hep::ReconstructedParticle";
  constexpr static auto dataTypeName = "edm4hep::ReconstructedParticleData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  ReconstructedParticleCollection* operator->() { return (ReconstructedParticleCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableReconstructedParticle create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableReconstructedParticle create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  ReconstructedParticle operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableReconstructedParticle operator[](std::size_t index);
  /// Returns the const object of given index
  ReconstructedParticle at(std::size_t index) const;
  /// Returns the object of given index
  MutableReconstructedParticle at(std::size_t index);


  /// Append object to the collection
  void push_back(ReconstructedParticle object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (ReconstructedParticleObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::int32_t> type(const size_t nElem = 0) const;
  std::vector<float> energy(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> momentum(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3f> referencePoint(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<float> mass(const size_t nElem = 0) const;
  std::vector<float> goodnessOfPID(const size_t nElem = 0) const;
  std::vector<std::array<float, 10>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class ReconstructedParticleCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable ReconstructedParticleCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const ReconstructedParticleCollection& v);

template<typename... Args>
MutableReconstructedParticle ReconstructedParticleCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new ReconstructedParticleObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, ReconstructedParticleData} constructor
  obj->m_clusters = new std::vector<edm4hep::Cluster>();
  obj->m_tracks = new std::vector<edm4hep::Track>();
  obj->m_particles = new std::vector<edm4hep::ReconstructedParticle>();
  obj->m_particleIDs = new std::vector<edm4hep::ParticleID>();
  m_storage.createRelations(obj);
  return MutableReconstructedParticle(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const ReconstructedParticleCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_ReconstructedParticle_CollectionData_H
#define EDM4HEP_ReconstructedParticle_CollectionData_H

// datamodel specific includes
#include "edm4hep/ReconstructedParticleData.h"
#include "edm4hep/ReconstructedParticleObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/ParticleID.h"
#include "edm4hep/Track.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using ReconstructedParticleObjPointerContainer = std::deque<ReconstructedParticleObj*>;
using ReconstructedParticleDataContainer = std::vector<ReconstructedParticleData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class ReconstructedParticleCollectionData {
public:
  /**
   * The Objs of this collection
   */
  ReconstructedParticleObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  ReconstructedParticleCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  ReconstructedParticleCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  ReconstructedParticleCollectionData(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData& operator=(const ReconstructedParticleCollectionData&) = delete;
  ReconstructedParticleCollectionData(ReconstructedParticleCollectionData&& other) = default;
  ReconstructedParticleCollectionData& operator=(ReconstructedParticleCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~ReconstructedParticleCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(ReconstructedParticleObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_clusters;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Cluster>> m_rel_clusters_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Track> m_rel_tracks;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::Track>> m_rel_tracks_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_particles;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ReconstructedParticle>> m_rel_particles_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDs;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::ParticleID>> m_rel_particleIDs_tmp{}; ///< Relation buffer for internal book-keeping
  podio::UVecPtr<edm4hep::Vertex> m_rel_startVertex{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::ParticleID> m_rel_particleIDUsed{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<ReconstructedParticleDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationDATA_H
#define EDM4HEP_MCRecoParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoParticleAssociationData
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_H
#define EDM4HEP_MCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoParticleAssociation;
class MCRecoParticleAssociationCollection;

/** @class MCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoParticleAssociation {

  friend class MutableMCRecoParticleAssociation;
  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MCRecoParticleAssociation();
  MCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MCRecoParticleAssociation(const MCRecoParticleAssociation& other);

  /// copy-assignment operator
  MCRecoParticleAssociation& operator=(MCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MCRecoParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoParticleAssociation& a, MCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoParticleAssociation_H
#define EDM4HEP_MutableMCRecoParticleAssociation_H

#include "edm4hep/MCRecoParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoParticleAssociation
 *  Used to keep track of the correspondence between MC and reconstructed particles
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoParticleAssociation {

  friend class MCRecoParticleAssociationCollection;
  friend class MCRecoParticleAssociationMutableCollectionIterator;
  friend class MCRecoParticleAssociation;

public:
  using object_type = MCRecoParticleAssociation;
  using collection_type = MCRecoParticleAssociationCollection;

  /// default constructor
  MutableMCRecoParticleAssociation();
  MutableMCRecoParticleAssociation(float weight);

  /// constructor from existing MCRecoParticleAssociationObj
  MutableMCRecoParticleAssociation(MCRecoParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoParticleAssociation(const MutableMCRecoParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoParticleAssociation& operator=(MutableMCRecoParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoParticleAssociation();

  /// conversion to const object
  operator MCRecoParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoParticleAssociation& a, MutableMCRecoParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationOBJ_H
#define EDM4HEP_MCRecoParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MCParticle;
}


namespace edm4hep {

class MCRecoParticleAssociation;

class MCRecoParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoParticleAssociationObj(const MCRecoParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoParticleAssociationObj(const podio::ObjectID id, MCRecoParticleAssociationData data);
  /// No assignment operator
  MCRecoParticleAssociationObj& operator=(const MCRecoParticleAssociationObj&) = delete;
  virtual ~MCRecoParticleAssociationObj();

public:
  MCRecoParticleAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociationCollection_H
#define EDM4HEP_MCRecoParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociation.h"
#include "edm4hep/MutableMCRecoParticleAssociation.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCRecoParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoParticleAssociationCollectionIterator {
public:
  MCRecoParticleAssociationCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationCollectionIterator(const MCRecoParticleAssociationCollectionIterator&) = delete;
  MCRecoParticleAssociationCollectionIterator& operator=(const MCRecoParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoParticleAssociation operator*();
  MCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoParticleAssociationMutableCollectionIterator {
public:
  MCRecoParticleAssociationMutableCollectionIterator(size_t index, const MCRecoParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoParticleAssociationMutableCollectionIterator(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoParticleAssociationMutableCollectionIterator& operator=(const MCRecoParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoParticleAssociation operator*();
  MutableMCRecoParticleAssociation* operator->();
  MCRecoParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoParticleAssociation m_object;
  const MCRecoParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoParticleAssociation;
  using const_iterator = MCRecoParticleAssociationCollectionIterator;
  using iterator = MCRecoParticleAssociationMutableCollectionIterator;

  MCRecoParticleAssociationCollection();
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoParticleAssociationCollection(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection& operator=(const MCRecoParticleAssociationCollection& ) = delete;
  MCRecoParticleAssociationCollection(MCRecoParticleAssociationCollection&&) = default;
  MCRecoParticleAssociationCollection& operator=(MCRecoParticleAssociationCollection&&) = default;

//  MCRecoParticleAssociationCollection(MCRecoParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoParticleAssociationCollection* operator->() { return (MCRecoParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoParticleAssociation MCRecoParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoParticleAssociationData.h"
#include "edm4hep/MCRecoParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/ReconstructedParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoParticleAssociationObjPointerContainer = std::deque<MCRecoParticleAssociationObj*>;
using MCRecoParticleAssociationDataContainer = std::vector<MCRecoParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoParticleAssociationCollectionData(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData& operator=(const MCRecoParticleAssociationCollectionData&) = delete;
  MCRecoParticleAssociationCollectionData(MCRecoParticleAssociationCollectionData&& other) = default;
  MCRecoParticleAssociationCollectionData& operator=(MCRecoParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationDATA_H
#define EDM4HEP_MCRecoCaloAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloAssociationData
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_H
#define EDM4HEP_MCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {

class MutableMCRecoCaloAssociation;
class MCRecoCaloAssociationCollection;

/** @class MCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoCaloAssociation {

  friend class MutableMCRecoCaloAssociation;
  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MCRecoCaloAssociation();
  MCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MCRecoCaloAssociation(const MCRecoCaloAssociation& other);

  /// copy-assignment operator
  MCRecoCaloAssociation& operator=(MCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MCRecoCaloAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloAssociation& a, MCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloAssociation_H
#define EDM4HEP_MutableMCRecoCaloAssociation_H

#include "edm4hep/MCRecoCaloAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class SimCalorimeterHit;
class MutableSimCalorimeterHit;
}


namespace edm4hep {


/** @class MutableMCRecoCaloAssociation
 *  Association between a CaloHit and the corresponding simulated CaloHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoCaloAssociation {

  friend class MCRecoCaloAssociationCollection;
  friend class MCRecoCaloAssociationMutableCollectionIterator;
  friend class MCRecoCaloAssociation;

public:
  using object_type = MCRecoCaloAssociation;
  using collection_type = MCRecoCaloAssociationCollection;

  /// default constructor
  MutableMCRecoCaloAssociation();
  MutableMCRecoCaloAssociation(float weight);

  /// constructor from existing MCRecoCaloAssociationObj
  MutableMCRecoCaloAssociation(MCRecoCaloAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloAssociation(const MutableMCRecoCaloAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloAssociation& operator=(MutableMCRecoCaloAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloAssociation();

  /// conversion to const object
  operator MCRecoCaloAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimCalorimeterHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimCalorimeterHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloAssociation& a, MutableMCRecoCaloAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationOBJ_H
#define EDM4HEP_MCRecoCaloAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class SimCalorimeterHit;
}


namespace edm4hep {

class MCRecoCaloAssociation;

class MCRecoCaloAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloAssociationObj(const MCRecoCaloAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloAssociationObj(const podio::ObjectID id, MCRecoCaloAssociationData data);
  /// No assignment operator
  MCRecoCaloAssociationObj& operator=(const MCRecoCaloAssociationObj&) = delete;
  virtual ~MCRecoCaloAssociationObj();

public:
  MCRecoCaloAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::SimCalorimeterHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociationCollection_H
#define EDM4HEP_MCRecoCaloAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociation.h"
#include "edm4hep/MutableMCRecoCaloAssociation.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/MCRecoCaloAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloAssociationCollectionIterator {
public:
  MCRecoCaloAssociationCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationCollectionIterator(const MCRecoCaloAssociationCollectionIterator&) = delete;
  MCRecoCaloAssociationCollectionIterator& operator=(const MCRecoCaloAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloAssociation operator*();
  MCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloAssociationMutableCollectionIterator {
public:
  MCRecoCaloAssociationMutableCollectionIterator(size_t index, const MCRecoCaloAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloAssociationMutableCollectionIterator(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloAssociationMutableCollectionIterator& operator=(const MCRecoCaloAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloAssociation operator*();
  MutableMCRecoCaloAssociation* operator->();
  MCRecoCaloAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloAssociation m_object;
  const MCRecoCaloAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloAssociation;
  using const_iterator = MCRecoCaloAssociationCollectionIterator;
  using iterator = MCRecoCaloAssociationMutableCollectionIterator;

  MCRecoCaloAssociationCollection();
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloAssociationCollection(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection& operator=(const MCRecoCaloAssociationCollection& ) = delete;
  MCRecoCaloAssociationCollection(MCRecoCaloAssociationCollection&&) = default;
  MCRecoCaloAssociationCollection& operator=(MCRecoCaloAssociationCollection&&) = default;

//  MCRecoCaloAssociationCollection(MCRecoCaloAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloAssociationCollection* operator->() { return (MCRecoCaloAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloAssociation MCRecoCaloAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloAssociationData.h"
#include "edm4hep/MCRecoCaloAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/SimCalorimeterHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloAssociationObjPointerContainer = std::deque<MCRecoCaloAssociationObj*>;
using MCRecoCaloAssociationDataContainer = std::vector<MCRecoCaloAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloAssociationCollectionData(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData& operator=(const MCRecoCaloAssociationCollectionData&) = delete;
  MCRecoCaloAssociationCollectionData(MCRecoCaloAssociationCollectionData&& other) = default;
  MCRecoCaloAssociationCollectionData& operator=(MCRecoCaloAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimCalorimeterHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationDATA_H
#define EDM4HEP_MCRecoTrackerAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerAssociationData
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_H
#define EDM4HEP_MCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerAssociation;
class MCRecoTrackerAssociationCollection;

/** @class MCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MCRecoTrackerAssociation {

  friend class MutableMCRecoTrackerAssociation;
  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MCRecoTrackerAssociation();
  MCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerAssociation(const MCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerAssociation& operator=(MCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MCRecoTrackerAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerAssociation& a, MCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerAssociation_H
#define EDM4HEP_MutableMCRecoTrackerAssociation_H

#include "edm4hep/MCRecoTrackerAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHit;
class MutableTrackerHit;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerAssociation
 *  Association between a TrackerHit and the corresponding simulated TrackerHit
 *  @author: C. Bernet, B. Hegner
 */
class MutableMCRecoTrackerAssociation {

  friend class MCRecoTrackerAssociationCollection;
  friend class MCRecoTrackerAssociationMutableCollectionIterator;
  friend class MCRecoTrackerAssociation;

public:
  using object_type = MCRecoTrackerAssociation;
  using collection_type = MCRecoTrackerAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerAssociation();
  MutableMCRecoTrackerAssociation(float weight);

  /// constructor from existing MCRecoTrackerAssociationObj
  MutableMCRecoTrackerAssociation(MCRecoTrackerAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerAssociation(const MutableMCRecoTrackerAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerAssociation& operator=(MutableMCRecoTrackerAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerAssociation();

  /// conversion to const object
  operator MCRecoTrackerAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHit getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHit value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerAssociation& a, MutableMCRecoTrackerAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHit;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerAssociation;

class MCRecoTrackerAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerAssociationObj(const MCRecoTrackerAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerAssociationObj(const podio::ObjectID id, MCRecoTrackerAssociationData data);
  /// No assignment operator
  MCRecoTrackerAssociationObj& operator=(const MCRecoTrackerAssociationObj&) = delete;
  virtual ~MCRecoTrackerAssociationObj();

public:
  MCRecoTrackerAssociationData data;
  edm4hep::TrackerHit* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociationCollection_H
#define EDM4HEP_MCRecoTrackerAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociation.h"
#include "edm4hep/MutableMCRecoTrackerAssociation.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/MCRecoTrackerAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerAssociationCollectionIterator {
public:
  MCRecoTrackerAssociationCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationCollectionIterator(const MCRecoTrackerAssociationCollectionIterator&) = delete;
  MCRecoTrackerAssociationCollectionIterator& operator=(const MCRecoTrackerAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerAssociation operator*();
  MCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerAssociationMutableCollectionIterator {
public:
  MCRecoTrackerAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerAssociationMutableCollectionIterator(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerAssociationMutableCollectionIterator& operator=(const MCRecoTrackerAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerAssociation operator*();
  MutableMCRecoTrackerAssociation* operator->();
  MCRecoTrackerAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerAssociation m_object;
  const MCRecoTrackerAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerAssociation;
  using const_iterator = MCRecoTrackerAssociationCollectionIterator;
  using iterator = MCRecoTrackerAssociationMutableCollectionIterator;

  MCRecoTrackerAssociationCollection();
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerAssociationCollection(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection& operator=(const MCRecoTrackerAssociationCollection& ) = delete;
  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationCollection&&) = default;
  MCRecoTrackerAssociationCollection& operator=(MCRecoTrackerAssociationCollection&&) = default;

//  MCRecoTrackerAssociationCollection(MCRecoTrackerAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerAssociationCollection* operator->() { return (MCRecoTrackerAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerAssociation MCRecoTrackerAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerAssociationData.h"
#include "edm4hep/MCRecoTrackerAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHit.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerAssociationObjPointerContainer = std::deque<MCRecoTrackerAssociationObj*>;
using MCRecoTrackerAssociationDataContainer = std::vector<MCRecoTrackerAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerAssociationCollectionData(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData& operator=(const MCRecoTrackerAssociationCollectionData&) = delete;
  MCRecoTrackerAssociationCollectionData(MCRecoTrackerAssociationCollectionData&& other) = default;
  MCRecoTrackerAssociationCollectionData& operator=(MCRecoTrackerAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackerHitPlaneAssociationData
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {

class MutableMCRecoTrackerHitPlaneAssociation;
class MCRecoTrackerHitPlaneAssociationCollection;

/** @class MCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackerHitPlaneAssociation {

  friend class MutableMCRecoTrackerHitPlaneAssociation;
  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MCRecoTrackerHitPlaneAssociation();
  MCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MCRecoTrackerHitPlaneAssociation(const MCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MCRecoTrackerHitPlaneAssociation& operator=(MCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MCRecoTrackerHitPlaneAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackerHitPlaneAssociation& a, MCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H
#define EDM4HEP_MutableMCRecoTrackerHitPlaneAssociation_H

#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class MutableTrackerHitPlane;
class SimTrackerHit;
class MutableSimTrackerHit;
}


namespace edm4hep {


/** @class MutableMCRecoTrackerHitPlaneAssociation
 *  Association between a TrackerHitPlane and the corresponding simulated TrackerHit
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackerHitPlaneAssociation {

  friend class MCRecoTrackerHitPlaneAssociationCollection;
  friend class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;
  friend class MCRecoTrackerHitPlaneAssociation;

public:
  using object_type = MCRecoTrackerHitPlaneAssociation;
  using collection_type = MCRecoTrackerHitPlaneAssociationCollection;

  /// default constructor
  MutableMCRecoTrackerHitPlaneAssociation();
  MutableMCRecoTrackerHitPlaneAssociation(float weight);

  /// constructor from existing MCRecoTrackerHitPlaneAssociationObj
  MutableMCRecoTrackerHitPlaneAssociation(MCRecoTrackerHitPlaneAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackerHitPlaneAssociation(const MutableMCRecoTrackerHitPlaneAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackerHitPlaneAssociation& operator=(MutableMCRecoTrackerHitPlaneAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackerHitPlaneAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackerHitPlaneAssociation();

  /// conversion to const object
  operator MCRecoTrackerHitPlaneAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::TrackerHitPlane getRec() const;
  /// Access the reference to the simulated hit
  const edm4hep::SimTrackerHit getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::TrackerHitPlane value);
  /// Set the reference to the simulated hit
  void setSim(edm4hep::SimTrackerHit value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackerHitPlaneAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackerHitPlaneAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackerHitPlaneAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackerHitPlaneAssociation& a, MutableMCRecoTrackerHitPlaneAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackerHitPlaneAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackerHitPlaneAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TrackerHitPlane;
class SimTrackerHit;
}


namespace edm4hep {

class MCRecoTrackerHitPlaneAssociation;

class MCRecoTrackerHitPlaneAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackerHitPlaneAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackerHitPlaneAssociationObj(const MCRecoTrackerHitPlaneAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackerHitPlaneAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackerHitPlaneAssociationObj(const podio::ObjectID id, MCRecoTrackerHitPlaneAssociationData data);
  /// No assignment operator
  MCRecoTrackerHitPlaneAssociationObj& operator=(const MCRecoTrackerHitPlaneAssociationObj&) = delete;
  virtual ~MCRecoTrackerHitPlaneAssociationObj();

public:
  MCRecoTrackerHitPlaneAssociationData data;
  edm4hep::TrackerHitPlane* m_rec{nullptr};
  edm4hep::SimTrackerHit* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MutableMCRecoTrackerHitPlaneAssociation.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackerHitPlaneAssociationCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationCollectionIterator(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackerHitPlaneAssociation operator*();
  MCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackerHitPlaneAssociationMutableCollectionIterator {
public:
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(size_t index, const MCRecoTrackerHitPlaneAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackerHitPlaneAssociation operator*();
  MutableMCRecoTrackerHitPlaneAssociation* operator->();
  MCRecoTrackerHitPlaneAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackerHitPlaneAssociation m_object;
  const MCRecoTrackerHitPlaneAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackerHitPlaneAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackerHitPlaneAssociation;
  using const_iterator = MCRecoTrackerHitPlaneAssociationCollectionIterator;
  using iterator = MCRecoTrackerHitPlaneAssociationMutableCollectionIterator;

  MCRecoTrackerHitPlaneAssociationCollection();
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackerHitPlaneAssociationCollection(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(const MCRecoTrackerHitPlaneAssociationCollection& ) = delete;
  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationCollection&&) = default;
  MCRecoTrackerHitPlaneAssociationCollection& operator=(MCRecoTrackerHitPlaneAssociationCollection&&) = default;

//  MCRecoTrackerHitPlaneAssociationCollection(MCRecoTrackerHitPlaneAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackerHitPlaneAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackerHitPlaneAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackerHitPlaneAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackerHitPlaneAssociationCollection* operator->() { return (MCRecoTrackerHitPlaneAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackerHitPlaneAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackerHitPlaneAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackerHitPlaneAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackerHitPlaneAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackerHitPlaneAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackerHitPlaneAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackerHitPlaneAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackerHitPlaneAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackerHitPlaneAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackerHitPlaneAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackerHitPlaneAssociation MCRecoTrackerHitPlaneAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackerHitPlaneAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackerHitPlaneAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackerHitPlaneAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackerHitPlaneAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackerHitPlaneAssociationData.h"
#include "edm4hep/MCRecoTrackerHitPlaneAssociationObj.h"
#include "edm4hep/SimTrackerHit.h"
#include "edm4hep/TrackerHitPlane.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackerHitPlaneAssociationObjPointerContainer = std::deque<MCRecoTrackerHitPlaneAssociationObj*>;
using MCRecoTrackerHitPlaneAssociationDataContainer = std::vector<MCRecoTrackerHitPlaneAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackerHitPlaneAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackerHitPlaneAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackerHitPlaneAssociationCollectionData(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(const MCRecoTrackerHitPlaneAssociationCollectionData&) = delete;
  MCRecoTrackerHitPlaneAssociationCollectionData(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;
  MCRecoTrackerHitPlaneAssociationCollectionData& operator=(MCRecoTrackerHitPlaneAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackerHitPlaneAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerHitPlane> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::SimTrackerHit> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackerHitPlaneAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationDATA_H
#define EDM4HEP_MCRecoCaloParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoCaloParticleAssociationData
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_H
#define EDM4HEP_MCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoCaloParticleAssociation;
class MCRecoCaloParticleAssociationCollection;

/** @class MCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoCaloParticleAssociation {

  friend class MutableMCRecoCaloParticleAssociation;
  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MCRecoCaloParticleAssociation();
  MCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MCRecoCaloParticleAssociation(const MCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MCRecoCaloParticleAssociation& operator=(MCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MCRecoCaloParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoCaloParticleAssociation& a, MCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoCaloParticleAssociation_H
#define EDM4HEP_MutableMCRecoCaloParticleAssociation_H

#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoCaloParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MutableCalorimeterHit;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoCaloParticleAssociation
 *  Association between a CalorimeterHit and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoCaloParticleAssociation {

  friend class MCRecoCaloParticleAssociationCollection;
  friend class MCRecoCaloParticleAssociationMutableCollectionIterator;
  friend class MCRecoCaloParticleAssociation;

public:
  using object_type = MCRecoCaloParticleAssociation;
  using collection_type = MCRecoCaloParticleAssociationCollection;

  /// default constructor
  MutableMCRecoCaloParticleAssociation();
  MutableMCRecoCaloParticleAssociation(float weight);

  /// constructor from existing MCRecoCaloParticleAssociationObj
  MutableMCRecoCaloParticleAssociation(MCRecoCaloParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoCaloParticleAssociation(const MutableMCRecoCaloParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoCaloParticleAssociation& operator=(MutableMCRecoCaloParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoCaloParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoCaloParticleAssociation();

  /// conversion to const object
  operator MCRecoCaloParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed hit
  const edm4hep::CalorimeterHit getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed hit
  void setRec(edm4hep::CalorimeterHit value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoCaloParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoCaloParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoCaloParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoCaloParticleAssociation& a, MutableMCRecoCaloParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoCaloParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoCaloParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationOBJ_H
#define EDM4HEP_MCRecoCaloParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class CalorimeterHit;
class MCParticle;
}


namespace edm4hep {

class MCRecoCaloParticleAssociation;

class MCRecoCaloParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoCaloParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoCaloParticleAssociationObj(const MCRecoCaloParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoCaloParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoCaloParticleAssociationObj(const podio::ObjectID id, MCRecoCaloParticleAssociationData data);
  /// No assignment operator
  MCRecoCaloParticleAssociationObj& operator=(const MCRecoCaloParticleAssociationObj&) = delete;
  virtual ~MCRecoCaloParticleAssociationObj();

public:
  MCRecoCaloParticleAssociationData data;
  edm4hep::CalorimeterHit* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociationCollection_H
#define EDM4HEP_MCRecoCaloParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociation.h"
#include "edm4hep/MutableMCRecoCaloParticleAssociation.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/MCRecoCaloParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoCaloParticleAssociationCollectionIterator {
public:
  MCRecoCaloParticleAssociationCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationCollectionIterator(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationCollectionIterator& operator=(const MCRecoCaloParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoCaloParticleAssociation operator*();
  MCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoCaloParticleAssociationMutableCollectionIterator {
public:
  MCRecoCaloParticleAssociationMutableCollectionIterator(size_t index, const MCRecoCaloParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoCaloParticleAssociationMutableCollectionIterator(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator=(const MCRecoCaloParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoCaloParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoCaloParticleAssociation operator*();
  MutableMCRecoCaloParticleAssociation* operator->();
  MCRecoCaloParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoCaloParticleAssociation m_object;
  const MCRecoCaloParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoCaloParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoCaloParticleAssociation;
  using const_iterator = MCRecoCaloParticleAssociationCollectionIterator;
  using iterator = MCRecoCaloParticleAssociationMutableCollectionIterator;

  MCRecoCaloParticleAssociationCollection();
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoCaloParticleAssociationCollection(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection& operator=(const MCRecoCaloParticleAssociationCollection& ) = delete;
  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationCollection&&) = default;
  MCRecoCaloParticleAssociationCollection& operator=(MCRecoCaloParticleAssociationCollection&&) = default;

//  MCRecoCaloParticleAssociationCollection(MCRecoCaloParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoCaloParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoCaloParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoCaloParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoCaloParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoCaloParticleAssociationCollection* operator->() { return (MCRecoCaloParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoCaloParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoCaloParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoCaloParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoCaloParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoCaloParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoCaloParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoCaloParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoCaloParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoCaloParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoCaloParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoCaloParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoCaloParticleAssociation MCRecoCaloParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoCaloParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoCaloParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoCaloParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoCaloParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoCaloParticleAssociationData.h"
#include "edm4hep/MCRecoCaloParticleAssociationObj.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoCaloParticleAssociationObjPointerContainer = std::deque<MCRecoCaloParticleAssociationObj*>;
using MCRecoCaloParticleAssociationDataContainer = std::vector<MCRecoCaloParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoCaloParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoCaloParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoCaloParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoCaloParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoCaloParticleAssociationCollectionData(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData& operator=(const MCRecoCaloParticleAssociationCollectionData&) = delete;
  MCRecoCaloParticleAssociationCollectionData(MCRecoCaloParticleAssociationCollectionData&& other) = default;
  MCRecoCaloParticleAssociationCollectionData& operator=(MCRecoCaloParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoCaloParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::CalorimeterHit> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoCaloParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationDATA_H
#define EDM4HEP_MCRecoClusterParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoClusterParticleAssociationData
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_H
#define EDM4HEP_MCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoClusterParticleAssociation;
class MCRecoClusterParticleAssociationCollection;

/** @class MCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoClusterParticleAssociation {

  friend class MutableMCRecoClusterParticleAssociation;
  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MCRecoClusterParticleAssociation();
  MCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MCRecoClusterParticleAssociation(const MCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MCRecoClusterParticleAssociation& operator=(MCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MCRecoClusterParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoClusterParticleAssociation& a, MCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoClusterParticleAssociation_H
#define EDM4HEP_MutableMCRecoClusterParticleAssociation_H

#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoClusterParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Cluster;
class MutableCluster;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoClusterParticleAssociation
 *  Association between a Cluster and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoClusterParticleAssociation {

  friend class MCRecoClusterParticleAssociationCollection;
  friend class MCRecoClusterParticleAssociationMutableCollectionIterator;
  friend class MCRecoClusterParticleAssociation;

public:
  using object_type = MCRecoClusterParticleAssociation;
  using collection_type = MCRecoClusterParticleAssociationCollection;

  /// default constructor
  MutableMCRecoClusterParticleAssociation();
  MutableMCRecoClusterParticleAssociation(float weight);

  /// constructor from existing MCRecoClusterParticleAssociationObj
  MutableMCRecoClusterParticleAssociation(MCRecoClusterParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoClusterParticleAssociation(const MutableMCRecoClusterParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoClusterParticleAssociation& operator=(MutableMCRecoClusterParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoClusterParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoClusterParticleAssociation();

  /// conversion to const object
  operator MCRecoClusterParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the cluster
  const edm4hep::Cluster getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the cluster
  void setRec(edm4hep::Cluster value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoClusterParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoClusterParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoClusterParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoClusterParticleAssociation& a, MutableMCRecoClusterParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoClusterParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoClusterParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationOBJ_H
#define EDM4HEP_MCRecoClusterParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Cluster;
class MCParticle;
}


namespace edm4hep {

class MCRecoClusterParticleAssociation;

class MCRecoClusterParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoClusterParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoClusterParticleAssociationObj(const MCRecoClusterParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoClusterParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoClusterParticleAssociationObj(const podio::ObjectID id, MCRecoClusterParticleAssociationData data);
  /// No assignment operator
  MCRecoClusterParticleAssociationObj& operator=(const MCRecoClusterParticleAssociationObj&) = delete;
  virtual ~MCRecoClusterParticleAssociationObj();

public:
  MCRecoClusterParticleAssociationData data;
  edm4hep::Cluster* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociationCollection_H
#define EDM4HEP_MCRecoClusterParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociation.h"
#include "edm4hep/MutableMCRecoClusterParticleAssociation.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/MCRecoClusterParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoClusterParticleAssociationCollectionIterator {
public:
  MCRecoClusterParticleAssociationCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationCollectionIterator(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationCollectionIterator& operator=(const MCRecoClusterParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoClusterParticleAssociation operator*();
  MCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoClusterParticleAssociationMutableCollectionIterator {
public:
  MCRecoClusterParticleAssociationMutableCollectionIterator(size_t index, const MCRecoClusterParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoClusterParticleAssociationMutableCollectionIterator(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator=(const MCRecoClusterParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoClusterParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoClusterParticleAssociation operator*();
  MutableMCRecoClusterParticleAssociation* operator->();
  MCRecoClusterParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoClusterParticleAssociation m_object;
  const MCRecoClusterParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoClusterParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoClusterParticleAssociation;
  using const_iterator = MCRecoClusterParticleAssociationCollectionIterator;
  using iterator = MCRecoClusterParticleAssociationMutableCollectionIterator;

  MCRecoClusterParticleAssociationCollection();
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoClusterParticleAssociationCollection(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection& operator=(const MCRecoClusterParticleAssociationCollection& ) = delete;
  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationCollection&&) = default;
  MCRecoClusterParticleAssociationCollection& operator=(MCRecoClusterParticleAssociationCollection&&) = default;

//  MCRecoClusterParticleAssociationCollection(MCRecoClusterParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoClusterParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoClusterParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoClusterParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoClusterParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoClusterParticleAssociationCollection* operator->() { return (MCRecoClusterParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoClusterParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoClusterParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoClusterParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoClusterParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoClusterParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoClusterParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoClusterParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoClusterParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoClusterParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoClusterParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoClusterParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoClusterParticleAssociation MCRecoClusterParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoClusterParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoClusterParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoClusterParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoClusterParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoClusterParticleAssociationData.h"
#include "edm4hep/MCRecoClusterParticleAssociationObj.h"
#include "edm4hep/Cluster.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoClusterParticleAssociationObjPointerContainer = std::deque<MCRecoClusterParticleAssociationObj*>;
using MCRecoClusterParticleAssociationDataContainer = std::vector<MCRecoClusterParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoClusterParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoClusterParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoClusterParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoClusterParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoClusterParticleAssociationCollectionData(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData& operator=(const MCRecoClusterParticleAssociationCollectionData&) = delete;
  MCRecoClusterParticleAssociationCollectionData(MCRecoClusterParticleAssociationCollectionData&& other) = default;
  MCRecoClusterParticleAssociationCollectionData& operator=(MCRecoClusterParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoClusterParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Cluster> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoClusterParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationDATA_H
#define EDM4HEP_MCRecoTrackParticleAssociationDATA_H


namespace edm4hep {


/** @class MCRecoTrackParticleAssociationData
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_H
#define EDM4HEP_MCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableMCRecoTrackParticleAssociation;
class MCRecoTrackParticleAssociationCollection;

/** @class MCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MCRecoTrackParticleAssociation {

  friend class MutableMCRecoTrackParticleAssociation;
  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationCollectionIterator;

public:
  using mutable_type = MutableMCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MCRecoTrackParticleAssociation();
  MCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MCRecoTrackParticleAssociation(const MCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MCRecoTrackParticleAssociation& operator=(MCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MCRecoTrackParticleAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MCRecoTrackParticleAssociation& a, MCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableMCRecoTrackParticleAssociation_H
#define EDM4HEP_MutableMCRecoTrackParticleAssociation_H

#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/MCRecoTrackParticleAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableMCRecoTrackParticleAssociation
 *  Association between a Track and a MCParticle
 *  @author: Placido Fernandez Declara
 */
class MutableMCRecoTrackParticleAssociation {

  friend class MCRecoTrackParticleAssociationCollection;
  friend class MCRecoTrackParticleAssociationMutableCollectionIterator;
  friend class MCRecoTrackParticleAssociation;

public:
  using object_type = MCRecoTrackParticleAssociation;
  using collection_type = MCRecoTrackParticleAssociationCollection;

  /// default constructor
  MutableMCRecoTrackParticleAssociation();
  MutableMCRecoTrackParticleAssociation(float weight);

  /// constructor from existing MCRecoTrackParticleAssociationObj
  MutableMCRecoTrackParticleAssociation(MCRecoTrackParticleAssociationObj* obj);

  /// copy constructor
  MutableMCRecoTrackParticleAssociation(const MutableMCRecoTrackParticleAssociation& other);

  /// copy-assignment operator
  MutableMCRecoTrackParticleAssociation& operator=(MutableMCRecoTrackParticleAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableMCRecoTrackParticleAssociation clone() const;

  /// destructor
  ~MutableMCRecoTrackParticleAssociation();

  /// conversion to const object
  operator MCRecoTrackParticleAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the track
  const edm4hep::Track getRec() const;
  /// Access the reference to the Monte-Carlo particle
  const edm4hep::MCParticle getSim() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the track
  void setRec(edm4hep::Track value);
  /// Set the reference to the Monte-Carlo particle
  void setSim(edm4hep::MCParticle value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from MCRecoTrackParticleAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MCRecoTrackParticleAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableMCRecoTrackParticleAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableMCRecoTrackParticleAssociation& a, MutableMCRecoTrackParticleAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  MCRecoTrackParticleAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableMCRecoTrackParticleAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationOBJ_H
#define EDM4HEP_MCRecoTrackParticleAssociationOBJ_H

// data model specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class Track;
class MCParticle;
}


namespace edm4hep {

class MCRecoTrackParticleAssociation;

class MCRecoTrackParticleAssociationObj : public podio::ObjBase {
public:
  /// constructor
  MCRecoTrackParticleAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  MCRecoTrackParticleAssociationObj(const MCRecoTrackParticleAssociationObj&);
  /// constructor from ObjectID and MCRecoTrackParticleAssociationData
  /// does not initialize the internal relation containers
  MCRecoTrackParticleAssociationObj(const podio::ObjectID id, MCRecoTrackParticleAssociationData data);
  /// No assignment operator
  MCRecoTrackParticleAssociationObj& operator=(const MCRecoTrackParticleAssociationObj&) = delete;
  virtual ~MCRecoTrackParticleAssociationObj();

public:
  MCRecoTrackParticleAssociationData data;
  edm4hep::Track* m_rec{nullptr};
  edm4hep::MCParticle* m_sim{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociationCollection_H
#define EDM4HEP_MCRecoTrackParticleAssociationCollection_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociation.h"
#include "edm4hep/MutableMCRecoTrackParticleAssociation.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCRecoTrackParticleAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class MCRecoTrackParticleAssociationCollectionIterator {
public:
  MCRecoTrackParticleAssociationCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationCollectionIterator(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationCollectionIterator& operator=(const MCRecoTrackParticleAssociationCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MCRecoTrackParticleAssociation operator*();
  MCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  MCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


class MCRecoTrackParticleAssociationMutableCollectionIterator {
public:
  MCRecoTrackParticleAssociationMutableCollectionIterator(size_t index, const MCRecoTrackParticleAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  MCRecoTrackParticleAssociationMutableCollectionIterator(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator=(const MCRecoTrackParticleAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const MCRecoTrackParticleAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableMCRecoTrackParticleAssociation operator*();
  MutableMCRecoTrackParticleAssociation* operator->();
  MCRecoTrackParticleAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableMCRecoTrackParticleAssociation m_object;
  const MCRecoTrackParticleAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class MCRecoTrackParticleAssociationCollection : public podio::CollectionBase {
public:
  using value_type = MCRecoTrackParticleAssociation;
  using const_iterator = MCRecoTrackParticleAssociationCollectionIterator;
  using iterator = MCRecoTrackParticleAssociationMutableCollectionIterator;

  MCRecoTrackParticleAssociationCollection();
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  MCRecoTrackParticleAssociationCollection(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection& operator=(const MCRecoTrackParticleAssociationCollection& ) = delete;
  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationCollection&&) = default;
  MCRecoTrackParticleAssociationCollection& operator=(MCRecoTrackParticleAssociationCollection&&) = default;

//  MCRecoTrackParticleAssociationCollection(MCRecoTrackParticleAssociationVector* data, uint32_t collectionID);
  ~MCRecoTrackParticleAssociationCollection();

  constexpr static auto typeName = "edm4hep::MCRecoTrackParticleAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::MCRecoTrackParticleAssociation";
  constexpr static auto dataTypeName = "edm4hep::MCRecoTrackParticleAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  MCRecoTrackParticleAssociationCollection* operator->() { return (MCRecoTrackParticleAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableMCRecoTrackParticleAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableMCRecoTrackParticleAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  MCRecoTrackParticleAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableMCRecoTrackParticleAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  MCRecoTrackParticleAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableMCRecoTrackParticleAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(MCRecoTrackParticleAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (MCRecoTrackParticleAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class MCRecoTrackParticleAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable MCRecoTrackParticleAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const MCRecoTrackParticleAssociationCollection& v);

template<typename... Args>
MutableMCRecoTrackParticleAssociation MCRecoTrackParticleAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new MCRecoTrackParticleAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableMCRecoTrackParticleAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MCRecoTrackParticleAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H
#define EDM4HEP_MCRecoTrackParticleAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/MCRecoTrackParticleAssociationData.h"
#include "edm4hep/MCRecoTrackParticleAssociationObj.h"
#include "edm4hep/MCParticle.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using MCRecoTrackParticleAssociationObjPointerContainer = std::deque<MCRecoTrackParticleAssociationObj*>;
using MCRecoTrackParticleAssociationDataContainer = std::vector<MCRecoTrackParticleAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class MCRecoTrackParticleAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  MCRecoTrackParticleAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  MCRecoTrackParticleAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  MCRecoTrackParticleAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  MCRecoTrackParticleAssociationCollectionData(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData& operator=(const MCRecoTrackParticleAssociationCollectionData&) = delete;
  MCRecoTrackParticleAssociationCollectionData(MCRecoTrackParticleAssociationCollectionData&& other) = default;
  MCRecoTrackParticleAssociationCollectionData& operator=(MCRecoTrackParticleAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~MCRecoTrackParticleAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::MCParticle> m_rel_sim{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<MCRecoTrackParticleAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationDATA_H
#define EDM4HEP_RecoParticleVertexAssociationDATA_H


namespace edm4hep {


/** @class RecoParticleVertexAssociationData
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociationData {
public:
  float weight{}; ///< weight of this association

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_H
#define EDM4HEP_RecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {

class MutableRecoParticleVertexAssociation;
class RecoParticleVertexAssociationCollection;

/** @class RecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class RecoParticleVertexAssociation {

  friend class MutableRecoParticleVertexAssociation;
  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationCollectionIterator;

public:
  using mutable_type = MutableRecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  RecoParticleVertexAssociation();
  RecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  RecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  RecoParticleVertexAssociation(const RecoParticleVertexAssociation& other);

  /// copy-assignment operator
  RecoParticleVertexAssociation& operator=(RecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~RecoParticleVertexAssociation();


public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecoParticleVertexAssociation& a, RecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociation& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecoParticleVertexAssociation_H
#define EDM4HEP_MutableRecoParticleVertexAssociation_H

#include "edm4hep/RecoParticleVertexAssociationObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecoParticleVertexAssociation.h"

#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class MutableReconstructedParticle;
class Vertex;
class MutableVertex;
}


namespace edm4hep {


/** @class MutableRecoParticleVertexAssociation
 *  Association between a Reconstructed Particle and a Vertex
 *  @author: Placido Fernandez Declara
 */
class MutableRecoParticleVertexAssociation {

  friend class RecoParticleVertexAssociationCollection;
  friend class RecoParticleVertexAssociationMutableCollectionIterator;
  friend class RecoParticleVertexAssociation;

public:
  using object_type = RecoParticleVertexAssociation;
  using collection_type = RecoParticleVertexAssociationCollection;

  /// default constructor
  MutableRecoParticleVertexAssociation();
  MutableRecoParticleVertexAssociation(float weight);

  /// constructor from existing RecoParticleVertexAssociationObj
  MutableRecoParticleVertexAssociation(RecoParticleVertexAssociationObj* obj);

  /// copy constructor
  MutableRecoParticleVertexAssociation(const MutableRecoParticleVertexAssociation& other);

  /// copy-assignment operator
  MutableRecoParticleVertexAssociation& operator=(MutableRecoParticleVertexAssociation other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecoParticleVertexAssociation clone() const;

  /// destructor
  ~MutableRecoParticleVertexAssociation();

  /// conversion to const object
  operator RecoParticleVertexAssociation() const;

public:

  /// Access the weight of this association
  const float& getWeight() const;


  /// Access the reference to the reconstructed particle
  const edm4hep::ReconstructedParticle getRec() const;
  /// Access the reference to the vertex
  const edm4hep::Vertex getVertex() const;

  /// Set the weight of this association
  void setWeight(float value);


  /// Set the reference to the reconstructed particle
  void setRec(edm4hep::ReconstructedParticle value);
  /// Set the reference to the vertex
  void setVertex(edm4hep::Vertex value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecoParticleVertexAssociationObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecoParticleVertexAssociation& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecoParticleVertexAssociation& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecoParticleVertexAssociation& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecoParticleVertexAssociation& a, MutableRecoParticleVertexAssociation& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecoParticleVertexAssociationObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecoParticleVertexAssociation& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationOBJ_H
#define EDM4HEP_RecoParticleVertexAssociationOBJ_H

// data model specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class ReconstructedParticle;
class Vertex;
}


namespace edm4hep {

class RecoParticleVertexAssociation;

class RecoParticleVertexAssociationObj : public podio::ObjBase {
public:
  /// constructor
  RecoParticleVertexAssociationObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecoParticleVertexAssociationObj(const RecoParticleVertexAssociationObj&);
  /// constructor from ObjectID and RecoParticleVertexAssociationData
  /// does not initialize the internal relation containers
  RecoParticleVertexAssociationObj(const podio::ObjectID id, RecoParticleVertexAssociationData data);
  /// No assignment operator
  RecoParticleVertexAssociationObj& operator=(const RecoParticleVertexAssociationObj&) = delete;
  virtual ~RecoParticleVertexAssociationObj();

public:
  RecoParticleVertexAssociationData data;
  edm4hep::ReconstructedParticle* m_rec{nullptr};
  edm4hep::Vertex* m_vertex{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociationCollection_H
#define EDM4HEP_RecoParticleVertexAssociationCollection_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociation.h"
#include "edm4hep/MutableRecoParticleVertexAssociation.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/RecoParticleVertexAssociationCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecoParticleVertexAssociationCollectionIterator {
public:
  RecoParticleVertexAssociationCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationCollectionIterator(const RecoParticleVertexAssociationCollectionIterator&) = delete;
  RecoParticleVertexAssociationCollectionIterator& operator=(const RecoParticleVertexAssociationCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecoParticleVertexAssociation operator*();
  RecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationCollectionIterator& operator++();

private:
  size_t m_index;
  RecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


class RecoParticleVertexAssociationMutableCollectionIterator {
public:
  RecoParticleVertexAssociationMutableCollectionIterator(size_t index, const RecoParticleVertexAssociationObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecoParticleVertexAssociationMutableCollectionIterator(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;
  RecoParticleVertexAssociationMutableCollectionIterator& operator=(const RecoParticleVertexAssociationMutableCollectionIterator&) = delete;

  bool operator!=(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecoParticleVertexAssociationMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecoParticleVertexAssociation operator*();
  MutableRecoParticleVertexAssociation* operator->();
  RecoParticleVertexAssociationMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecoParticleVertexAssociation m_object;
  const RecoParticleVertexAssociationObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecoParticleVertexAssociationCollection : public podio::CollectionBase {
public:
  using value_type = RecoParticleVertexAssociation;
  using const_iterator = RecoParticleVertexAssociationCollectionIterator;
  using iterator = RecoParticleVertexAssociationMutableCollectionIterator;

  RecoParticleVertexAssociationCollection();
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecoParticleVertexAssociationCollection(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection& operator=(const RecoParticleVertexAssociationCollection& ) = delete;
  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationCollection&&) = default;
  RecoParticleVertexAssociationCollection& operator=(RecoParticleVertexAssociationCollection&&) = default;

//  RecoParticleVertexAssociationCollection(RecoParticleVertexAssociationVector* data, uint32_t collectionID);
  ~RecoParticleVertexAssociationCollection();

  constexpr static auto typeName = "edm4hep::RecoParticleVertexAssociationCollection";
  constexpr static auto valueTypeName = "edm4hep::RecoParticleVertexAssociation";
  constexpr static auto dataTypeName = "edm4hep::RecoParticleVertexAssociationData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecoParticleVertexAssociationCollection* operator->() { return (RecoParticleVertexAssociationCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecoParticleVertexAssociation create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecoParticleVertexAssociation create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecoParticleVertexAssociation operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecoParticleVertexAssociation operator[](std::size_t index);
  /// Returns the const object of given index
  RecoParticleVertexAssociation at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecoParticleVertexAssociation at(std::size_t index);


  /// Append object to the collection
  void push_back(RecoParticleVertexAssociation object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecoParticleVertexAssociationObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<float> weight(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecoParticleVertexAssociationCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecoParticleVertexAssociationCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecoParticleVertexAssociationCollection& v);

template<typename... Args>
MutableRecoParticleVertexAssociation RecoParticleVertexAssociationCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecoParticleVertexAssociationObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableRecoParticleVertexAssociation(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecoParticleVertexAssociationCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecoParticleVertexAssociation_CollectionData_H
#define EDM4HEP_RecoParticleVertexAssociation_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecoParticleVertexAssociationData.h"
#include "edm4hep/RecoParticleVertexAssociationObj.h"
#include "edm4hep/ReconstructedParticle.h"
#include "edm4hep/Vertex.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecoParticleVertexAssociationObjPointerContainer = std::deque<RecoParticleVertexAssociationObj*>;
using RecoParticleVertexAssociationDataContainer = std::vector<RecoParticleVertexAssociationData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecoParticleVertexAssociationCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecoParticleVertexAssociationObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecoParticleVertexAssociationCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecoParticleVertexAssociationCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecoParticleVertexAssociationCollectionData(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData& operator=(const RecoParticleVertexAssociationCollectionData&) = delete;
  RecoParticleVertexAssociationCollectionData(RecoParticleVertexAssociationCollectionData&& other) = default;
  RecoParticleVertexAssociationCollectionData& operator=(RecoParticleVertexAssociationCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecoParticleVertexAssociationCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::ReconstructedParticle> m_rel_rec{nullptr}; ///< Relation buffer for read / write
  podio::UVecPtr<edm4hep::Vertex> m_rel_vertex{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecoParticleVertexAssociationDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterDATA_H
#define EDM4HEP_SimPrimaryIonizationClusterDATA_H

#include "edm4hep/Vector3d.h"
#include <cstdint>

namespace edm4hep {


/** @class SimPrimaryIonizationClusterData
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< the primary ionization's time in the lab frame [ns].
  ::edm4hep::Vector3d position{}; ///< the primary ionization's position [mm].
  std::int16_t type{}; ///< type.

  unsigned int electronCellID_begin{};
  unsigned int electronCellID_end{};
  unsigned int electronTime_begin{};
  unsigned int electronTime_end{};
  unsigned int electronPosition_begin{};
  unsigned int electronPosition_end{};
  unsigned int pulseTime_begin{};
  unsigned int pulseTime_end{};
  unsigned int pulseAmplitude_begin{};
  unsigned int pulseAmplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_H
#define EDM4HEP_SimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {

class MutableSimPrimaryIonizationCluster;
class SimPrimaryIonizationClusterCollection;

/** @class SimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class SimPrimaryIonizationCluster {

  friend class MutableSimPrimaryIonizationCluster;
  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableSimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  SimPrimaryIonizationCluster();
  SimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  SimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  SimPrimaryIonizationCluster(const SimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  SimPrimaryIonizationCluster& operator=(SimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~SimPrimaryIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const SimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableSimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const SimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(SimPrimaryIonizationCluster& a, SimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableSimPrimaryIonizationCluster_H
#define EDM4HEP_MutableSimPrimaryIonizationCluster_H

#include "edm4hep/SimPrimaryIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/SimPrimaryIonizationCluster.h"

#include "edm4hep/Vector3d.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class MCParticle;
class MutableMCParticle;
}


namespace edm4hep {


/** @class MutableSimPrimaryIonizationCluster
 *  Simulated Primary Ionization
 *  @author: Wenxing Fang, IHEP
 */
class MutableSimPrimaryIonizationCluster {

  friend class SimPrimaryIonizationClusterCollection;
  friend class SimPrimaryIonizationClusterMutableCollectionIterator;
  friend class SimPrimaryIonizationCluster;

public:
  using object_type = SimPrimaryIonizationCluster;
  using collection_type = SimPrimaryIonizationClusterCollection;

  /// default constructor
  MutableSimPrimaryIonizationCluster();
  MutableSimPrimaryIonizationCluster(std::uint64_t cellID, float time, edm4hep::Vector3d position, std::int16_t type);

  /// constructor from existing SimPrimaryIonizationClusterObj
  MutableSimPrimaryIonizationCluster(SimPrimaryIonizationClusterObj* obj);

  /// copy constructor
  MutableSimPrimaryIonizationCluster(const MutableSimPrimaryIonizationCluster& other);

  /// copy-assignment operator
  MutableSimPrimaryIonizationCluster& operator=(MutableSimPrimaryIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableSimPrimaryIonizationCluster clone() const;

  /// destructor
  ~MutableSimPrimaryIonizationCluster();

  /// conversion to const object
  operator SimPrimaryIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the the primary ionization's time in the lab frame [ns].
  const float& getTime() const;

  /// Access the the primary ionization's position [mm].
  const edm4hep::Vector3d& getPosition() const;

  /// Access the type.
  const std::int16_t& getType() const;


  /// Access the the particle that caused the ionizing collisions.
  const edm4hep::MCParticle getMCParticle() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the the primary ionization's time in the lab frame [ns].
  void setTime(float value);

  /// Set the the primary ionization's position [mm].
  void setPosition(edm4hep::Vector3d value);
  /// Get reference to the primary ionization's position [mm].
  edm4hep::Vector3d& position();

  /// Set the type.
  void setType(std::int16_t value);


  /// Set the the particle that caused the ionizing collisions.
  void setMCParticle(edm4hep::MCParticle value);

  void addToElectronCellID(std::uint64_t);
  std::size_t electronCellID_size() const;
  std::uint64_t getElectronCellID(std::size_t) const;
  std::vector<std::uint64_t>::const_iterator electronCellID_begin() const;
  std::vector<std::uint64_t>::const_iterator electronCellID_end() const;
  podio::RelationRange<std::uint64_t> getElectronCellID() const;
  void addToElectronTime(float);
  std::size_t electronTime_size() const;
  float getElectronTime(std::size_t) const;
  std::vector<float>::const_iterator electronTime_begin() const;
  std::vector<float>::const_iterator electronTime_end() const;
  podio::RelationRange<float> getElectronTime() const;
  void addToElectronPosition(edm4hep::Vector3d);
  std::size_t electronPosition_size() const;
  edm4hep::Vector3d getElectronPosition(std::size_t) const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_begin() const;
  std::vector<edm4hep::Vector3d>::const_iterator electronPosition_end() const;
  podio::RelationRange<edm4hep::Vector3d> getElectronPosition() const;
  void addToPulseTime(float);
  std::size_t pulseTime_size() const;
  float getPulseTime(std::size_t) const;
  std::vector<float>::const_iterator pulseTime_begin() const;
  std::vector<float>::const_iterator pulseTime_end() const;
  podio::RelationRange<float> getPulseTime() const;
  void addToPulseAmplitude(float);
  std::size_t pulseAmplitude_size() const;
  float getPulseAmplitude(std::size_t) const;
  std::vector<float>::const_iterator pulseAmplitude_begin() const;
  std::vector<float>::const_iterator pulseAmplitude_end() const;
  podio::RelationRange<float> getPulseAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from SimPrimaryIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableSimPrimaryIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const SimPrimaryIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableSimPrimaryIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableSimPrimaryIonizationCluster& a, MutableSimPrimaryIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  SimPrimaryIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableSimPrimaryIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterOBJ_H
#define EDM4HEP_SimPrimaryIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/Vector3d.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class MCParticle;
}


namespace edm4hep {

class SimPrimaryIonizationCluster;

class SimPrimaryIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  SimPrimaryIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  SimPrimaryIonizationClusterObj(const SimPrimaryIonizationClusterObj&);
  /// constructor from ObjectID and SimPrimaryIonizationClusterData
  /// does not initialize the internal relation containers
  SimPrimaryIonizationClusterObj(const podio::ObjectID id, SimPrimaryIonizationClusterData data);
  /// No assignment operator
  SimPrimaryIonizationClusterObj& operator=(const SimPrimaryIonizationClusterObj&) = delete;
  virtual ~SimPrimaryIonizationClusterObj();

public:
  SimPrimaryIonizationClusterData data;
  edm4hep::MCParticle* m_MCParticle{nullptr};
  std::vector<std::uint64_t>* m_electronCellID{nullptr};
  std::vector<float>* m_electronTime{nullptr};
  std::vector<edm4hep::Vector3d>* m_electronPosition{nullptr};
  std::vector<float>* m_pulseTime{nullptr};
  std::vector<float>* m_pulseAmplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationClusterCollection_H
#define EDM4HEP_SimPrimaryIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationCluster.h"
#include "edm4hep/MutableSimPrimaryIonizationCluster.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/SimPrimaryIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class SimPrimaryIonizationClusterCollectionIterator {
public:
  SimPrimaryIonizationClusterCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterCollectionIterator(const SimPrimaryIonizationClusterCollectionIterator&) = delete;
  SimPrimaryIonizationClusterCollectionIterator& operator=(const SimPrimaryIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  SimPrimaryIonizationCluster operator*();
  SimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  SimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


class SimPrimaryIonizationClusterMutableCollectionIterator {
public:
  SimPrimaryIonizationClusterMutableCollectionIterator(size_t index, const SimPrimaryIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  SimPrimaryIonizationClusterMutableCollectionIterator(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;
  SimPrimaryIonizationClusterMutableCollectionIterator& operator=(const SimPrimaryIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const SimPrimaryIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableSimPrimaryIonizationCluster operator*();
  MutableSimPrimaryIonizationCluster* operator->();
  SimPrimaryIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableSimPrimaryIonizationCluster m_object;
  const SimPrimaryIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class SimPrimaryIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = SimPrimaryIonizationCluster;
  using const_iterator = SimPrimaryIonizationClusterCollectionIterator;
  using iterator = SimPrimaryIonizationClusterMutableCollectionIterator;

  SimPrimaryIonizationClusterCollection();
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  SimPrimaryIonizationClusterCollection(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection& operator=(const SimPrimaryIonizationClusterCollection& ) = delete;
  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterCollection&&) = default;
  SimPrimaryIonizationClusterCollection& operator=(SimPrimaryIonizationClusterCollection&&) = default;

//  SimPrimaryIonizationClusterCollection(SimPrimaryIonizationClusterVector* data, uint32_t collectionID);
  ~SimPrimaryIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::SimPrimaryIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::SimPrimaryIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::SimPrimaryIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  SimPrimaryIonizationClusterCollection* operator->() { return (SimPrimaryIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableSimPrimaryIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableSimPrimaryIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  SimPrimaryIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableSimPrimaryIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  SimPrimaryIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableSimPrimaryIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(SimPrimaryIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (SimPrimaryIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<edm4hep::Vector3d> position(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class SimPrimaryIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable SimPrimaryIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const SimPrimaryIonizationClusterCollection& v);

template<typename... Args>
MutableSimPrimaryIonizationCluster SimPrimaryIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new SimPrimaryIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, SimPrimaryIonizationClusterData} constructor
  obj->m_electronCellID = new std::vector<std::uint64_t>();
  obj->m_electronTime = new std::vector<float>();
  obj->m_electronPosition = new std::vector<edm4hep::Vector3d>();
  obj->m_pulseTime = new std::vector<float>();
  obj->m_pulseAmplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableSimPrimaryIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const SimPrimaryIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H
#define EDM4HEP_SimPrimaryIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/SimPrimaryIonizationClusterData.h"
#include "edm4hep/SimPrimaryIonizationClusterObj.h"
#include "edm4hep/MCParticle.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using SimPrimaryIonizationClusterObjPointerContainer = std::deque<SimPrimaryIonizationClusterObj*>;
using SimPrimaryIonizationClusterDataContainer = std::vector<SimPrimaryIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class SimPrimaryIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  SimPrimaryIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  SimPrimaryIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  SimPrimaryIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  SimPrimaryIonizationClusterCollectionData(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData& operator=(const SimPrimaryIonizationClusterCollectionData&) = delete;
  SimPrimaryIonizationClusterCollectionData(SimPrimaryIonizationClusterCollectionData&& other) = default;
  SimPrimaryIonizationClusterCollectionData& operator=(SimPrimaryIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~SimPrimaryIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(SimPrimaryIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::MCParticle> m_rel_MCParticle{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<std::uint64_t> m_vec_electronCellID{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<std::uint64_t>> m_vecs_electronCellID{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_electronTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_electronTime{}; /// pointers to individual member vectors
  podio::UVecPtr<edm4hep::Vector3d> m_vec_electronPosition{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::Vector3d>> m_vecs_electronPosition{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseTime{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseTime{}; /// pointers to individual member vectors
  podio::UVecPtr<float> m_vec_pulseAmplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_pulseAmplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<SimPrimaryIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseDATA_H
#define EDM4HEP_TrackerPulseDATA_H

#include <array>
#include <cstdint>

namespace edm4hep {


/** @class TrackerPulseData
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulseData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< time [ns].
  float charge{}; ///< charge [fC].
  std::int16_t quality{}; ///< quality.
  std::array<float, 3> covMatrix{}; ///< lower triangle covariance matrix of the charge(c) and time(t) measurements.

};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_H
#define EDM4HEP_TrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {

class MutableTrackerPulse;
class TrackerPulseCollection;

/** @class TrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class TrackerPulse {

  friend class MutableTrackerPulse;
  friend class TrackerPulseCollection;
  friend class TrackerPulseCollectionIterator;

public:
  using mutable_type = MutableTrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  TrackerPulse();
  TrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  TrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  TrackerPulse(const TrackerPulse& other);

  /// copy-assignment operator
  TrackerPulse& operator=(TrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~TrackerPulse();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TrackerPulse& a, TrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TrackerPulse& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTrackerPulse_H
#define EDM4HEP_MutableTrackerPulse_H

#include "edm4hep/TrackerPulseObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TrackerPulse.h"

#include <array>
#include <cstdint>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class TimeSeries;
class MutableTimeSeries;
}


namespace edm4hep {


/** @class MutableTrackerPulse
 *  Reconstructed Tracker Pulse
 *  @author: Wenxing Fang, IHEP
 */
class MutableTrackerPulse {

  friend class TrackerPulseCollection;
  friend class TrackerPulseMutableCollectionIterator;
  friend class TrackerPulse;

public:
  using object_type = TrackerPulse;
  using collection_type = TrackerPulseCollection;

  /// default constructor
  MutableTrackerPulse();
  MutableTrackerPulse(std::uint64_t cellID, float time, float charge, std::int16_t quality, std::array<float, 3> covMatrix);

  /// constructor from existing TrackerPulseObj
  MutableTrackerPulse(TrackerPulseObj* obj);

  /// copy constructor
  MutableTrackerPulse(const MutableTrackerPulse& other);

  /// copy-assignment operator
  MutableTrackerPulse& operator=(MutableTrackerPulse other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTrackerPulse clone() const;

  /// destructor
  ~MutableTrackerPulse();

  /// conversion to const object
  operator TrackerPulse() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the time [ns].
  const float& getTime() const;

  /// Access the charge [fC].
  const float& getCharge() const;

  /// Access the quality.
  const std::int16_t& getQuality() const;

  /// Access the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const std::array<float, 3>& getCovMatrix() const;
  /// Access item i of the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  const float& getCovMatrix(size_t i) const;

  /// Access the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  const edm4hep::TimeSeries getTimeSeries() const;

  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the time [ns].
  void setTime(float value);

  /// Set the charge [fC].
  void setCharge(float value);

  /// Set the quality.
  void setQuality(std::int16_t value);

  /// Set the lower triangle covariance matrix of the charge(c) and time(t) measurements.
  void setCovMatrix(std::array<float, 3> value);
  void setCovMatrix(size_t i, float value);
  /// Get reference to lower triangle covariance matrix of the charge(c) and time(t) measurements.
  std::array<float, 3>& covMatrix();


  /// Set the Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse.
  void setTimeSeries(edm4hep::TimeSeries value);




  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TrackerPulseObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTrackerPulse& other) const { return m_obj == other.m_obj; }
  bool operator==(const TrackerPulse& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTrackerPulse& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTrackerPulse& a, MutableTrackerPulse& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TrackerPulseObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTrackerPulse& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseOBJ_H
#define EDM4HEP_TrackerPulseOBJ_H

// data model specific includes
#include "edm4hep/TrackerPulseData.h"

#include "podio/ObjBase.h"

// forward declarations
namespace edm4hep {
class TimeSeries;
}


namespace edm4hep {

class TrackerPulse;

class TrackerPulseObj : public podio::ObjBase {
public:
  /// constructor
  TrackerPulseObj();
  /// copy constructor (does a deep-copy of relation containers)
  TrackerPulseObj(const TrackerPulseObj&);
  /// constructor from ObjectID and TrackerPulseData
  /// does not initialize the internal relation containers
  TrackerPulseObj(const podio::ObjectID id, TrackerPulseData data);
  /// No assignment operator
  TrackerPulseObj& operator=(const TrackerPulseObj&) = delete;
  virtual ~TrackerPulseObj();

public:
  TrackerPulseData data;
  edm4hep::TimeSeries* m_timeSeries{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulseCollection_H
#define EDM4HEP_TrackerPulseCollection_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulse.h"
#include "edm4hep/MutableTrackerPulse.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TrackerPulseCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TrackerPulseCollectionIterator {
public:
  TrackerPulseCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseCollectionIterator(const TrackerPulseCollectionIterator&) = delete;
  TrackerPulseCollectionIterator& operator=(const TrackerPulseCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TrackerPulse operator*();
  TrackerPulse* operator->();
  TrackerPulseCollectionIterator& operator++();

private:
  size_t m_index;
  TrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


class TrackerPulseMutableCollectionIterator {
public:
  TrackerPulseMutableCollectionIterator(size_t index, const TrackerPulseObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TrackerPulseMutableCollectionIterator(const TrackerPulseMutableCollectionIterator&) = delete;
  TrackerPulseMutableCollectionIterator& operator=(const TrackerPulseMutableCollectionIterator&) = delete;

  bool operator!=(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TrackerPulseMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTrackerPulse operator*();
  MutableTrackerPulse* operator->();
  TrackerPulseMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTrackerPulse m_object;
  const TrackerPulseObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TrackerPulseCollection : public podio::CollectionBase {
public:
  using value_type = TrackerPulse;
  using const_iterator = TrackerPulseCollectionIterator;
  using iterator = TrackerPulseMutableCollectionIterator;

  TrackerPulseCollection();
  TrackerPulseCollection(TrackerPulseCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TrackerPulseCollection(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection& operator=(const TrackerPulseCollection& ) = delete;
  TrackerPulseCollection(TrackerPulseCollection&&) = default;
  TrackerPulseCollection& operator=(TrackerPulseCollection&&) = default;

//  TrackerPulseCollection(TrackerPulseVector* data, uint32_t collectionID);
  ~TrackerPulseCollection();

  constexpr static auto typeName = "edm4hep::TrackerPulseCollection";
  constexpr static auto valueTypeName = "edm4hep::TrackerPulse";
  constexpr static auto dataTypeName = "edm4hep::TrackerPulseData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TrackerPulseCollection* operator->() { return (TrackerPulseCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTrackerPulse create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTrackerPulse create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TrackerPulse operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTrackerPulse operator[](std::size_t index);
  /// Returns the const object of given index
  TrackerPulse at(std::size_t index) const;
  /// Returns the object of given index
  MutableTrackerPulse at(std::size_t index);


  /// Append object to the collection
  void push_back(TrackerPulse object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TrackerPulseObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> charge(const size_t nElem = 0) const;
  std::vector<std::int16_t> quality(const size_t nElem = 0) const;
  std::vector<std::array<float, 3>> covMatrix(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TrackerPulseCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TrackerPulseCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TrackerPulseCollection& v);

template<typename... Args>
MutableTrackerPulse TrackerPulseCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TrackerPulseObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  return MutableTrackerPulse(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TrackerPulseCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TrackerPulse_CollectionData_H
#define EDM4HEP_TrackerPulse_CollectionData_H

// datamodel specific includes
#include "edm4hep/TrackerPulseData.h"
#include "edm4hep/TrackerPulseObj.h"
#include "edm4hep/TimeSeries.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TrackerPulseObjPointerContainer = std::deque<TrackerPulseObj*>;
using TrackerPulseDataContainer = std::vector<TrackerPulseData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TrackerPulseCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TrackerPulseObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TrackerPulseCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TrackerPulseCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TrackerPulseCollectionData(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData& operator=(const TrackerPulseCollectionData&) = delete;
  TrackerPulseCollectionData(TrackerPulseCollectionData&& other) = default;
  TrackerPulseCollectionData& operator=(TrackerPulseCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TrackerPulseCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();


  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TimeSeries> m_rel_timeSeries{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TrackerPulseDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterDATA_H
#define EDM4HEP_RecIonizationClusterDATA_H

#include <cstdint>

namespace edm4hep {


/** @class RecIonizationClusterData
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationClusterData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float significance{}; ///< significance.
  std::int16_t type{}; ///< type.

  unsigned int trackerPulse_begin{};
  unsigned int trackerPulse_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_H
#define EDM4HEP_RecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableRecIonizationCluster;
class RecIonizationClusterCollection;

/** @class RecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class RecIonizationCluster {

  friend class MutableRecIonizationCluster;
  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterCollectionIterator;

public:
  using mutable_type = MutableRecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  RecIonizationCluster();
  RecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  RecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  RecIonizationCluster(const RecIonizationCluster& other);

  /// copy-assignment operator
  RecIonizationCluster& operator=(RecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~RecIonizationCluster();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecIonizationCluster& a, RecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecIonizationCluster& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecIonizationCluster_H
#define EDM4HEP_MutableRecIonizationCluster_H

#include "edm4hep/RecIonizationClusterObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecIonizationCluster.h"

#include "edm4hep/TrackerPulse.h"
#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableRecIonizationCluster
 *  Reconstructed Ionization Cluster
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecIonizationCluster {

  friend class RecIonizationClusterCollection;
  friend class RecIonizationClusterMutableCollectionIterator;
  friend class RecIonizationCluster;

public:
  using object_type = RecIonizationCluster;
  using collection_type = RecIonizationClusterCollection;

  /// default constructor
  MutableRecIonizationCluster();
  MutableRecIonizationCluster(std::uint64_t cellID, float significance, std::int16_t type);

  /// constructor from existing RecIonizationClusterObj
  MutableRecIonizationCluster(RecIonizationClusterObj* obj);

  /// copy constructor
  MutableRecIonizationCluster(const MutableRecIonizationCluster& other);

  /// copy-assignment operator
  MutableRecIonizationCluster& operator=(MutableRecIonizationCluster other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecIonizationCluster clone() const;

  /// destructor
  ~MutableRecIonizationCluster();

  /// conversion to const object
  operator RecIonizationCluster() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the significance.
  const float& getSignificance() const;

  /// Access the type.
  const std::int16_t& getType() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the significance.
  void setSignificance(float value);

  /// Set the type.
  void setType(std::int16_t value);



  void addToTrackerPulse(edm4hep::TrackerPulse);
  std::size_t trackerPulse_size() const;
  edm4hep::TrackerPulse getTrackerPulse(std::size_t) const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_begin() const;
  std::vector<edm4hep::TrackerPulse>::const_iterator trackerPulse_end() const;
  podio::RelationRange<edm4hep::TrackerPulse> getTrackerPulse() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecIonizationClusterObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecIonizationCluster& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecIonizationCluster& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecIonizationCluster& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecIonizationCluster& a, MutableRecIonizationCluster& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecIonizationClusterObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecIonizationCluster& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterOBJ_H
#define EDM4HEP_RecIonizationClusterOBJ_H

// data model specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/TrackerPulse.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class RecIonizationCluster;

class RecIonizationClusterObj : public podio::ObjBase {
public:
  /// constructor
  RecIonizationClusterObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecIonizationClusterObj(const RecIonizationClusterObj&);
  /// constructor from ObjectID and RecIonizationClusterData
  /// does not initialize the internal relation containers
  RecIonizationClusterObj(const podio::ObjectID id, RecIonizationClusterData data);
  /// No assignment operator
  RecIonizationClusterObj& operator=(const RecIonizationClusterObj&) = delete;
  virtual ~RecIonizationClusterObj();

public:
  RecIonizationClusterData data;
  std::vector<edm4hep::TrackerPulse>* m_trackerPulse{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationClusterCollection_H
#define EDM4HEP_RecIonizationClusterCollection_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationCluster.h"
#include "edm4hep/MutableRecIonizationCluster.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/RecIonizationClusterCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecIonizationClusterCollectionIterator {
public:
  RecIonizationClusterCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterCollectionIterator(const RecIonizationClusterCollectionIterator&) = delete;
  RecIonizationClusterCollectionIterator& operator=(const RecIonizationClusterCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecIonizationCluster operator*();
  RecIonizationCluster* operator->();
  RecIonizationClusterCollectionIterator& operator++();

private:
  size_t m_index;
  RecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


class RecIonizationClusterMutableCollectionIterator {
public:
  RecIonizationClusterMutableCollectionIterator(size_t index, const RecIonizationClusterObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecIonizationClusterMutableCollectionIterator(const RecIonizationClusterMutableCollectionIterator&) = delete;
  RecIonizationClusterMutableCollectionIterator& operator=(const RecIonizationClusterMutableCollectionIterator&) = delete;

  bool operator!=(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecIonizationClusterMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecIonizationCluster operator*();
  MutableRecIonizationCluster* operator->();
  RecIonizationClusterMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecIonizationCluster m_object;
  const RecIonizationClusterObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecIonizationClusterCollection : public podio::CollectionBase {
public:
  using value_type = RecIonizationCluster;
  using const_iterator = RecIonizationClusterCollectionIterator;
  using iterator = RecIonizationClusterMutableCollectionIterator;

  RecIonizationClusterCollection();
  RecIonizationClusterCollection(RecIonizationClusterCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecIonizationClusterCollection(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection& operator=(const RecIonizationClusterCollection& ) = delete;
  RecIonizationClusterCollection(RecIonizationClusterCollection&&) = default;
  RecIonizationClusterCollection& operator=(RecIonizationClusterCollection&&) = default;

//  RecIonizationClusterCollection(RecIonizationClusterVector* data, uint32_t collectionID);
  ~RecIonizationClusterCollection();

  constexpr static auto typeName = "edm4hep::RecIonizationClusterCollection";
  constexpr static auto valueTypeName = "edm4hep::RecIonizationCluster";
  constexpr static auto dataTypeName = "edm4hep::RecIonizationClusterData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecIonizationClusterCollection* operator->() { return (RecIonizationClusterCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecIonizationCluster create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecIonizationCluster create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecIonizationCluster operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecIonizationCluster operator[](std::size_t index);
  /// Returns the const object of given index
  RecIonizationCluster at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecIonizationCluster at(std::size_t index);


  /// Append object to the collection
  void push_back(RecIonizationCluster object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecIonizationClusterObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> significance(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecIonizationClusterCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecIonizationClusterCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecIonizationClusterCollection& v);

template<typename... Args>
MutableRecIonizationCluster RecIonizationClusterCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecIonizationClusterObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecIonizationClusterData} constructor
  obj->m_trackerPulse = new std::vector<edm4hep::TrackerPulse>();
  m_storage.createRelations(obj);
  return MutableRecIonizationCluster(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecIonizationClusterCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecIonizationCluster_CollectionData_H
#define EDM4HEP_RecIonizationCluster_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecIonizationClusterData.h"
#include "edm4hep/RecIonizationClusterObj.h"
#include "edm4hep/TrackerPulse.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecIonizationClusterObjPointerContainer = std::deque<RecIonizationClusterObj*>;
using RecIonizationClusterDataContainer = std::vector<RecIonizationClusterData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecIonizationClusterCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecIonizationClusterObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecIonizationClusterCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecIonizationClusterCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecIonizationClusterCollectionData(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData& operator=(const RecIonizationClusterCollectionData&) = delete;
  RecIonizationClusterCollectionData(RecIonizationClusterCollectionData&& other) = default;
  RecIonizationClusterCollectionData& operator=(RecIonizationClusterCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecIonizationClusterCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecIonizationClusterObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::TrackerPulse> m_rel_trackerPulse;  ///< Relation buffer for read / write
  std::vector<podio::UVecPtr<edm4hep::TrackerPulse>> m_rel_trackerPulse_tmp{}; ///< Relation buffer for internal book-keeping

  // members to handle vector members

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecIonizationClusterDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesDATA_H
#define EDM4HEP_TimeSeriesDATA_H

#include <cstdint>

namespace edm4hep {


/** @class TimeSeriesData
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeriesData {
public:
  std::uint64_t cellID{}; ///< cell id.
  float time{}; ///< begin time [ns].
  float interval{}; ///< interval of each sampling [ns].

  unsigned int amplitude_begin{};
  unsigned int amplitude_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_H
#define EDM4HEP_TimeSeries_H

#include "edm4hep/TimeSeriesObj.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {

class MutableTimeSeries;
class TimeSeriesCollection;

/** @class TimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class TimeSeries {

  friend class MutableTimeSeries;
  friend class TimeSeriesCollection;
  friend class TimeSeriesCollectionIterator;

public:
  using mutable_type = MutableTimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  TimeSeries();
  TimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  TimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  TimeSeries(const TimeSeries& other);

  /// copy-assignment operator
  TimeSeries& operator=(TimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~TimeSeries();


public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const TimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableTimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const TimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(TimeSeries& a, TimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const TimeSeries& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableTimeSeries_H
#define EDM4HEP_MutableTimeSeries_H

#include "edm4hep/TimeSeriesObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/TimeSeries.h"

#include "podio/RelationRange.h"
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif



namespace edm4hep {


/** @class MutableTimeSeries
 *  Calibrated Detector Data
 *  @author: Wenxing Fang, IHEP
 */
class MutableTimeSeries {

  friend class TimeSeriesCollection;
  friend class TimeSeriesMutableCollectionIterator;
  friend class TimeSeries;

public:
  using object_type = TimeSeries;
  using collection_type = TimeSeriesCollection;

  /// default constructor
  MutableTimeSeries();
  MutableTimeSeries(std::uint64_t cellID, float time, float interval);

  /// constructor from existing TimeSeriesObj
  MutableTimeSeries(TimeSeriesObj* obj);

  /// copy constructor
  MutableTimeSeries(const MutableTimeSeries& other);

  /// copy-assignment operator
  MutableTimeSeries& operator=(MutableTimeSeries other);

  /// create a mutable deep-copy of the object with identical relations
  MutableTimeSeries clone() const;

  /// destructor
  ~MutableTimeSeries();

  /// conversion to const object
  operator TimeSeries() const;

public:

  /// Access the cell id.
  const std::uint64_t& getCellID() const;

  /// Access the begin time [ns].
  const float& getTime() const;

  /// Access the interval of each sampling [ns].
  const float& getInterval() const;



  /// Set the cell id.
  void setCellID(std::uint64_t value);

  /// Set the begin time [ns].
  void setTime(float value);

  /// Set the interval of each sampling [ns].
  void setInterval(float value);



  void addToAmplitude(float);
  std::size_t amplitude_size() const;
  float getAmplitude(std::size_t) const;
  std::vector<float>::const_iterator amplitude_begin() const;
  std::vector<float>::const_iterator amplitude_end() const;
  podio::RelationRange<float> getAmplitude() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from TimeSeriesObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableTimeSeries& other) const { return m_obj == other.m_obj; }
  bool operator==(const TimeSeries& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableTimeSeries& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableTimeSeries& a, MutableTimeSeries& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  TimeSeriesObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableTimeSeries& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesOBJ_H
#define EDM4HEP_TimeSeriesOBJ_H

// data model specific includes
#include "edm4hep/TimeSeriesData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>


namespace edm4hep {

class TimeSeries;

class TimeSeriesObj : public podio::ObjBase {
public:
  /// constructor
  TimeSeriesObj();
  /// copy constructor (does a deep-copy of relation containers)
  TimeSeriesObj(const TimeSeriesObj&);
  /// constructor from ObjectID and TimeSeriesData
  /// does not initialize the internal relation containers
  TimeSeriesObj(const podio::ObjectID id, TimeSeriesData data);
  /// No assignment operator
  TimeSeriesObj& operator=(const TimeSeriesObj&) = delete;
  virtual ~TimeSeriesObj();

public:
  TimeSeriesData data;
  std::vector<float>* m_amplitude{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeriesCollection_H
#define EDM4HEP_TimeSeriesCollection_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeries.h"
#include "edm4hep/MutableTimeSeries.h"
#include "edm4hep/TimeSeriesObj.h"
#include "edm4hep/TimeSeriesCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class TimeSeriesCollectionIterator {
public:
  TimeSeriesCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesCollectionIterator(const TimeSeriesCollectionIterator&) = delete;
  TimeSeriesCollectionIterator& operator=(const TimeSeriesCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  TimeSeries operator*();
  TimeSeries* operator->();
  TimeSeriesCollectionIterator& operator++();

private:
  size_t m_index;
  TimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


class TimeSeriesMutableCollectionIterator {
public:
  TimeSeriesMutableCollectionIterator(size_t index, const TimeSeriesObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  TimeSeriesMutableCollectionIterator(const TimeSeriesMutableCollectionIterator&) = delete;
  TimeSeriesMutableCollectionIterator& operator=(const TimeSeriesMutableCollectionIterator&) = delete;

  bool operator!=(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const TimeSeriesMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableTimeSeries operator*();
  MutableTimeSeries* operator->();
  TimeSeriesMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableTimeSeries m_object;
  const TimeSeriesObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class TimeSeriesCollection : public podio::CollectionBase {
public:
  using value_type = TimeSeries;
  using const_iterator = TimeSeriesCollectionIterator;
  using iterator = TimeSeriesMutableCollectionIterator;

  TimeSeriesCollection();
  TimeSeriesCollection(TimeSeriesCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  TimeSeriesCollection(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection& operator=(const TimeSeriesCollection& ) = delete;
  TimeSeriesCollection(TimeSeriesCollection&&) = default;
  TimeSeriesCollection& operator=(TimeSeriesCollection&&) = default;

//  TimeSeriesCollection(TimeSeriesVector* data, uint32_t collectionID);
  ~TimeSeriesCollection();

  constexpr static auto typeName = "edm4hep::TimeSeriesCollection";
  constexpr static auto valueTypeName = "edm4hep::TimeSeries";
  constexpr static auto dataTypeName = "edm4hep::TimeSeriesData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  TimeSeriesCollection* operator->() { return (TimeSeriesCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableTimeSeries create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableTimeSeries create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  TimeSeries operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableTimeSeries operator[](std::size_t index);
  /// Returns the const object of given index
  TimeSeries at(std::size_t index) const;
  /// Returns the object of given index
  MutableTimeSeries at(std::size_t index);


  /// Append object to the collection
  void push_back(TimeSeries object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (TimeSeriesObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<std::uint64_t> cellID(const size_t nElem = 0) const;
  std::vector<float> time(const size_t nElem = 0) const;
  std::vector<float> interval(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class TimeSeriesCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable TimeSeriesCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const TimeSeriesCollection& v);

template<typename... Args>
MutableTimeSeries TimeSeriesCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new TimeSeriesObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, TimeSeriesData} constructor
  obj->m_amplitude = new std::vector<float>();
  m_storage.createRelations(obj);
  return MutableTimeSeries(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const TimeSeriesCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_TimeSeries_CollectionData_H
#define EDM4HEP_TimeSeries_CollectionData_H

// datamodel specific includes
#include "edm4hep/TimeSeriesData.h"
#include "edm4hep/TimeSeriesObj.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using TimeSeriesObjPointerContainer = std::deque<TimeSeriesObj*>;
using TimeSeriesDataContainer = std::vector<TimeSeriesData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class TimeSeriesCollectionData {
public:
  /**
   * The Objs of this collection
   */
  TimeSeriesObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  TimeSeriesCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  TimeSeriesCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  TimeSeriesCollectionData(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData& operator=(const TimeSeriesCollectionData&) = delete;
  TimeSeriesCollectionData(TimeSeriesCollectionData&& other) = default;
  TimeSeriesCollectionData& operator=(TimeSeriesCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~TimeSeriesCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(TimeSeriesObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations

  // members to handle vector members
  podio::UVecPtr<float> m_vec_amplitude{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<float>> m_vecs_amplitude{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<TimeSeriesDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxDATA_H
#define EDM4HEP_RecDqdxDATA_H

#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include <array>
#include <cstdint>

namespace edm4hep {


/** @class RecDqdxData
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdxData {
public:
  ::edm4hep::Quantity dQdx{}; ///< the reconstructed dEdx or dNdx and its error
  std::int16_t particleType{}; ///< particle type, e(0),mu(1),pi(2),K(3),p(4).
  std::int16_t type{}; ///< type.
  std::array<edm4hep::Hypothesis, 5> hypotheses{}; ///< 5 particle hypothesis

  unsigned int hitData_begin{};
  unsigned int hitData_end{};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_H
#define EDM4HEP_RecDqdx_H

#include "edm4hep/RecDqdxObj.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {

class MutableRecDqdx;
class RecDqdxCollection;

/** @class RecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class RecDqdx {

  friend class MutableRecDqdx;
  friend class RecDqdxCollection;
  friend class RecDqdxCollectionIterator;

public:
  using mutable_type = MutableRecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  RecDqdx();
  RecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  RecDqdx(RecDqdxObj* obj);

  /// copy constructor
  RecDqdx(const RecDqdx& other);

  /// copy-assignment operator
  RecDqdx& operator=(RecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~RecDqdx();


public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;


  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const RecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const MutableRecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const RecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(RecDqdx& a, RecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

std::ostream& operator<<(std::ostream& o, const RecDqdx& value);

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_MutableRecDqdx_H
#define EDM4HEP_MutableRecDqdx_H

#include "edm4hep/RecDqdxObj.h"
// Make the immutable class available from its mutable version but not vice versa
#include "edm4hep/RecDqdx.h"

#include "edm4hep/HitLevelData.h"
#include "edm4hep/Hypothesis.h"
#include "edm4hep/Quantity.h"
#include "podio/RelationRange.h"
#include <array>
#include <cstdint>
#include <vector>
#include "podio/ObjectID.h"
#include <ostream>
#include <cstddef>

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

// forward declarations
namespace edm4hep {
class Track;
class MutableTrack;
}


namespace edm4hep {


/** @class MutableRecDqdx
 *  dN/dx or dE/dx info of Track.
 *  @author: Wenxing Fang, IHEP
 */
class MutableRecDqdx {

  friend class RecDqdxCollection;
  friend class RecDqdxMutableCollectionIterator;
  friend class RecDqdx;

public:
  using object_type = RecDqdx;
  using collection_type = RecDqdxCollection;

  /// default constructor
  MutableRecDqdx();
  MutableRecDqdx(edm4hep::Quantity dQdx, std::int16_t particleType, std::int16_t type, std::array<edm4hep::Hypothesis, 5> hypotheses);

  /// constructor from existing RecDqdxObj
  MutableRecDqdx(RecDqdxObj* obj);

  /// copy constructor
  MutableRecDqdx(const MutableRecDqdx& other);

  /// copy-assignment operator
  MutableRecDqdx& operator=(MutableRecDqdx other);

  /// create a mutable deep-copy of the object with identical relations
  MutableRecDqdx clone() const;

  /// destructor
  ~MutableRecDqdx();

  /// conversion to const object
  operator RecDqdx() const;

public:

  /// Access the the reconstructed dEdx or dNdx and its error
  const edm4hep::Quantity& getDQdx() const;

  /// Access the particle type, e(0),mu(1),pi(2),K(3),p(4).
  const std::int16_t& getParticleType() const;

  /// Access the type.
  const std::int16_t& getType() const;

  /// Access the 5 particle hypothesis
  const std::array<edm4hep::Hypothesis, 5>& getHypotheses() const;
  /// Access item i of the 5 particle hypothesis
  const edm4hep::Hypothesis& getHypotheses(size_t i) const;

  /// Access the the corresponding track.
  const edm4hep::Track getTrack() const;

  /// Set the the reconstructed dEdx or dNdx and its error
  void setDQdx(edm4hep::Quantity value);
  /// Get reference to the reconstructed dEdx or dNdx and its error
  edm4hep::Quantity& dQdx();

  /// Set the particle type, e(0),mu(1),pi(2),K(3),p(4).
  void setParticleType(std::int16_t value);

  /// Set the type.
  void setType(std::int16_t value);

  /// Set the 5 particle hypothesis
  void setHypotheses(std::array<edm4hep::Hypothesis, 5> value);
  void setHypotheses(size_t i, edm4hep::Hypothesis value);
  /// Get reference to 5 particle hypothesis
  std::array<edm4hep::Hypothesis, 5>& hypotheses();


  /// Set the the corresponding track.
  void setTrack(edm4hep::Track value);

  void addToHitData(edm4hep::HitLevelData);
  std::size_t hitData_size() const;
  edm4hep::HitLevelData getHitData(std::size_t) const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_begin() const;
  std::vector<edm4hep::HitLevelData>::const_iterator hitData_end() const;
  podio::RelationRange<edm4hep::HitLevelData> getHitData() const;



  /// check whether the object is actually available
  bool isAvailable() const;
  /// disconnect from RecDqdxObj instance
  void unlink() { m_obj = nullptr; }

  bool operator==(const MutableRecDqdx& other) const { return m_obj == other.m_obj; }
  bool operator==(const RecDqdx& other) const;

  // less comparison operator, so that objects can be e.g. stored in sets.
  bool operator<(const MutableRecDqdx& other) const { return m_obj < other.m_obj; }

  podio::ObjectID id() const { return getObjectID(); }

  const podio::ObjectID getObjectID() const;

  friend void swap(MutableRecDqdx& a, MutableRecDqdx& b) {
    using std::swap;
    swap(a.m_obj, b.m_obj); // swap out the internal pointers
  }

private:
  RecDqdxObj* m_obj;
};

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const MutableRecDqdx& value);
#endif


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxOBJ_H
#define EDM4HEP_RecDqdxOBJ_H

// data model specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/HitLevelData.h"
#include <vector>

#include "podio/ObjBase.h"
#include <vector>
// forward declarations
namespace edm4hep {
class Track;
}


namespace edm4hep {

class RecDqdx;

class RecDqdxObj : public podio::ObjBase {
public:
  /// constructor
  RecDqdxObj();
  /// copy constructor (does a deep-copy of relation containers)
  RecDqdxObj(const RecDqdxObj&);
  /// constructor from ObjectID and RecDqdxData
  /// does not initialize the internal relation containers
  RecDqdxObj(const podio::ObjectID id, RecDqdxData data);
  /// No assignment operator
  RecDqdxObj& operator=(const RecDqdxObj&) = delete;
  virtual ~RecDqdxObj();

public:
  RecDqdxData data;
  edm4hep::Track* m_track{nullptr};
  std::vector<edm4hep::HitLevelData>* m_hitData{nullptr};
};

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdxCollection_H
#define EDM4HEP_RecDqdxCollection_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdx.h"
#include "edm4hep/MutableRecDqdx.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/RecDqdxCollectionData.h"

// podio specific includes
#include "podio/ICollectionProvider.h"
#include "podio/CollectionBase.h"
#include "podio/CollectionIDTable.h"

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
#include "nlohmann/json_fwd.hpp"
#endif

#include <string>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
#include <ostream>
#include <mutex>
#include <memory>
#include <cstddef>

namespace podio {
  struct RelationNames;
}

namespace edm4hep {



class RecDqdxCollectionIterator {
public:
  RecDqdxCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxCollectionIterator(const RecDqdxCollectionIterator&) = delete;
  RecDqdxCollectionIterator& operator=(const RecDqdxCollectionIterator&) = delete;

  bool operator!=(const RecDqdxCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  RecDqdx operator*();
  RecDqdx* operator->();
  RecDqdxCollectionIterator& operator++();

private:
  size_t m_index;
  RecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


class RecDqdxMutableCollectionIterator {
public:
  RecDqdxMutableCollectionIterator(size_t index, const RecDqdxObjPointerContainer* collection) : m_index(index), m_object(nullptr), m_collection(collection) {}

  RecDqdxMutableCollectionIterator(const RecDqdxMutableCollectionIterator&) = delete;
  RecDqdxMutableCollectionIterator& operator=(const RecDqdxMutableCollectionIterator&) = delete;

  bool operator!=(const RecDqdxMutableCollectionIterator& x) const {
    return m_index != x.m_index; // TODO: may not be complete
  }

  bool operator==(const RecDqdxMutableCollectionIterator& x) const {
    return m_index ==  x.m_index; // TODO: may not be complete
  }

  MutableRecDqdx operator*();
  MutableRecDqdx* operator->();
  RecDqdxMutableCollectionIterator& operator++();

private:
  size_t m_index;
  MutableRecDqdx m_object;
  const RecDqdxObjPointerContainer* m_collection;
};


/**
A Collection is identified by an ID.
*/
class RecDqdxCollection : public podio::CollectionBase {
public:
  using value_type = RecDqdx;
  using const_iterator = RecDqdxCollectionIterator;
  using iterator = RecDqdxMutableCollectionIterator;

  RecDqdxCollection();
  RecDqdxCollection(RecDqdxCollectionData&& data, bool isSubsetColl);
  // This is a move-only type
  RecDqdxCollection(const RecDqdxCollection& ) = delete;
  RecDqdxCollection& operator=(const RecDqdxCollection& ) = delete;
  RecDqdxCollection(RecDqdxCollection&&) = default;
  RecDqdxCollection& operator=(RecDqdxCollection&&) = default;

//  RecDqdxCollection(RecDqdxVector* data, uint32_t collectionID);
  ~RecDqdxCollection();

  constexpr static auto typeName = "edm4hep::RecDqdxCollection";
  constexpr static auto valueTypeName = "edm4hep::RecDqdx";
  constexpr static auto dataTypeName = "edm4hep::RecDqdxData";

  void clear() final;

  /// Print this collection to the passed stream
  void print(std::ostream& os=std::cout, bool flush=true) const final;

  /// operator to allow pointer like calling of members a la LCIO
  RecDqdxCollection* operator->() { return (RecDqdxCollection*) this; }

  /// Append a new object to the collection, and return this object.
  MutableRecDqdx create();

  /// Append a new object to the collection, and return this object.
  /// Initialized with the parameters given
  template<typename... Args>
  MutableRecDqdx create(Args&&... args);

  /// number of elements in the collection
  std::size_t size() const final;

  /// Is the collection empty
  bool empty() const final;

  /// fully qualified type name
  const std::string_view getTypeName() const final { return typeName; }
  /// fully qualified type name of elements - with namespace
  const std::string_view getValueTypeName() const final { return valueTypeName; }
  /// fully qualified type name of stored POD elements - with namespace
  const std::string_view getDataTypeName() const final { return dataTypeName; }
  /// schema version
  podio::SchemaVersionT getSchemaVersion() const final;

  bool isSubsetCollection() const final {
    return m_isSubsetColl;
  }

  void setSubsetCollection(bool setSubset=true) final;

  /// Returns the const object of given index
  RecDqdx operator[](std::size_t index) const;
  /// Returns the object of a given index
  MutableRecDqdx operator[](std::size_t index);
  /// Returns the const object of given index
  RecDqdx at(std::size_t index) const;
  /// Returns the object of given index
  MutableRecDqdx at(std::size_t index);


  /// Append object to the collection
  void push_back(RecDqdx object);

  void prepareForWrite() const final;
  void prepareAfterRead() final;
  bool setReferences(const podio::ICollectionProvider* collectionProvider) final;

  /// Get the collection buffers for this collection
  podio::CollectionWriteBuffers getBuffers() final;

  void setID(uint32_t ID) final {
    m_collectionID = ID;
    if (!m_isSubsetColl) {
      std::for_each(m_storage.entries.begin(), m_storage.entries.end(),
                  [ID] (RecDqdxObj* obj) { obj->id = {obj->id.index, static_cast<uint32_t>(ID)}; }
      );
    }
    m_isValid = true;
  };

  uint32_t getID() const final {
    return m_collectionID;
  }

  bool isValid() const final {
    return m_isValid;
  }

  size_t getDatamodelRegistryIndex() const final;

  // support for the iterator protocol
  iterator begin() {
    return iterator(0, &m_storage.entries);
  }
  const_iterator begin() const {
    return const_iterator(0, &m_storage.entries);
  }
  iterator end() {
    return iterator(m_storage.entries.size(), &m_storage.entries);
  }
  const_iterator end() const {
    return const_iterator(m_storage.entries.size(), &m_storage.entries);
  }

  std::vector<edm4hep::Quantity> dQdx(const size_t nElem = 0) const;
  std::vector<std::int16_t> particleType(const size_t nElem = 0) const;
  std::vector<std::int16_t> type(const size_t nElem = 0) const;
  std::vector<std::array<edm4hep::Hypothesis, 5>> hypotheses(const size_t nElem = 0) const;

private:
  // For setReferences, we need to give our own CollectionData access to our
  // private entries. Otherwise we would need to expose a public member function
  // that gives access to the Obj* which is definitely not what we want
  friend class RecDqdxCollectionData;

  bool m_isValid{false};
  mutable bool m_isPrepared{false};
  bool m_isSubsetColl{false};
  uint32_t m_collectionID{0};
  mutable std::unique_ptr<std::mutex> m_storageMtx{nullptr};
  mutable RecDqdxCollectionData m_storage{};
};

std::ostream& operator<<(std::ostream& o, const RecDqdxCollection& v);

template<typename... Args>
MutableRecDqdx RecDqdxCollection::create(Args&&... args) {
  if (m_isSubsetColl) {
    throw std::logic_error("Cannot create new elements on a subset collection");
  }
  const int size = m_storage.entries.size();
  auto obj = new RecDqdxObj({size, m_collectionID}, {std::forward<Args>(args)...});
  m_storage.entries.push_back(obj);

  // Need to initialize the relation vectors manually for the {ObjectID, RecDqdxData} constructor
  obj->m_hitData = new std::vector<edm4hep::HitLevelData>();
  m_storage.createRelations(obj);
  return MutableRecDqdx(obj);
}

#if defined(PODIO_JSON_OUTPUT) && !defined(__CLING__)
void to_json(nlohmann::json& j, const RecDqdxCollection& collection);
#endif

} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#ifndef EDM4HEP_RecDqdx_CollectionData_H
#define EDM4HEP_RecDqdx_CollectionData_H

// datamodel specific includes
#include "edm4hep/RecDqdxData.h"
#include "edm4hep/RecDqdxObj.h"
#include "edm4hep/Track.h"

// schema evolution specific includes

// podio specific includes
#include "podio/CollectionBuffers.h"
#include "podio/ICollectionProvider.h"

#include <deque>
#include <memory>

namespace edm4hep {


using RecDqdxObjPointerContainer = std::deque<RecDqdxObj*>;
using RecDqdxDataContainer = std::vector<RecDqdxData>;


/**
 * Class encapsulating everything related to storage of data that is needed by a
 * collection.
 */
class RecDqdxCollectionData {
public:
  /**
   * The Objs of this collection
   */
  RecDqdxObjPointerContainer entries{};

  /**
   * Default constructor setting up the necessary buffers
   */
  RecDqdxCollectionData();

  /**
   * Constructor from existing I/O buffers
   */
  RecDqdxCollectionData(podio::CollectionReadBuffers buffers, bool isSubsetColl);

  /**
   * Non copy-able, move-only class
   */
  RecDqdxCollectionData(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData& operator=(const RecDqdxCollectionData&) = delete;
  RecDqdxCollectionData(RecDqdxCollectionData&& other) = default;
  RecDqdxCollectionData& operator=(RecDqdxCollectionData&& other) = default;

  /**
   * Deconstructor
   */
  ~RecDqdxCollectionData() = default;

  void clear(bool isSubsetColl);

  podio::CollectionWriteBuffers getCollectionBuffers(bool isSubsetColl);

  void prepareForWrite(bool isSubsetColl);

  void prepareAfterRead(uint32_t collectionID);

  void makeSubsetCollection();

  void createRelations(RecDqdxObj* obj);

  bool setReferences(const podio::ICollectionProvider* collectionProvider, bool isSubsetColl);

private:
  // members to handle 1-to-N-relations
  podio::UVecPtr<edm4hep::Track> m_rel_track{nullptr}; ///< Relation buffer for read / write

  // members to handle vector members
  podio::UVecPtr<edm4hep::HitLevelData> m_vec_hitData{nullptr}; /// combined vector of all objects in collection
  std::vector<podio::UVecPtr<edm4hep::HitLevelData>> m_vecs_hitData{}; /// pointers to individual member vectors

  // I/O related buffers
  podio::CollRefCollection m_refCollections{};
  podio::VectorMembersInfo m_vecmem_info{};
  std::unique_ptr<RecDqdxDataContainer> m_data{nullptr};
};


} // namespace edm4hep


#endif
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

#include "podio/DatamodelRegistry.h"
#include "podio/SchemaEvolution.h"

namespace edm4hep::meta {
/**
 * The complete definition of the datamodel at generation time in JSON format.
 */
static constexpr auto edm4hep__JSONDefinition = R"DATAMODELDEF({"options": {"getSyntax": true, "exposePODMembers": false, "includeSubfolder": "edm4hep/", "schema_version": 1}, "schema_version": 1, "components": {"edm4hep::Vector3f": {"Members": ["float x", "float y", "float z"], "ExtraCode": {"declaration": " constexpr Vector3f() : x(0),y(0),z(0) {}\n constexpr Vector3f(float xx, float yy, float zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3f(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3f& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr float operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector3d": {"Members": ["double x", "double y", "double z"], "ExtraCode": {"declaration": " constexpr Vector3d() : x(0),y(0),z(0) {}\n constexpr Vector3d(double xx, double yy, double zz) : x(xx),y(yy),z(zz) {}\n constexpr Vector3d(const double* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr Vector3d(const float* v) : x(v[0]),y(v[1]),z(v[2]) {}\n constexpr bool operator==(const Vector3d& v) const { return (x==v.x&&y==v.y&&z==v.z) ; }\n constexpr double operator[](unsigned i) const { return *( &x + i ) ; }\n "}}, "edm4hep::Vector2i": {"Members": ["std::int32_t a", "std::int32_t b"], "ExtraCode": {"declaration": " constexpr Vector2i() : a(0),b(0) {}\n constexpr Vector2i(int32_t aa, int32_t bb) : a(aa),b(bb) {}\n constexpr Vector2i( const int32_t* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2i& v) const { return (a==v.a&&b==v.b) ; }\n constexpr int operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::Vector2f": {"Members": ["float a", "float b"], "ExtraCode": {"declaration": " constexpr Vector2f() : a(0),b(0) {}\n constexpr Vector2f(float aa,float bb) : a(aa),b(bb) {}\n constexpr Vector2f(const float* v) : a(v[0]), b(v[1]) {}\n constexpr bool operator==(const Vector2f& v) const { return (a==v.a&&b==v.b) ; }\n constexpr float operator[](unsigned i) const { return *( &a + i ) ; }\n "}}, "edm4hep::TrackState": {"Members": ["std::int32_t location // for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation", "float D0 // transverse impact parameter", "float phi // azimuthal angle", "float omega // is the signed curvature of the track in [1/mm].", "float Z0 // longitudinal impact parameter", "float tanLambda // lambda is the dip angle of the track in r-z", "float time // time of the track at this trackstate", "edm4hep::Vector3f referencePoint // Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]", "std::array<float, 21> covMatrix // lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix."], "ExtraCode": {"declaration": " static const int AtOther = 0 ; // any location other than the ones defined below\n static const int AtIP = 1 ;\n static const int AtFirstHit = 2 ;\n static const int AtLastHit = 3 ;\n static const int AtCalorimeter = 4 ;\n static const int AtVertex = 5 ;\n static const int LastLocation = AtVertex  ;\n "}}, "edm4hep::ObjectID": {"Members": ["std::int32_t index", "std::int32_t collectionID"], "ExtraCode": {"includes": "#include <podio/ObjectID.h>\n", "declaration": " ObjectID() = default;\n ObjectID(const podio::ObjectID& id ): index(id.index), collectionID(id.collectionID) {}\n "}}, "edm4hep::Quantity": {"Members": ["std::int16_t type // flag identifying how to interpret the quantity", "float value // value of the quantity", "float error // error on the value of the quantity"]}, "edm4hep::Hypothesis": {"Members": ["float chi2 // chi2", "float expected // expected value", "float sigma // sigma value"]}, "edm4hep::HitLevelData": {"Members": ["std::uint64_t cellID // cell id", "std::uint32_t N // number of reconstructed ionization cluster.", "float eDep // reconstructed energy deposit [GeV].", "float pathLength // track path length [mm]."]}}, "datatypes": {"edm4hep::EventHeader": {"Description": "Event Header. Additional parameters are assumed to go into the metadata tree.", "Author": "F.Gaede", "Members": ["std::int32_t eventNumber // event number", "std::int32_t runNumber // run number", "std::uint64_t timeStamp // time stamp", "float weight // event weight"], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCParticle": {"Description": "The Monte Carlo particle - based on the lcio::MCParticle.", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the particle", "std::int32_t generatorStatus // status of the particle as defined by the generator", "std::int32_t simulatorStatus // status of the particle from the simulation program - use BIT constants below", "float charge // particle charge", "float time // creation time of the particle in [ns] wrt. the event, e.g. for preassigned decays or decays in flight from the simulator.", "double mass // mass of the particle in [GeV]", "edm4hep::Vector3d vertex // production vertex of the particle in [mm].", "edm4hep::Vector3d endpoint // endpoint of the particle in [mm]", "edm4hep::Vector3f momentum // particle 3-momentum at the production vertex in [GeV]", "edm4hep::Vector3f momentumAtEndpoint // particle 3-momentum at the endpoint in [GeV]", "edm4hep::Vector3f spin // spin (helicity) vector of the particle.", "edm4hep::Vector2i colorFlow // color flow as defined by the generator"], "OneToManyRelations": ["edm4hep::MCParticle parents // The parents of this particle.", "edm4hep::MCParticle daughters // The daughters this particle."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }                               \n void setCreatedInSimulation(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITCreatedInSimulation , bitval ) ) ;  }  \t\t     \n void setBackscatter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITBackscatter , bitval ) ) ;   }  \t\t\t     \n void setVertexIsNotEndpointOfParent(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITVertexIsNotEndpointOfParent , bitval ) ) ; } \n void setDecayedInTracker(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInTracker , bitval ) ) ;   }  \t\t     \n void setDecayedInCalorimeter(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITDecayedInCalorimeter , bitval ) ) ;   }  \t\t     \n void setHasLeftDetector(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITLeftDetector , bitval ) ) ;   }  \t\t\t     \n void setStopped(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITStopped , bitval ) ) ;   }  \t\t\t\t     \n void setOverlay(bool bitval) { setSimulatorStatus( set_bit( getSimulatorStatus() , BITOverlay , bitval ) ) ;   }         \n "}, "ExtraCode": {"declaration": " // define the bit positions for the simulation flag\n static const int BITEndpoint = 31;\n static const int BITCreatedInSimulation = 30;\n static const int BITBackscatter = 29 ;\n static const int BITVertexIsNotEndpointOfParent = 28 ;  \n static const int BITDecayedInTracker = 27 ; \n static const int BITDecayedInCalorimeter = 26 ;   \n static const int BITLeftDetector = 25 ;     \n static const int BITStopped = 24 ;    \n static const int BITOverlay = 23 ;    \n /// return energy computed from momentum and mass \n double getEnergy() const { return sqrt( getMomentum()[0]*getMomentum()[0]+getMomentum()[1]*getMomentum()[1]+\n getMomentum()[2]*getMomentum()[2] + getMass()*getMass()  )  ;} \n\n/// True if the particle has been created by the simulation program (rather than the generator).     \n bool isCreatedInSimulation() const { return ( getSimulatorStatus() & ( 0x1 << BITCreatedInSimulation ))  ; }    \n /// True if the particle is the result of a backscatter from a calorimeter shower. \n bool isBackscatter() const { return ( getSimulatorStatus() & ( 0x1 << BITBackscatter )) ; }   \n /// True if the particle's vertex is not the endpoint of the  parent particle.     \n bool vertexIsNotEndpointOfParent() const { return ( getSimulatorStatus() & ( 0x1 << BITVertexIsNotEndpointOfParent )) ; } \n /// True if the particle has interacted in a tracking region.                \n bool isDecayedInTracker() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInTracker )) ; }     \n /// True if the particle has interacted in a calorimeter region.             \n bool isDecayedInCalorimeter() const { return ( getSimulatorStatus() & ( 0x1 << BITDecayedInCalorimeter )) ; }   \n /// True if the particle has left the world volume undecayed.                \n bool hasLeftDetector() const { return ( getSimulatorStatus() & ( 0x1 << BITLeftDetector )) ; }\n /// True if the particle has been stopped by the simulation program.         \n bool isStopped() const { return ( getSimulatorStatus() & ( 0x1 << BITStopped )) ; }     \n /// True if the particle has been overlayed by the simulation (or digitization)  program.\n bool isOverlay() const { return ( getSimulatorStatus() & ( 0x1 << BITOverlay )) ; }     \n "}, "VectorMembers": [], "OneToOneRelations": []}, "edm4hep::SimTrackerHit": {"Description": "Simulated tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float EDep // energy deposited in the hit [GeV].", "float time // proper time of the hit in the lab frame in [ns].", "float pathLength // path length of the particle in the sensitive material that resulted in this hit.", "std::int32_t quality // quality bit flag.", "edm4hep::Vector3d position // the hit position in [mm].", "edm4hep::Vector3f momentum // the 3-momentum of the particle at the hits position in [GeV]"], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // MCParticle that caused the hit."], "MutableExtraCode": {"includes": "#include <cmath>", "declaration": " int32_t  set_bit(int32_t val, int num, bool bitval){ return (val & ~(1<<num)) | (bitval << num); }\n void setOverlay(bool val) { setQuality( set_bit( getQuality() , BITOverlay , val ) ) ;   }\n void setProducedBySecondary(bool val) { setQuality( set_bit( getQuality() , BITProducedBySecondary , val ) ) ;   }\n "}, "ExtraCode": {"declaration": " static const int  BITOverlay = 31;\n static const int  BITProducedBySecondary = 30;\n bool isOverlay() const { return getQuality() & (1 << BITOverlay) ; }\n bool isProducedBySecondary() const { return getQuality() & (1 << BITProducedBySecondary) ; }\n double x() const {return getPosition()[0];}\n double y() const {return getPosition()[1];}\n double z() const {return getPosition()[2];}\n double rho() const {return sqrt(x()*x() + y()*y());}\n "}, "VectorMembers": [], "OneToManyRelations": []}, "edm4hep::CaloHitContribution": {"Description": "Monte Carlo contribution to SimCalorimeterHit", "Author": "F.Gaede, DESY", "Members": ["std::int32_t PDG // PDG code of the shower particle that caused this contribution.", "float energy // energy in [GeV] of the this contribution", "float time // time in [ns] of this contribution", "edm4hep::Vector3f stepPosition // position of this energy deposition (step) [mm]"], "OneToOneRelations": ["edm4hep::MCParticle particle // primary MCParticle that caused the shower responsible for this contribution to the hit."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimCalorimeterHit": {"Description": "Simulated calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "float energy // energy of the hit in [GeV].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm]."], "OneToManyRelations": ["edm4hep::CaloHitContribution contributions // Monte Carlo step contribution - parallel to particle"], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawCalorimeterHit": {"Description": "Raw calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "std::int32_t amplitude // amplitude of the hit in ADC counts.", "std::int32_t timeStamp // time stamp for the hit."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::CalorimeterHit": {"Description": "Calorimeter hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific (geometrical) cell id.", "float energy // energy of the hit in [GeV].", "float energyError // error of the hit energy in [GeV].", "float time // time of the hit in [ns].", "edm4hep::Vector3f position // position of the hit in world coordinates in [mm].", "std::int32_t type // type of hit. Mapping of integer types to names via collection parameters \"CalorimeterHitTypeNames\" and \"CalorimeterHitTypeValues\"."], "VectorMembers": [], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ParticleID": {"Description": "ParticleID", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // userdefined type", "std::int32_t PDG // PDG code of this id - ( 999999 ) if unknown.", "std::int32_t algorithmType // type of the algorithm/module that created this hypothesis", "float likelihood // likelihood of this hypothesis - in a user defined normalization."], "VectorMembers": ["float parameters // parameters associated with this hypothesis. Check/set collection parameters ParameterNames_PIDAlgorithmTypeName for decoding the indices."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Cluster": {"Description": "Calorimeter Hit Cluster", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of cluster. Bits 16-31 are used internally.", "float energy // energy of the cluster [GeV]", "float energyError // error on the energy", "edm4hep::Vector3f position // position of the cluster [mm]", "std::array<float, 6> positionError // covariance matrix of the position (6 Parameters)", "float iTheta // intrinsic direction of cluster at position  Theta. Not to be confused with direction cluster is seen from IP.", "float phi // intrinsic direction of cluster at position - Phi. Not to be confused with direction cluster is seen from IP.", "edm4hep::Vector3f directionError // covariance matrix of the direction (3 Parameters) [mm^2]"], "VectorMembers": ["float shapeParameters // shape parameters - check/set collection parameter ClusterShapeParameters for size and names of parameters.", "float subdetectorEnergies // energy observed in a particular subdetector. Check/set collection parameter ClusterSubdetectorNames for decoding the indices of the array."], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been combined to this cluster.", "edm4hep::CalorimeterHit hits // hits that have been combined to this cluster.", "edm4hep::ParticleID particleIDs // particle IDs (sorted by their likelihood)"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHit": {"Description": "Tracker hit", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerHitPlane": {"Description": "Tracker hit plane", "Author": "Placido Fernandez Declara, CERN", "Members": ["std::uint64_t cellID // ID of the sensor that created this hit", "std::int32_t type // type of raw data hit, either one of edm4hep::RawTimeSeries, edm4hep::SIMTRACKERHIT - see collection parameters \"TrackerHitTypeNames\" and \"TrackerHitTypeValues\".", "std::int32_t quality // quality bit flag of the hit.", "float time // time of the hit [ns].", "float eDep // energy deposited on the hit [GeV].", "float eDepError // error measured on EDep [GeV].", "edm4hep::Vector2f u // measurement direction vector, u lies in the x-y plane", "edm4hep::Vector2f v // measurement direction vector, v is along z", "float du // measurement error along the direction", "float dv // measurement error along the direction", "edm4hep::Vector3d position // hit position in [mm].", "std::array<float, 6> covMatrix // covariance of the position (x,y,z), stored as lower triangle matrix. i.e. cov(x,x) , cov(y,x) , cov(y,y) , cov(z,x) , cov(z,y) , cov(z,z)"], "VectorMembers": ["edm4hep::ObjectID rawHits // raw data hits. Check getType to get actual data type."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RawTimeSeries": {"Description": "Raw data of a detector readout", "Author": "F.Gaede, DESY", "Members": ["std::uint64_t cellID // detector specific cell id.", "std::int32_t quality // quality flag for the hit.", "float time // time of the hit [ns].", "float charge // integrated charge of the hit [fC].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["std::int32_t adcCounts // raw data (32-bit) word at i."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Track": {"Description": "Reconstructed track", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // flagword that defines the type of track.Bits 16-31 are used internally", "float chi2 // Chi^2 of the track fit", "std::int32_t ndf // number of degrees of freedom of the track fit", "float dEdx // dEdx of the track.", "float dEdxError // error of dEdx.", "float radiusOfInnermostHit // radius of the innermost hit that has been used in the track fit"], "VectorMembers": ["std::int32_t subdetectorHitNumbers // number of hits in particular subdetectors.Check/set collection variable TrackSubdetectorNames for decoding the indices", "edm4hep::TrackState trackStates // track states", "edm4hep::Quantity dxQuantities // different measurements of dx quantities"], "OneToManyRelations": ["edm4hep::TrackerHit trackerHits // hits that have been used to create this track", "edm4hep::Track tracks // tracks (segments) that have been combined to create this track"], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::Vertex": {"Description": "Vertex", "Author": "F.Gaede, DESY", "Members": ["std::int32_t primary // boolean flag, if vertex is the primary vertex of the event", "float chi2 // chi-squared of the vertex fit", "float probability // probability of the vertex fit", "edm4hep::Vector3f position // [mm] position of the vertex.", "std::array<float, 6> covMatrix // covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),... )", "std::int32_t algorithmType // type code for the algorithm that has been used to create the vertex - check/set the collection parameters AlgorithmName and AlgorithmType."], "VectorMembers": ["float parameters // additional parameters related to this vertex - check/set the collection parameter \"VertexParameterNames\" for the parameters meaning."], "OneToOneRelations": ["edm4hep::ReconstructedParticle associatedParticle // reconstructed particle associated to this vertex."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::ReconstructedParticle": {"Description": "Reconstructed Particle", "Author": "F.Gaede, DESY", "Members": ["std::int32_t type // type of reconstructed particle. Check/set collection parameters ReconstructedParticleTypeNames and ReconstructedParticleTypeValues.", "float energy // [GeV] energy of the reconstructed particle. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f momentum // [GeV] particle momentum. Four momentum state is not kept consistent internally.", "edm4hep::Vector3f referencePoint // [mm] reference, i.e. where the particle has been measured", "float charge // charge of the reconstructed particle.", "float mass // [GeV] mass of the reconstructed particle, set independently from four vector. Four momentum state is not kept consistent internally.", "float goodnessOfPID // overall goodness of the PID on a scale of [0;1]", "std::array<float, 10> covMatrix // cvariance matrix of the reconstructed particle 4vector (10 parameters). Stored as lower triangle matrix of the four momentum (px,py,pz,E), i.e. cov(px,px), cov(py,##"], "OneToOneRelations": ["edm4hep::Vertex startVertex // start vertex associated to this particle", "edm4hep::ParticleID particleIDUsed // particle Id used for the kinematics of this particle"], "OneToManyRelations": ["edm4hep::Cluster clusters // clusters that have been used for this particle.", "edm4hep::Track tracks // tracks that have been used for this particle.", "edm4hep::ReconstructedParticle particles // reconstructed particles that have been combined to this particle.", "edm4hep::ParticleID particleIDs // particle Ids (not sorted by their likelihood)"], "ExtraCode": {"declaration": " bool isCompound() const { return particles_size() > 0 ;}\n "}, "MutableExtraCode": {"declaration": " //vertex where the particle decays This method actually returns the start vertex from the first daughter particle found.\n //TODO: edm4hep::Vertex  getEndVertex() { return  edm4hep::Vertex(  (getParticles(0).isAvailable() ? getParticles(0).getStartVertex() :  edm4hep::Vertex(0,0) ) ) ; }\n "}, "VectorMembers": []}, "edm4hep::MCRecoParticleAssociation": {"Description": "Used to keep track of the correspondence between MC and reconstructed particles", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloAssociation": {"Description": "Association between a CaloHit and the corresponding simulated CaloHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::SimCalorimeterHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerAssociation": {"Description": "Association between a TrackerHit and the corresponding simulated TrackerHit", "Author": "C. Bernet, B. Hegner", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHit rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackerHitPlaneAssociation": {"Description": "Association between a TrackerHitPlane and the corresponding simulated TrackerHit", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::TrackerHitPlane rec // reference to the reconstructed hit", "edm4hep::SimTrackerHit sim // reference to the simulated hit"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoCaloParticleAssociation": {"Description": "Association between a CalorimeterHit and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::CalorimeterHit rec // reference to the reconstructed hit", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoClusterParticleAssociation": {"Description": "Association between a Cluster and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Cluster rec // reference to the cluster", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::MCRecoTrackParticleAssociation": {"Description": "Association between a Track and a MCParticle", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::Track rec // reference to the track", "edm4hep::MCParticle sim // reference to the Monte-Carlo particle"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecoParticleVertexAssociation": {"Description": "Association between a Reconstructed Particle and a Vertex", "Author": "Placido Fernandez Declara", "Members": ["float weight // weight of this association"], "OneToOneRelations": ["edm4hep::ReconstructedParticle rec // reference to the reconstructed particle", "edm4hep::Vertex vertex // reference to the vertex"], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::SimPrimaryIonizationCluster": {"Description": "Simulated Primary Ionization", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // the primary ionization's time in the lab frame [ns].", "edm4hep::Vector3d position // the primary ionization's position [mm].", "std::int16_t type // type."], "VectorMembers": ["std::uint64_t electronCellID // cell id.", "float electronTime // the time in the lab frame [ns].", "edm4hep::Vector3d electronPosition // the position in the lab frame [mm].", "float pulseTime // the pulse's time in the lab frame [ns].", "float pulseAmplitude // the pulse's amplitude [fC]."], "OneToOneRelations": ["edm4hep::MCParticle MCParticle // the particle that caused the ionizing collisions."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TrackerPulse": {"Description": "Reconstructed Tracker Pulse", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // time [ns].", "float charge // charge [fC].", "std::int16_t quality // quality.", "std::array<float, 3> covMatrix // lower triangle covariance matrix of the charge(c) and time(t) measurements."], "OneToOneRelations": ["edm4hep::TimeSeries timeSeries // Optionally, the timeSeries that has been used to create the pulse can be stored with the pulse."], "VectorMembers": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecIonizationCluster": {"Description": "Reconstructed Ionization Cluster", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float significance // significance.", "std::int16_t type // type."], "OneToManyRelations": ["edm4hep::TrackerPulse trackerPulse // the TrackerPulse used to create the ionization cluster."], "VectorMembers": [], "OneToOneRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::TimeSeries": {"Description": "Calibrated Detector Data", "Author": "Wenxing Fang, IHEP", "Members": ["std::uint64_t cellID // cell id.", "float time // begin time [ns].", "float interval // interval of each sampling [ns]."], "VectorMembers": ["float amplitude // calibrated detector data."], "OneToOneRelations": [], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}, "edm4hep::RecDqdx": {"Description": "dN/dx or dE/dx info of Track.", "Author": "Wenxing Fang, IHEP", "Members": ["edm4hep::Quantity dQdx // the reconstructed dEdx or dNdx and its error", "std::int16_t particleType // particle type, e(0),mu(1),pi(2),K(3),p(4).", "std::int16_t type // type.", "std::array<edm4hep::Hypothesis, 5> hypotheses // 5 particle hypothesis"], "VectorMembers": ["edm4hep::HitLevelData hitData // hit level data"], "OneToOneRelations": ["edm4hep::Track track // the corresponding track."], "OneToManyRelations": [], "ExtraCode": {}, "MutableExtraCode": {}}}})DATAMODELDEF";


/**
 * The names of all relations and vector members for all datatypes
 */
inline podio::RelationNameMapping edm4hep__getRelationNames() {
  using namespace std::string_view_literals;
  return {
    {"edm4hep::EventHeader"sv,
      {  },
      {  },
    },
    {"edm4hep::MCParticle"sv,
      { "parents"sv, "daughters"sv },
      {  },
    },
    {"edm4hep::SimTrackerHit"sv,
      { "MCParticle"sv },
      {  },
    },
    {"edm4hep::CaloHitContribution"sv,
      { "particle"sv },
      {  },
    },
    {"edm4hep::SimCalorimeterHit"sv,
      { "contributions"sv },
      {  },
    },
    {"edm4hep::RawCalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::CalorimeterHit"sv,
      {  },
      {  },
    },
    {"edm4hep::ParticleID"sv,
      {  },
      { "parameters"sv },
    },
    {"edm4hep::Cluster"sv,
      { "clusters"sv, "hits"sv, "particleIDs"sv },
      { "shapeParameters"sv, "subdetectorEnergies"sv },
    },
    {"edm4hep::TrackerHit"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::TrackerHitPlane"sv,
      {  },
      { "rawHits"sv },
    },
    {"edm4hep::RawTimeSeries"sv,
      {  },
      { "adcCounts"sv },
    },
    {"edm4hep::Track"sv,
      { "trackerHits"sv, "tracks"sv },
      { "subdetectorHitNumbers"sv, "trackStates"sv, "dxQuantities"sv },
    },
    {"edm4hep::Vertex"sv,
      { "associatedParticle"sv },
      { "parameters"sv },
    },
    {"edm4hep::ReconstructedParticle"sv,
      { "clusters"sv, "tracks"sv, "particles"sv, "particleIDs"sv, "startVertex"sv, "particleIDUsed"sv },
      {  },
    },
    {"edm4hep::MCRecoParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackerHitPlaneAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoCaloParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoClusterParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::MCRecoTrackParticleAssociation"sv,
      { "rec"sv, "sim"sv },
      {  },
    },
    {"edm4hep::RecoParticleVertexAssociation"sv,
      { "rec"sv, "vertex"sv },
      {  },
    },
    {"edm4hep::SimPrimaryIonizationCluster"sv,
      { "MCParticle"sv },
      { "electronCellID"sv, "electronTime"sv, "electronPosition"sv, "pulseTime"sv, "pulseAmplitude"sv },
    },
    {"edm4hep::TrackerPulse"sv,
      { "timeSeries"sv },
      {  },
    },
    {"edm4hep::RecIonizationCluster"sv,
      { "trackerPulse"sv },
      {  },
    },
    {"edm4hep::TimeSeries"sv,
      {  },
      { "amplitude"sv },
    },
    {"edm4hep::RecDqdx"sv,
      { "track"sv },
      { "hitData"sv },
    },
  };
}

/**
 * The schema version at generation time
 */
static constexpr podio::SchemaVersionT schemaVersion = 1;

/**
 * The helper class that takes care of registering the datamodel definition to
 * the DatamodelRegistry and to provide the index in that registry.
 *
 * Implemented as a singleton mainly to ensure only a single registration of
 * each datamodel, during the constructor
 */
class DatamodelRegistryIndex {
public:
  static size_t value() {
    static const auto relationNames = edm4hep__getRelationNames();
    static auto index = DatamodelRegistryIndex(podio::DatamodelRegistry::mutInstance().registerDatamodel("edm4hep", edm4hep__JSONDefinition, relationNames));
    return index.m_value;
  }
private:
  DatamodelRegistryIndex(size_t v) : m_value(v) {}
  size_t m_value{podio::DatamodelRegistry::NoDefinitionAvailable};
};


namespace static_registration {
  // The usual trick via an IIFE and a const variable that we assign to, to
  // ensure that we populate this before everything starts
  inline  bool ensureRegistration() {
    const static auto reg = []() {
      return edm4hep::meta::DatamodelRegistryIndex::value() != podio::DatamodelRegistry::NoDefinitionAvailable;
    }();
    return reg;
  }

  const auto registrationEnsured = ensureRegistration();
}

} // namespace edm4hep::meta

#undef  _BACKWARD_BACKWARD_WARNING_H

ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.7112, px=1.68427,py=0.302399,pz=1.04781e-16,theta=90,phi=10.1786
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.40557, px=4.33005,py=0.812242,pz=2.69764e-16,theta=90,phi=10.6242
DetSimAlg.G4Pri...   INFO Start a new event 1
ToolSvc.Edm4hep...   INFO Event 1
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 672 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 672 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.79772, px=6.66312,py=1.34602,pz=4.1624e-16,theta=90,phi=11.4207
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.24643, px=2.19682,py=0.469497,pz=1.37554e-16,theta=90,phi=12.0636
DetSimAlg.G4Pri...   INFO Start a new event 2
ToolSvc.Edm4hep...   INFO Event 2
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 682 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 682 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.59464, px=7.47753,py=1.32858,pz=4.65038e-16,theta=90,phi=10.0749
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.42714, px=4.35306,py=0.806531,pz=2.71084e-16,theta=90,phi=10.4967
DetSimAlg.G4Pri...   INFO Start a new event 3
ToolSvc.Edm4hep...   INFO Event 3
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1598 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1598 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.12388, px=6.97539,py=1.44695,pz=4.36212e-16,theta=90,phi=11.7191
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.952, px=9.77518,py=1.8677,pz=6.09384e-16,theta=90,phi=10.8169
DetSimAlg.G4Pri...   INFO Start a new event 4
ToolSvc.Edm4hep...   INFO Event 4
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 794 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 794 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.2924, px=3.23612,py=0.606159,pz=2.01602e-16,theta=90,phi=10.6092
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.24847, px=3.18379,py=0.645026,pz=1.98912e-16,theta=90,phi=11.4529
DetSimAlg.G4Pri...   INFO Start a new event 5
ToolSvc.Edm4hep...   INFO Event 5
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 812 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 812 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.99999, px=5.90621,py=1.05666,pz=3.67393e-16,theta=90,phi=10.1433
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.69673, px=6.59146,py=1.18272,pz=4.10057e-16,theta=90,phi=10.1725
DetSimAlg.G4Pri...   INFO Start a new event 6
ToolSvc.Edm4hep...   INFO Event 6
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1218 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1218 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.99757, px=3.93283,py=0.716559,pz=2.44781e-16,theta=90,phi=10.326
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.64742, px=8.46284,py=1.7771,pz=5.29501e-16,theta=90,phi=11.8592
DetSimAlg.G4Pri...   INFO Start a new event 7
ToolSvc.Edm4hep...   INFO Event 7
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1234 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1234 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.36087, px=1.33192,py=0.279184,pz=8.3329e-17,theta=90,phi=11.8384
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.22186, px=6.09446,py=1.25267,pz=3.80979e-16,theta=90,phi=11.6149
DetSimAlg.G4Pri...   INFO Start a new event 8
ToolSvc.Edm4hep...   INFO Event 8
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 678 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 678 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.09466, px=1.07292,py=0.217088,pz=6.70284e-17,theta=90,phi=11.4385
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.75266, px=6.6418,py=1.21856,pz=4.13481e-16,theta=90,phi=10.3964
DetSimAlg.G4Pri...   INFO Start a new event 9
ToolSvc.Edm4hep...   INFO Event 9
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1006 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1006 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.00101, px=8.80976,py=1.84561,pz=5.51153e-16,theta=90,phi=11.8321
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.70441, px=6.5791,py=1.29015,pz=4.10527e-16,theta=90,phi=11.0948
DetSimAlg.G4Pri...   INFO Start a new event 10
ToolSvc.Edm4hep...   INFO Event 10
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 945 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 945 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.53653, px=8.35254,py=1.7628,pz=5.22712e-16,theta=90,phi=11.9174
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.61101, px=4.53195,py=0.850242,pz=2.82343e-16,theta=90,phi=10.6258
DetSimAlg.G4Pri...   INFO Start a new event 11
ToolSvc.Edm4hep...   INFO Event 11
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1024 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1024 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.43864, px=5.33862,py=1.03828,pz=3.33021e-16,theta=90,phi=11.0057
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.59256, px=7.4442,py=1.49361,pz=4.6491e-16,theta=90,phi=11.3452
DetSimAlg.G4Pri...   INFO Start a new event 12
ToolSvc.Edm4hep...   INFO Event 12
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 759 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 759 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.11484, px=2.08044,py=0.37987,pz=1.29496e-16,theta=90,phi=10.3477
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.17715, px=1.15302,py=0.237125,pz=7.20796e-17,theta=90,phi=11.6212
DetSimAlg.G4Pri...   INFO Start a new event 13
ToolSvc.Edm4hep...   INFO Event 13
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 289 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 289 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.7643, px=3.69112,py=0.738609,pz=2.30497e-16,theta=90,phi=11.3157
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.41471, px=6.2982,py=1.21707,pz=3.92788e-16,theta=90,phi=10.9371
DetSimAlg.G4Pri...   INFO Start a new event 14
ToolSvc.Edm4hep...   INFO Event 14
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 926 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 926 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.58138, px=5.47832,py=1.06759,pz=3.41761e-16,theta=90,phi=11.0273
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.36947, px=3.317,py=0.592292,pz=2.0632e-16,theta=90,phi=10.1242
DetSimAlg.G4Pri...   INFO Start a new event 15
ToolSvc.Edm4hep...   INFO Event 15
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 728 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 728 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.70624, px=3.63639,py=0.71613,pz=2.26942e-16,theta=90,phi=11.1409
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.04031, px=4.93537,py=1.0232,pz=3.0863e-16,theta=90,phi=11.7126
DetSimAlg.G4Pri...   INFO Start a new event 16
ToolSvc.Edm4hep...   INFO Event 16
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 769 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 769 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.77128, px=2.71794,py=0.541105,pz=1.69692e-16,theta=90,phi=11.2596
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.6878, px=5.58412,py=1.08103,pz=3.48277e-16,theta=90,phi=10.9564
DetSimAlg.G4Pri...   INFO Start a new event 17
ToolSvc.Edm4hep...   INFO Event 17
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 614 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 614 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.12018, px=7.95539,py=1.62763,pz=4.97218e-16,theta=90,phi=11.5628
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.72616, px=8.56664,py=1.66092,pz=5.34323e-16,theta=90,phi=10.9725
DetSimAlg.G4Pri...   INFO Start a new event 18
ToolSvc.Edm4hep...   INFO Event 18
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1317 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1317 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.05085, px=4.96829,py=0.909468,pz=3.09275e-16,theta=90,phi=10.3734
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.80856, px=7.6358,py=1.63345,pz=4.78137e-16,theta=90,phi=12.0747
DetSimAlg.G4Pri...   INFO Start a new event 19
ToolSvc.Edm4hep...   INFO Event 19
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 598 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 598 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.77629, px=9.61054,py=1.79257,pz=5.98625e-16,theta=90,phi=10.5655
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.112, px=2.07855,py=0.374434,pz=1.29323e-16,theta=90,phi=10.2119
DetSimAlg.G4Pri...   INFO Start a new event 20
ToolSvc.Edm4hep...   INFO Event 20
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1006 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1006 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.31176, px=9.17025,py=1.61721,pz=5.70181e-16,theta=90,phi=10.0015
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.44973, px=3.39687,py=0.601587,pz=2.11235e-16,theta=90,phi=10.043
DetSimAlg.G4Pri...   INFO Start a new event 21
ToolSvc.Edm4hep...   INFO Event 21
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 994 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 994 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.6105, px=5.51433,py=1.03438,pz=3.43544e-16,theta=90,phi=10.6241
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.17885, px=6.06931,py=1.15829,pz=3.78345e-16,theta=90,phi=10.8046
DetSimAlg.G4Pri...   INFO Start a new event 22
ToolSvc.Edm4hep...   INFO Event 22
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1052 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1052 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.69628, px=1.66977,py=0.298719,pz=1.03867e-16,theta=90,phi=10.1428
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.91856, px=2.86987,py=0.530883,pz=1.7871e-16,theta=90,phi=10.4804
DetSimAlg.G4Pri...   INFO Start a new event 23
ToolSvc.Edm4hep...   INFO Event 23
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 860 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 860 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.95746, px=7.82921,py=1.42292,pz=4.87254e-16,theta=90,phi=10.3008
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.65574, px=2.59816,py=0.550014,pz=1.62617e-16,theta=90,phi=11.9527
DetSimAlg.G4Pri...   INFO Start a new event 24
ToolSvc.Edm4hep...   INFO Event 24
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 712 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 712 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.21367, px=6.09123,py=1.22743,pz=3.80478e-16,theta=90,phi=11.393
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.64573, px=6.52834,py=1.24363,pz=4.06934e-16,theta=90,phi=10.7855
DetSimAlg.G4Pri...   INFO Start a new event 25
ToolSvc.Edm4hep...   INFO Event 25
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 463 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 463 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.00128, px=8.84212,py=1.6852,pz=5.51169e-16,theta=90,phi=10.7905
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.24387, px=8.09031,py=1.58374,pz=5.04791e-16,theta=90,phi=11.076
DetSimAlg.G4Pri...   INFO Start a new event 26
ToolSvc.Edm4hep...   INFO Event 26
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1186 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1186 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.09163, px=4.98887,py=1.01777,pz=3.11772e-16,theta=90,phi=11.5306
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.93272, px=4.83566,py=0.973718,pz=3.02042e-16,theta=90,phi=11.3849
DetSimAlg.G4Pri...   INFO Start a new event 27
ToolSvc.Edm4hep...   INFO Event 27
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 738 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 738 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.1407, px=4.07198,py=0.751211,pz=2.53544e-16,theta=90,phi=10.4526
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.07576, px=4.01337,py=0.710389,pz=2.49568e-16,theta=90,phi=10.0377
DetSimAlg.G4Pri...   INFO Start a new event 28
ToolSvc.Edm4hep...   INFO Event 28
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 714 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 714 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.07211, px=3.99465,py=0.790457,pz=2.49345e-16,theta=90,phi=11.193
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.98399, px=9.81634,py=1.82193,pz=6.11343e-16,theta=90,phi=10.5145
DetSimAlg.G4Pri...   INFO Start a new event 29
ToolSvc.Edm4hep...   INFO Event 29
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 858 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 858 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.71661, px=8.56955,py=1.59435,pz=5.33738e-16,theta=90,phi=10.5393
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.16374, px=9.01393,py=1.65025,pz=5.61118e-16,theta=90,phi=10.3747
DetSimAlg.G4Pri...   INFO Start a new event 30
ToolSvc.Edm4hep...   INFO Event 30
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 939 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 939 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.64467, px=6.52106,py=1.27571,pz=4.06869e-16,theta=90,phi=11.069
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.59906, px=1.56459,py=0.33022,pz=9.79141e-17,theta=90,phi=11.9178
DetSimAlg.G4Pri...   INFO Start a new event 31
ToolSvc.Edm4hep...   INFO Event 31
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 483 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 483 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.70004, px=3.62428,py=0.744868,pz=2.26562e-16,theta=90,phi=11.6138
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.77429, px=6.65568,py=1.26211,pz=4.14806e-16,theta=90,phi=10.7374
DetSimAlg.G4Pri...   INFO Start a new event 32
ToolSvc.Edm4hep...   INFO Event 32
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 673 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 673 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.38768, px=1.36246,py=0.263396,pz=8.49711e-17,theta=90,phi=10.9417
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.82111, px=4.72481,py=0.958831,pz=2.95208e-16,theta=90,phi=11.4716
DetSimAlg.G4Pri...   INFO Start a new event 33
ToolSvc.Edm4hep...   INFO Event 33
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 499 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 499 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.23157, px=1.21125,py=0.222814,pz=7.5412e-17,theta=90,phi=10.4233
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.18202, px=7.05099,py=1.36565,pz=4.39772e-16,theta=90,phi=10.9614
DetSimAlg.G4Pri...   INFO Start a new event 34
ToolSvc.Edm4hep...   INFO Event 34
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 454 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 454 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.08408, px=3.02294,py=0.611044,pz=1.88846e-16,theta=90,phi=11.4275
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.39407, px=6.2744,py=1.23128,pz=3.91524e-16,theta=90,phi=11.1026
DetSimAlg.G4Pri...   INFO Start a new event 35
ToolSvc.Edm4hep...   INFO Event 35
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 495 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 495 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.46499, px=9.28301,py=1.84712,pz=5.79564e-16,theta=90,phi=11.2536
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.60752, px=1.57967,py=0.297925,pz=9.84324e-17,theta=90,phi=10.6805
DetSimAlg.G4Pri...   INFO Start a new event 36
ToolSvc.Edm4hep...   INFO Event 36
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 804 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 804 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.69876, px=4.61365,py=0.890244,pz=2.87716e-16,theta=90,phi=10.9215
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.49722, px=1.46962,py=0.286183,pz=9.16785e-17,theta=90,phi=11.0195
DetSimAlg.G4Pri...   INFO Start a new event 37
ToolSvc.Edm4hep...   INFO Event 37
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 719 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 719 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.27213, px=7.12366,py=1.46198,pz=4.4529e-16,theta=90,phi=11.5977
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.0931, px=3.03721,py=0.585365,pz=1.89398e-16,theta=90,phi=10.9089
DetSimAlg.G4Pri...   INFO Start a new event 38
ToolSvc.Edm4hep...   INFO Event 38
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 698 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 698 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.86841, px=8.68424,py=1.798,pz=5.43034e-16,theta=90,phi=11.6973
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.83714, px=1.79845,py=0.375067,pz=1.12493e-16,theta=90,phi=11.7802
DetSimAlg.G4Pri...   INFO Start a new event 39
ToolSvc.Edm4hep...   INFO Event 39
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1437 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1437 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.64372, px=5.54091,py=1.07235,pz=3.45578e-16,theta=90,phi=10.9532
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.22352, px=9.06297,py=1.71345,pz=5.64778e-16,theta=90,phi=10.706
DetSimAlg.G4Pri...   INFO Start a new event 40
ToolSvc.Edm4hep...   INFO Event 40
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 869 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 869 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.74414, px=7.58777,py=1.54837,pz=4.74192e-16,theta=90,phi=11.5335
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.4487, px=1.41989,py=0.287509,pz=8.87076e-17,theta=90,phi=11.4469
DetSimAlg.G4Pri...   INFO Start a new event 41
ToolSvc.Edm4hep...   INFO Event 41
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 618 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 618 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.46296, px=8.28208,py=1.74037,pz=5.18207e-16,theta=90,phi=11.8673
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.99388, px=8.84156,py=1.64825,pz=5.50716e-16,theta=90,phi=10.5599
DetSimAlg.G4Pri...   INFO Start a new event 42
ToolSvc.Edm4hep...   INFO Event 42
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 981 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 981 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.01953, px=3.93293,py=0.829889,pz=2.46125e-16,theta=90,phi=11.9152
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.41641, px=4.34776,py=0.775672,pz=2.70427e-16,theta=90,phi=10.1156
DetSimAlg.G4Pri...   INFO Start a new event 43
ToolSvc.Edm4hep...   INFO Event 43
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 579 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 579 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.46404, px=5.35941,py=1.06415,pz=3.34576e-16,theta=90,phi=11.2304
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.39587, px=1.37432,py=0.244353,pz=8.54727e-17,theta=90,phi=10.0818
DetSimAlg.G4Pri...   INFO Start a new event 44
ToolSvc.Edm4hep...   INFO Event 44
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1010 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1010 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.17994, px=3.12401,py=0.593738,pz=1.94715e-16,theta=90,phi=10.7611
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.32872, px=9.15022,py=1.81619,pz=5.7122e-16,theta=90,phi=11.2265
DetSimAlg.G4Pri...   INFO Start a new event 45
ToolSvc.Edm4hep...   INFO Event 45
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1536 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1536 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.63963, px=8.49511,py=1.57363,pz=5.29025e-16,theta=90,phi=10.4945
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.90833, px=8.76354,py=1.59957,pz=5.45478e-16,theta=90,phi=10.3441
DetSimAlg.G4Pri...   INFO Start a new event 46
ToolSvc.Edm4hep...   INFO Event 46
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 995 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 995 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.99902, px=5.87904,py=1.1938,pz=3.67334e-16,theta=90,phi=11.4784
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.96488, px=2.91982,py=0.514915,pz=1.81546e-16,theta=90,phi=10.0014
DetSimAlg.G4Pri...   INFO Start a new event 47
ToolSvc.Edm4hep...   INFO Event 47
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 575 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 575 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.00114, px=7.85321,py=1.53147,pz=4.89929e-16,theta=90,phi=11.0348
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.15565, px=3.09714,py=0.604858,pz=1.93228e-16,theta=90,phi=11.0505
DetSimAlg.G4Pri...   INFO Start a new event 48
ToolSvc.Edm4hep...   INFO Event 48
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 889 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 889 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.51725, px=5.40689,py=1.09797,pz=3.37834e-16,theta=90,phi=11.4789
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.5324, px=5.42261,py=1.0967,pz=3.38762e-16,theta=90,phi=11.4336
DetSimAlg.G4Pri...   INFO Start a new event 49
ToolSvc.Edm4hep...   INFO Event 49
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1125 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1125 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.75266, px=2.69902,py=0.540752,pz=1.68552e-16,theta=90,phi=11.3293
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.62276, px=2.5657,py=0.544106,pz=1.60598e-16,theta=90,phi=11.9733
DetSimAlg.G4Pri...   INFO Start a new event 50
ToolSvc.Edm4hep...   INFO Event 50
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 703 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 703 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.76868, px=7.61586,py=1.53333,pz=4.75695e-16,theta=90,phi=11.3834
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.19594, px=5.09084,py=1.03977,pz=3.1816e-16,theta=90,phi=11.5435
DetSimAlg.G4Pri...   INFO Start a new event 51
ToolSvc.Edm4hep...   INFO Event 51
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 628 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 628 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.67581, px=8.4917,py=1.77783,pz=5.3124e-16,theta=90,phi=11.8247
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.46881, px=5.38059,py=0.978354,pz=3.34868e-16,theta=90,phi=10.3055
DetSimAlg.G4Pri...   INFO Start a new event 52
ToolSvc.Edm4hep...   INFO Event 52
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 889 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 889 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.02303, px=6.89315,py=1.34442,pz=4.30036e-16,theta=90,phi=11.0363
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.47961, px=3.40834,py=0.700679,pz=2.13065e-16,theta=90,phi=11.6169
DetSimAlg.G4Pri...   INFO Start a new event 53
ToolSvc.Edm4hep...   INFO Event 53
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 561 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 561 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.31836, px=7.19131,py=1.35774,pz=4.4812e-16,theta=90,phi=10.6917
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.80067, px=2.75521,py=0.502602,pz=1.71492e-16,theta=90,phi=10.3382
DetSimAlg.G4Pri...   INFO Start a new event 54
ToolSvc.Edm4hep...   INFO Event 54
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1531 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1531 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.04454, px=2.00674,py=0.391366,pz=1.25192e-16,theta=90,phi=11.0357
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.71554, px=7.57224,py=1.48007,pz=4.7244e-16,theta=90,phi=11.0596
DetSimAlg.G4Pri...   INFO Start a new event 55
ToolSvc.Edm4hep...   INFO Event 55
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 716 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 716 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.73268, px=2.68961,py=0.483214,pz=1.67328e-16,theta=90,phi=10.185
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.26943, px=6.15663,py=1.18391,pz=3.83892e-16,theta=90,phi=10.885
DetSimAlg.G4Pri...   INFO Start a new event 56
ToolSvc.Edm4hep...   INFO Event 56
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 480 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 480 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.07005, px=4.98921,py=0.901783,pz=3.10451e-16,theta=90,phi=10.2454
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.04938, px=5.93887,py=1.15099,pz=3.70418e-16,theta=90,phi=10.9683
DetSimAlg.G4Pri...   INFO Start a new event 57
ToolSvc.Edm4hep...   INFO Event 57
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 916 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 916 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.66897, px=9.47457,py=1.9291,pz=5.92053e-16,theta=90,phi=11.5086
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.10634, px=2.0655,py=0.412761,pz=1.28976e-16,theta=90,phi=11.3009
DetSimAlg.G4Pri...   INFO Start a new event 58
ToolSvc.Edm4hep...   INFO Event 58
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 872 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 872 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.95626, px=4.84808,py=1.02991,pz=3.03484e-16,theta=90,phi=11.9935
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.21651, px=1.19438,py=0.230954,pz=7.44896e-17,theta=90,phi=10.944
DetSimAlg.G4Pri...   INFO Start a new event 59
ToolSvc.Edm4hep...   INFO Event 59
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 784 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 784 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.33642, px=2.29087,py=0.459073,pz=1.43064e-16,theta=90,phi=11.3315
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.72832, px=4.64931,py=0.860813,pz=2.89526e-16,theta=90,phi=10.4895
DetSimAlg.G4Pri...   INFO Start a new event 60
ToolSvc.Edm4hep...   INFO Event 60
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1283 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1283 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.72648, px=4.64668,py=0.864881,pz=2.89414e-16,theta=90,phi=10.5437
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.54704, px=5.4416,py=1.0764,pz=3.39658e-16,theta=90,phi=11.1892
DetSimAlg.G4Pri...   INFO Start a new event 61
ToolSvc.Edm4hep...   INFO Event 61
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 608 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 608 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.72393, px=9.57395,py=1.70128,pz=5.95419e-16,theta=90,phi=10.0762
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.97788, px=3.89085,py=0.827528,pz=2.43575e-16,theta=90,phi=12.0071
DetSimAlg.G4Pri...   INFO Start a new event 62
ToolSvc.Edm4hep...   INFO Event 62
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 742 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 742 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.74749, px=3.67999,py=0.708047,pz=2.29467e-16,theta=90,phi=10.8909
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.56711, px=1.54299,py=0.273907,pz=9.5958e-17,theta=90,phi=10.0661
DetSimAlg.G4Pri...   INFO Start a new event 63
ToolSvc.Edm4hep...   INFO Event 63
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 427 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 427 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.4268, px=3.36718,py=0.636451,pz=2.09831e-16,theta=90,phi=10.7036
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.5982, px=5.49737,py=1.05774,pz=3.42791e-16,theta=90,phi=10.8911
DetSimAlg.G4Pri...   INFO Start a new event 64
ToolSvc.Edm4hep...   INFO Event 64
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1136 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1136 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.13684, px=7.00355,py=1.37285,pz=4.37005e-16,theta=90,phi=11.0906
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.13332, px=8.9585,py=1.77842,pz=5.59255e-16,theta=90,phi=11.2282
DetSimAlg.G4Pri...   INFO Start a new event 65
ToolSvc.Edm4hep...   INFO Event 65
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1218 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1218 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.25757, px=2.21485,py=0.437068,pz=1.38236e-16,theta=90,phi=11.163
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.5083, px=8.3206,py=1.77727,pz=5.20983e-16,theta=90,phi=12.0571
DetSimAlg.G4Pri...   INFO Start a new event 66
ToolSvc.Edm4hep...   INFO Event 66
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 615 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 615 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.09551, px=3.02815,py=0.642257,pz=1.89545e-16,theta=90,phi=11.9747
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.08302, px=6.95837,py=1.32298,pz=4.3371e-16,theta=90,phi=10.765
DetSimAlg.G4Pri...   INFO Start a new event 67
ToolSvc.Edm4hep...   INFO Event 67
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 744 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 744 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.18362, px=8.00348,py=1.70763,pz=5.01102e-16,theta=90,phi=12.0441
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.16437, px=8.99816,py=1.73746,pz=5.61156e-16,theta=90,phi=10.9288
DetSimAlg.G4Pri...   INFO Start a new event 68
ToolSvc.Edm4hep...   INFO Event 68
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1102 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1102 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.64204, px=4.56629,py=0.835216,pz=2.84243e-16,theta=90,phi=10.3653
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.24471, px=3.18654,py=0.611654,pz=1.98681e-16,theta=90,phi=10.8657
DetSimAlg.G4Pri...   INFO Start a new event 69
ToolSvc.Edm4hep...   INFO Event 69
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 675 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 675 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.40488, px=8.23765,py=1.66827,pz=5.1465e-16,theta=90,phi=11.4486
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.18608, px=8.05074,py=1.4824,pz=5.01253e-16,theta=90,phi=10.4331
DetSimAlg.G4Pri...   INFO Start a new event 70
ToolSvc.Edm4hep...   INFO Event 70
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 682 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 682 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.28645, px=7.17424,py=1.2738,pz=4.46166e-16,theta=90,phi=10.0681
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.3115, px=9.14761,py=1.73933,pz=5.70165e-16,theta=90,phi=10.7657
DetSimAlg.G4Pri...   INFO Start a new event 71
ToolSvc.Edm4hep...   INFO Event 71
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1223 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1223 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.44712, px=5.3367,py=1.09122,pz=3.3354e-16,theta=90,phi=11.5562
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.27313, px=8.09864,py=1.69019,pz=5.06583e-16,theta=90,phi=11.7885
DetSimAlg.G4Pri...   INFO Start a new event 72
ToolSvc.Edm4hep...   INFO Event 72
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 946 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 946 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.93786, px=5.81256,py=1.2134,pz=3.63589e-16,theta=90,phi=11.7914
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.80719, px=9.62726,py=1.87003,pz=6.00517e-16,theta=90,phi=10.9925
DetSimAlg.G4Pri...   INFO Start a new event 73
ToolSvc.Edm4hep...   INFO Event 73
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 878 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 878 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.18667, px=8.05026,py=1.4882,pz=5.01289e-16,theta=90,phi=10.4737
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.37562, px=2.33262,py=0.449945,pz=1.45465e-16,theta=90,phi=10.9178
DetSimAlg.G4Pri...   INFO Start a new event 74
ToolSvc.Edm4hep...   INFO Event 74
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 678 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 678 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.49117, px=7.37047,py=1.33931,pz=4.58702e-16,theta=90,phi=10.299
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.94586, px=4.83774,py=1.02851,pz=3.02847e-16,theta=90,phi=12.0025
DetSimAlg.G4Pri...   INFO Start a new event 75
ToolSvc.Edm4hep...   INFO Event 75
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1224 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1224 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.24416, px=5.13515,py=1.0637,pz=3.21112e-16,theta=90,phi=11.7028
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.5314, px=9.37788,py=1.70381,pz=5.8363e-16,theta=90,phi=10.2974
DetSimAlg.G4Pri...   INFO Start a new event 76
ToolSvc.Edm4hep...   INFO Event 76
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 989 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 989 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.53444, px=5.43865,py=1.02521,pz=3.38887e-16,theta=90,phi=10.6753
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.0914, px=6.93386,py=1.48644,pz=4.34223e-16,theta=90,phi=12.0996
DetSimAlg.G4Pri...   INFO Start a new event 77
ToolSvc.Edm4hep...   INFO Event 77
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 968 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 968 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.208, px=1.18743,py=0.221973,pz=7.39689e-17,theta=90,phi=10.5884
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.59472, px=3.52652,py=0.696926,pz=2.20113e-16,theta=90,phi=11.179
DetSimAlg.G4Pri...   INFO Start a new event 78
ToolSvc.Edm4hep...   INFO Event 78
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 397 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 397 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.12344, px=7.01208,py=1.25465,pz=4.36185e-16,theta=90,phi=10.1444
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.84289, px=6.7058,py=1.3629,pz=4.19006e-16,theta=90,phi=11.4884
DetSimAlg.G4Pri...   INFO Start a new event 79
ToolSvc.Edm4hep...   INFO Event 79
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1119 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1119 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.19168, px=8.03829,py=1.57782,pz=5.01596e-16,theta=90,phi=11.1053
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.95558, px=4.84806,py=1.02668,pz=3.03442e-16,theta=90,phi=11.957
DetSimAlg.G4Pri...   INFO Start a new event 80
ToolSvc.Edm4hep...   INFO Event 80
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 907 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 907 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.24334, px=7.12512,py=1.30334,pz=4.43527e-16,theta=90,phi=10.3661
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.1975, px=5.08364,py=1.08195,pz=3.18255e-16,theta=90,phi=12.0149
DetSimAlg.G4Pri...   INFO Start a new event 81
ToolSvc.Edm4hep...   INFO Event 81
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1149 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1149 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=6.71817, px=6.59581,py=1.27638,pz=4.11369e-16,theta=90,phi=10.9522
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.95812, px=9.79976,py=1.76885,pz=6.09759e-16,theta=90,phi=10.2317
DetSimAlg.G4Pri...   INFO Start a new event 82
ToolSvc.Edm4hep...   INFO Event 82
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 544 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 544 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.71324, px=3.64145,py=0.726583,pz=2.2737e-16,theta=90,phi=11.2841
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.97885, px=7.83593,py=1.50341,pz=4.88563e-16,theta=90,phi=10.8608
DetSimAlg.G4Pri...   INFO Start a new event 83
ToolSvc.Edm4hep...   INFO Event 83
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 873 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 873 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.75042, px=2.69473,py=0.550648,pz=1.68415e-16,theta=90,phi=11.549
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.28649, px=2.24315,py=0.443115,pz=1.40007e-16,theta=90,phi=11.1744
DetSimAlg.G4Pri...   INFO Start a new event 84
ToolSvc.Edm4hep...   INFO Event 84
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 426 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 426 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.5825, px=1.55691,py=0.28339,pz=9.68999e-17,theta=90,phi=10.316
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.46425, px=1.44147,py=0.25729,pz=8.96594e-17,theta=90,phi=10.1203
DetSimAlg.G4Pri...   INFO Start a new event 85
ToolSvc.Edm4hep...   INFO Event 85
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 348 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 348 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.40731, px=5.31877,py=0.974523,pz=3.31102e-16,theta=90,phi=10.3828
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.08403, px=4.99989,py=0.921137,pz=3.11307e-16,theta=90,phi=10.4386
DetSimAlg.G4Pri...   INFO Start a new event 86
ToolSvc.Edm4hep...   INFO Event 86
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 777 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 777 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.06749, px=6.94959,py=1.28555,pz=4.32759e-16,theta=90,phi=10.4803
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.6216, px=2.5696,py=0.519578,pz=1.60527e-16,theta=90,phi=11.4312
DetSimAlg.G4Pri...   INFO Start a new event 87
ToolSvc.Edm4hep...   INFO Event 87
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 564 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 564 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.93681, px=8.79638,py=1.57808,pz=5.47222e-16,theta=90,phi=10.1708
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.02896, px=6.91598,py=1.2552,pz=4.304e-16,theta=90,phi=10.2868
DetSimAlg.G4Pri...   INFO Start a new event 88
ToolSvc.Edm4hep...   INFO Event 88
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1388 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1388 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.92712, px=2.87443,py=0.552893,pz=1.79234e-16,theta=90,phi=10.8878
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.08263, px=3.03307,py=0.55058,pz=1.88757e-16,theta=90,phi=10.2886
DetSimAlg.G4Pri...   INFO Start a new event 89
ToolSvc.Edm4hep...   INFO Event 89
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 992 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 992 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.54582, px=8.39029,py=1.62295,pz=5.2328e-16,theta=90,phi=10.9476
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.33158, px=7.176,py=1.50236,pz=4.4893e-16,theta=90,phi=11.8246
DetSimAlg.G4Pri...   INFO Start a new event 90
ToolSvc.Edm4hep...   INFO Event 90
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 841 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 841 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.24744, px=2.20085,py=0.455235,pz=1.37616e-16,theta=90,phi=11.6866
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=2.40843, px=2.36887,py=0.434713,pz=1.47474e-16,theta=90,phi=10.3987
DetSimAlg.G4Pri...   INFO Start a new event 91
ToolSvc.Edm4hep...   INFO Event 91
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 411 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 411 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.48009, px=5.37813,py=1.05218,pz=3.35559e-16,theta=90,phi=11.0695
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.27786, px=3.22442,py=0.589462,pz=2.00711e-16,theta=90,phi=10.3599
DetSimAlg.G4Pri...   INFO Start a new event 92
ToolSvc.Edm4hep...   INFO Event 92
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 681 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 681 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.19011, px=7.07678,py=1.27152,pz=4.40267e-16,theta=90,phi=10.186
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.42248, px=9.24304,py=1.83011,pz=5.76961e-16,theta=90,phi=11.1997
DetSimAlg.G4Pri...   INFO Start a new event 93
ToolSvc.Edm4hep...   INFO Event 93
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1090 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1090 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.33685, px=9.15362,py=1.84065,pz=5.71717e-16,theta=90,phi=11.3696
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=1.19635, px=1.17802,py=0.208629,pz=7.32551e-17,theta=90,phi=10.0431
DetSimAlg.G4Pri...   INFO Start a new event 94
ToolSvc.Edm4hep...   INFO Event 94
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 861 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 861 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=7.14985, px=7.02436,py=1.33371,pz=4.37802e-16,theta=90,phi=10.7507
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.02369, px=4.91363,py=1.04578,pz=3.07612e-16,theta=90,phi=12.0151
DetSimAlg.G4Pri...   INFO Start a new event 95
ToolSvc.Edm4hep...   INFO Event 95
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 781 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 781 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=5.9841, px=5.86764,py=1.17485,pz=3.6642e-16,theta=90,phi=11.3224
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=3.39841, px=3.34428,py=0.604143,pz=2.08093e-16,theta=90,phi=10.24
DetSimAlg.G4Pri...   INFO Start a new event 96
ToolSvc.Edm4hep...   INFO Event 96
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 720 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 720 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.63952, px=8.48357,py=1.63414,pz=5.29018e-16,theta=90,phi=10.903
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.67117, px=8.50861,py=1.67118,pz=5.30956e-16,theta=90,phi=11.1121
DetSimAlg.G4Pri...   INFO Start a new event 97
ToolSvc.Edm4hep...   INFO Event 97
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1086 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1086 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=8.25193, px=8.09858,py=1.58342,pz=5.05285e-16,theta=90,phi=11.0628
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.52215, px=9.33551,py=1.8761,pz=5.83064e-16,theta=90,phi=11.363
DetSimAlg.G4Pri...   INFO Start a new event 98
ToolSvc.Edm4hep...   INFO Event 98
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 1438 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 1438 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=9.47771, px=9.30194,py=1.81688,pz=5.80343e-16,theta=90,phi=11.052
ToolSvc.GtGunTool    INFO According to the gamma get 0x2549c1d0
GenGt p=4.86981, px=4.7806,py=0.927856,pz=2.9819e-16,theta=90,phi=10.9838
DetSimAlg.G4Pri...   INFO Start a new event 99
ToolSvc.Edm4hep...   INFO Event 99
ToolSvc.Edm4hep...   INFO mcCol size (original) : 2
ToolSvc.Edm4hep...   INFO mcCol size (after simulation) : 2
ToolSvc.Edm4hep...   INFO Readout EcalBarrelCollection
ToolSvc.Edm4hep...   INFO Collection EcalBarrelCollection #0 has 788 hits.
ToolSvc.Edm4hep...   INFO  cast to G4THitsCollection<dd4hep::sim::Geant4Hit>. 
ToolSvc.Edm4hep...   INFO 0 hits cast to dd4hep::sim::Geant4TrackerHit. 
ToolSvc.Edm4hep...   INFO 788 hits cast to dd4hep::sim::Geant4CalorimeterHit. 
ApplicationMgr       INFO Application Manager Stopped successfully
End Run of detector simultion...
EventLoopMgr         INFO Histograms converted successfully according to request.
ToolSvc              INFO Removing all tools created by ToolSvc
ApplicationMgr       INFO Application Manager Finalized successfully
ApplicationMgr       INFO Application Manager Terminated successfully
